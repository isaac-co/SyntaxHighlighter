<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">""" Non-negative matrix factorization.
"""</span>
<span class="comment"># Author: Vlad Niculae</span>
<span class="comment">#         Lars Buitinck</span>
<span class="comment">#         Mathieu Blondel &lt;mathieu@mblondel.org&gt;</span>
<span class="comment">#         Tom Dupre la Tour</span>
<span class="comment"># License: BSD 3 clause</span>

<span class="keyword">import</span> <span class="identifier">numbers</span>
<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">import</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">sparse</span> <span class="keyword">as</span> <span class="identifier">sp</span>
<span class="keyword">import</span> <span class="identifier">time</span>
<span class="keyword">import</span> <span class="identifier">warnings</span>
<span class="keyword">from</span> <span class="identifier">math</span> <span class="keyword">import</span> <span class="identifier">sqrt</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_cdnmf_fast</span> <span class="keyword">import</span> <span class="identifier">_update_cdnmf_fast</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">_config</span> <span class="keyword">import</span> <span class="identifier">config_context</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">BaseEstimator</span><span class="punctuation">,</span> <span class="identifier">TransformerMixin</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="invalid">e</span><span class="invalid">x</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="invalid">i</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">s</span> <span class="keyword">import</span> <span class="identifier">ConvergenceWarning</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">check_random_state</span><span class="punctuation">,</span> <span class="identifier">check_array</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">extmath</span> <span class="keyword">import</span> <span class="identifier">randomized_svd</span><span class="punctuation">,</span> <span class="identifier">safe_sparse_dot</span><span class="punctuation">,</span> <span class="identifier">squared_norm</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_is_fitted</span><span class="punctuation">,</span> <span class="identifier">check_non_negative</span>

<span class="identifier">EPSILON</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span>


<span class="keyword">def</span> <span class="identifier">norm</span><span class="grouping">(</span><span class="identifier">x</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Dot product-based Euclidean norm implementation.

    See: http://fseoane.net/blog/2011/computing-the-vector-norm/

    Parameters
    ----------
    x : array-like
        Vector for which to compute the norm.
    """</span>
    <span class="keyword">return</span> <span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">squared_norm</span><span class="grouping">(</span><span class="identifier">x</span><span class="grouping">)</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">trace_dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">Y</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Trace of np.dot(X, Y.T).

    Parameters
    ----------
    X : array-like
        First matrix.
    Y : array-like
        Second matrix.
    """</span>
    <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">Y</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_check_init</span><span class="grouping">(</span><span class="identifier">A</span><span class="punctuation">,</span> <span class="identifier">shape</span><span class="punctuation">,</span> <span class="identifier">whom</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="identifier">A</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">A</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">(</span><span class="identifier">A</span><span class="grouping">)</span> <span class="relational-operator">!=</span> <span class="identifier">shape</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'Array with wrong shape passed to %s. Expected %s, '</span>
                         <span class="string-literal">'but got %s '</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">whom</span><span class="punctuation">,</span> <span class="identifier">shape</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">(</span><span class="identifier">A</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="identifier">check_non_negative</span><span class="grouping">(</span><span class="identifier">A</span><span class="punctuation">,</span> <span class="identifier">whom</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">max</span><span class="grouping">(</span><span class="identifier">A</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'Array passed to %s is full of zeros.'</span> <span class="arithmetic-operator">%</span> <span class="identifier">whom</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_beta_divergence</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">beta</span><span class="punctuation">,</span> <span class="identifier">square_root</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Compute the beta-divergence of X and dot(W, H).

    Parameters
    ----------
    X : float or array-like of shape (n_samples, n_features)

    W : float or array-like of shape (n_samples, n_components)

    H : float or array-like of shape (n_components, n_features)

    beta : float or {'frobenius', 'kullback-leibler', 'itakura-saito'}
        Parameter of the beta-divergence.
        If beta == 2, this is half the Frobenius *squared* norm.
        If beta == 1, this is the generalized Kullback-Leibler divergence.
        If beta == 0, this is the Itakura-Saito divergence.
        Else, this is the general beta-divergence.

    square_root : bool, default=False
        If True, return np.sqrt(2 * res)
        For beta == 2, it corresponds to the Frobenius norm.

    Returns
    -------
        res : float
            Beta divergence of X and np.dot(X, H).
    """</span>
    <span class="identifier">beta</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_beta_loss_to_float</span><span class="grouping">(</span><span class="identifier">beta</span><span class="grouping">)</span>

    <span class="comment"># The method can be called with scalars</span>
    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">atleast_2d</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="identifier">W</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">atleast_2d</span><span class="grouping">(</span><span class="identifier">W</span><span class="grouping">)</span>
    <span class="identifier">H</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">atleast_2d</span><span class="grouping">(</span><span class="identifier">H</span><span class="grouping">)</span>

    <span class="comment"># Frobenius norm</span>
    <span class="keyword">if</span> <span class="identifier">beta</span> <span class="relational-operator">==</span> <span class="int-literal">2</span><span class="punctuation">:</span>
        <span class="comment"># Avoid the creation of the dense np.dot(W, H) if X is sparse.</span>
        <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">norm_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">data</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">data</span><span class="grouping">)</span>
            <span class="identifier">norm_WH</span> <span class="arithmetic-assignment">=</span> <span class="identifier">trace_dot</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">multi_dot</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">W</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="grouping">)</span>
            <span class="identifier">cross_prod</span> <span class="arithmetic-assignment">=</span> <span class="identifier">trace_dot</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">X</span> <span class="arithmetic-operator">*</span> <span class="identifier">H</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="grouping">)</span>
            <span class="identifier">res</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">norm_X</span> <span class="arithmetic-operator">+</span> <span class="identifier">norm_WH</span> <span class="arithmetic-operator">-</span> <span class="int-literal">2</span><span class="punctuation">.</span> <span class="arithmetic-operator">*</span> <span class="identifier">cross_prod</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="int-literal">2</span><span class="punctuation">.</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">res</span> <span class="arithmetic-assignment">=</span> <span class="identifier">squared_norm</span><span class="grouping">(</span><span class="identifier">X</span> <span class="arithmetic-operator">-</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="grouping">)</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="int-literal">2</span><span class="punctuation">.</span>

        <span class="keyword">if</span> <span class="identifier">square_root</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">res</span> <span class="arithmetic-operator">*</span> <span class="int-literal">2</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">res</span>

    <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># compute np.dot(W, H) only where X is nonzero</span>
        <span class="identifier">WH_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_special_sparse_dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">data</span>
        <span class="identifier">X_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">data</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">WH</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="grouping">)</span>
        <span class="identifier">WH_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">WH</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">X_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="comment"># do not affect the zeros: here 0 ** (-1) = 0 and not infinity</span>
    <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_data</span> <span class="relational-operator">&gt;</span> <span class="identifier">EPSILON</span>
    <span class="identifier">WH_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">WH_data</span><span class="grouping">[</span><span class="identifier">indices</span><span class="grouping">]</span>
    <span class="identifier">X_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_data</span><span class="grouping">[</span><span class="identifier">indices</span><span class="grouping">]</span>

    <span class="comment"># used to avoid division by zero</span>
    <span class="identifier">WH_data</span><span class="grouping">[</span><span class="identifier">WH_data</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">EPSILON</span>

    <span class="comment"># generalized Kullback-Leibler divergence</span>
    <span class="keyword">if</span> <span class="identifier">beta</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="comment"># fast and memory efficient computation of np.sum(np.dot(W, H))</span>
        <span class="identifier">sum_WH</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="comment"># computes np.sum(X * log(X / WH)) only where X is nonzero</span>
        <span class="identifier">div</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_data</span> <span class="arithmetic-operator">/</span> <span class="identifier">WH_data</span>
        <span class="identifier">res</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X_data</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">log</span><span class="grouping">(</span><span class="identifier">div</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="comment"># add full np.sum(np.dot(W, H)) - np.sum(X)</span>
        <span class="identifier">res</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">sum_WH</span> <span class="arithmetic-operator">-</span> <span class="identifier">X_data</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="comment"># Itakura-Saito divergence</span>
    <span class="keyword">elif</span> <span class="identifier">beta</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
        <span class="identifier">div</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_data</span> <span class="arithmetic-operator">/</span> <span class="identifier">WH_data</span>
        <span class="identifier">res</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">div</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">product</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">log</span><span class="grouping">(</span><span class="identifier">div</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="comment"># beta-divergence, beta not in (0, 1, 2)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># slow loop, but memory efficient computation of :</span>
            <span class="comment"># np.sum(np.dot(W, H) ** beta)</span>
            <span class="identifier">sum_WH_beta</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
            <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">sum_WH_beta</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="grouping">]</span><span class="grouping">)</span> <span class="arithmetic-operator">**</span> <span class="identifier">beta</span><span class="grouping">)</span>

        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">sum_WH_beta</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">WH</span> <span class="arithmetic-operator">**</span> <span class="identifier">beta</span><span class="grouping">)</span>

        <span class="identifier">sum_X_WH</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X_data</span><span class="punctuation">,</span> <span class="identifier">WH_data</span> <span class="arithmetic-operator">**</span> <span class="grouping">(</span><span class="identifier">beta</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">res</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">X_data</span> <span class="arithmetic-operator">**</span> <span class="identifier">beta</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">beta</span> <span class="arithmetic-operator">*</span> <span class="identifier">sum_X_WH</span>
        <span class="identifier">res</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">sum_WH_beta</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="identifier">beta</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">)</span>
        <span class="identifier">res</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">beta</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="identifier">beta</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">square_root</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="int-literal">2</span> <span class="arithmetic-operator">*</span> <span class="identifier">res</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">res</span>


<span class="keyword">def</span> <span class="identifier">_special_sparse_dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Computes np.dot(W, H), only where X is non zero."""</span>
    <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">ii</span><span class="punctuation">,</span> <span class="identifier">jj</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">nonzero</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">n_vals</span> <span class="arithmetic-assignment">=</span> <span class="identifier">ii</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">dot_vals</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">n_vals</span><span class="grouping">)</span>
        <span class="identifier">n_components</span> <span class="arithmetic-assignment">=</span> <span class="identifier">W</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>

        <span class="identifier">batch_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max</span><span class="grouping">(</span><span class="identifier">n_components</span><span class="punctuation">,</span> <span class="identifier">n_vals</span> <span class="arithmetic-operator">//</span> <span class="identifier">n_components</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">start</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">n_vals</span><span class="punctuation">,</span> <span class="identifier">batch_size</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">batch</span> <span class="arithmetic-assignment">=</span> <span class="identifier">slice</span><span class="grouping">(</span><span class="identifier">start</span><span class="punctuation">,</span> <span class="identifier">start</span> <span class="arithmetic-operator">+</span> <span class="identifier">batch_size</span><span class="grouping">)</span>
            <span class="identifier">dot_vals</span><span class="grouping">[</span><span class="identifier">batch</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">multiply</span><span class="grouping">(</span><span class="identifier">W</span><span class="grouping">[</span><span class="identifier">ii</span><span class="grouping">[</span><span class="identifier">batch</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span><span class="punctuation">,</span>
                                          <span class="identifier">H</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">jj</span><span class="grouping">[</span><span class="identifier">batch</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span>

        <span class="identifier">WH</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">coo_matrix</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">dot_vals</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">ii</span><span class="punctuation">,</span> <span class="identifier">jj</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">shape</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">WH</span><span class="punctuation">.</span><span class="identifier">tocsr</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_compute_regularization</span><span class="grouping">(</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">l1_ratio</span><span class="punctuation">,</span> <span class="identifier">regularization</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Compute L1 and L2 regularization coefficients for W and H."""</span>
    <span class="identifier">alpha_H</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>
    <span class="identifier">alpha_W</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>
    <span class="keyword">if</span> <span class="identifier">regularization</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="string-literal">'both', 'components'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">alpha_H</span> <span class="arithmetic-assignment">=</span> <span class="identifier">float</span><span class="grouping">(</span><span class="identifier">alpha</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">regularization</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="string-literal">'both', 'transformation'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">alpha_W</span> <span class="arithmetic-assignment">=</span> <span class="identifier">float</span><span class="grouping">(</span><span class="identifier">alpha</span><span class="grouping">)</span>

    <span class="identifier">l1_reg_W</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha_W</span> <span class="arithmetic-operator">*</span> <span class="identifier">l1_ratio</span>
    <span class="identifier">l1_reg_H</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha_H</span> <span class="arithmetic-operator">*</span> <span class="identifier">l1_ratio</span>
    <span class="identifier">l2_reg_W</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha_W</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">-</span> <span class="identifier">l1_ratio</span><span class="grouping">)</span>
    <span class="identifier">l2_reg_H</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha_H</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">-</span> <span class="identifier">l1_ratio</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">l1_reg_W</span><span class="punctuation">,</span> <span class="identifier">l1_reg_H</span><span class="punctuation">,</span> <span class="identifier">l2_reg_W</span><span class="punctuation">,</span> <span class="identifier">l2_reg_H</span>


<span class="keyword">def</span> <span class="identifier">_check_string_param</span><span class="grouping">(</span><span class="identifier">solver</span><span class="punctuation">,</span> <span class="identifier">regularization</span><span class="punctuation">,</span> <span class="identifier">beta_loss</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="identifier">allowed_solver</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="string-literal">'cd', 'mu'</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">solver</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="identifier">allowed_solver</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
            <span class="string-literal">'Invalid solver parameter: got %r instead of one of %r'</span> <span class="arithmetic-operator">%</span>
            <span class="grouping">(</span><span class="identifier">solver</span><span class="punctuation">,</span> <span class="identifier">allowed_solver</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="identifier">allowed_regularization</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="string-literal">'both', 'components', 'transformation'</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">regularization</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="identifier">allowed_regularization</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
            <span class="string-literal">'Invalid regularization parameter: got %r instead of one of %r'</span> <span class="arithmetic-operator">%</span>
            <span class="grouping">(</span><span class="identifier">regularization</span><span class="punctuation">,</span> <span class="identifier">allowed_regularization</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="comment"># 'mu' is the only solver that handles other beta losses than 'frobenius'</span>
    <span class="keyword">if</span> <span class="identifier">solver</span> <span class="relational-operator">!=</span> <span class="string-literal">'mu' and beta_loss not in (2, 'frobenius'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
            <span class="string-literal">'Invalid beta_loss parameter: solver %r does not handle beta_loss'</span>
            <span class="string-literal">' = %r'</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">solver</span><span class="punctuation">,</span> <span class="identifier">beta_loss</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">solver</span> <span class="relational-operator">==</span> <span class="string-literal">'mu' and init == 'nndsvd'</span><span class="punctuation">:</span>
        <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">"The multiplicative update ('mu') solver cannot update "</span>
                      <span class="string-literal">"zeros present in the initialization, and so leads to "</span>
                      <span class="string-literal">"poorer results when used jointly with init='nndsvd'. "</span>
                      <span class="string-literal">"You may try init='nndsvda' or init='nndsvdar' instead."</span><span class="punctuation">,</span>
                      <span class="identifier">UserWarning</span><span class="grouping">)</span>

    <span class="identifier">beta_loss</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_beta_loss_to_float</span><span class="grouping">(</span><span class="identifier">beta_loss</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">beta_loss</span>


<span class="keyword">def</span> <span class="identifier">_beta_loss_to_float</span><span class="grouping">(</span><span class="identifier">beta_loss</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Convert string beta_loss to float."""</span>
    <span class="identifier">allowed_beta_loss</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="string-literal">'frobenius'</span><span class="punctuation">:</span> <span class="int-literal">2</span><span class="punctuation">,</span>
                         <span class="string-literal">'kullback-leibler'</span><span class="punctuation">:</span> <span class="int-literal">1</span><span class="punctuation">,</span>
                         <span class="string-literal">'itakura-saito'</span><span class="punctuation">:</span> <span class="int-literal">0</span><span class="grouping">}</span>
    <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">beta_loss</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">beta_loss</span> <span class="relational-operator">in</span> <span class="identifier">allowed_beta_loss</span><span class="punctuation">:</span>
        <span class="identifier">beta_loss</span> <span class="arithmetic-assignment">=</span> <span class="identifier">allowed_beta_loss</span><span class="grouping">[</span><span class="identifier">beta_loss</span><span class="grouping">]</span>

    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">beta_loss</span><span class="punctuation">,</span> <span class="identifier">numbers</span><span class="punctuation">.</span><span class="identifier">Number</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'Invalid beta_loss parameter: got %r instead '</span>
                         <span class="string-literal">'of one of %r, or a float.'</span> <span class="arithmetic-operator">%</span>
                         <span class="grouping">(</span><span class="identifier">beta_loss</span><span class="punctuation">,</span> <span class="identifier">allowed_beta_loss</span><span class="punctuation">.</span><span class="identifier">keys</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">beta_loss</span>


<span class="keyword">def</span> <span class="identifier">_initialize_nmf</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">n_components</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="arithmetic-assignment">=</span><span class="string-literal">'warn'</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-6</span><span class="punctuation">,</span>
                    <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Algorithms for NMF initialization.

    Computes an initial guess for the non-negative
    rank k matrix approximation for X: X = WH.

    Parameters
    ----------
    X : array-like of shape (n_samples, n_features)
        The data matrix to be decomposed.

    n_components : int
        The number of components desired in the approximation.

    init :  {'random', 'nndsvd', 'nndsvda', 'nndsvdar'}, default=None
        Method used to initialize the procedure.
        Default: None.
        Valid options:

        - None: 'nndsvd' if n_components &lt;= min(n_samples, n_features),
            otherwise 'random'.

        - 'random': non-negative random matrices, scaled with:
            sqrt(X.mean() / n_components)

        - 'nndsvd': Nonnegative Double Singular Value Decomposition (NNDSVD)
            initialization (better for sparseness)

        - 'nndsvda': NNDSVD with zeros filled with the average of X
            (better when sparsity is not desired)

        - 'nndsvdar': NNDSVD with zeros filled with small random values
            (generally faster, less accurate alternative to NNDSVDa
            for when sparsity is not desired)

        - 'custom': use custom matrices W and H

    eps : float, default=1e-6
        Truncate all values less then this in output to zero.

    random_state : int, RandomState instance or None, default=None
        Used when ``init`` == 'nndsvdar' or 'random'. Pass an int for
        reproducible results across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    Returns
    -------
    W : array-like of shape (n_samples, n_components)
        Initial guesses for solving X ~= WH.

    H : array-like of shape (n_components, n_features)
        Initial guesses for solving X ~= WH.

    References
    ----------
    C. Boutsidis, E. Gallopoulos: SVD based initialization: A head start for
    nonnegative matrix factorization - Pattern Recognition, 2008
    http://tinyurl.com/nndsvd
    """</span>
    <span class="keyword">if</span> <span class="identifier">init</span> <span class="relational-operator">==</span> <span class="string-literal">'warn'</span><span class="punctuation">:</span>
        <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="grouping">(</span><span class="string-literal">"The 'init' value, when 'init=None' and "</span>
                       <span class="string-literal">"n_components is less than n_samples and "</span>
                       <span class="string-literal">"n_features, will be changed from 'nndsvd' to "</span>
                       <span class="string-literal">"'nndsvda' in 1.1 (renaming of 0.26)."</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">FutureWarning</span><span class="grouping">)</span>
        <span class="identifier">init</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>

    <span class="identifier">check_non_negative</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="string-literal">"NMF initialization"</span><span class="grouping">)</span>
    <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>

    <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">init</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">init</span> <span class="relational-operator">!=</span> <span class="string-literal">'random'</span>
            <span class="logical-operator">and</span> <span class="identifier">n_components</span> <span class="relational-operator">&gt;</span> <span class="identifier">min</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"init = '{}' can only be used when "</span>
                         <span class="string-literal">"n_components &lt;= min(n_samples, n_features)"</span>
                         <span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">init</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">init</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">n_components</span> <span class="relational-operator">&lt;=</span> <span class="identifier">min</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">init</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'nndsvd'</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">init</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'random'</span>

    <span class="comment"># Random initialization</span>
    <span class="keyword">if</span> <span class="identifier">init</span> <span class="relational-operator">==</span> <span class="string-literal">'random'</span><span class="punctuation">:</span>
        <span class="identifier">avg</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">n_components</span><span class="grouping">)</span>
        <span class="identifier">rng</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="identifier">H</span> <span class="arithmetic-assignment">=</span> <span class="identifier">avg</span> <span class="arithmetic-operator">*</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">randn</span><span class="grouping">(</span><span class="identifier">n_components</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span>
                                                             <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">W</span> <span class="arithmetic-assignment">=</span> <span class="identifier">avg</span> <span class="arithmetic-operator">*</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">randn</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_components</span><span class="grouping">)</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span>
                                                            <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">out</span><span class="arithmetic-assignment">=</span><span class="identifier">H</span><span class="grouping">)</span>
        <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">out</span><span class="arithmetic-assignment">=</span><span class="identifier">W</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span>

    <span class="comment"># NNDSVD initialization</span>
    <span class="identifier">U</span><span class="punctuation">,</span> <span class="identifier">S</span><span class="punctuation">,</span> <span class="identifier">V</span> <span class="arithmetic-assignment">=</span> <span class="identifier">randomized_svd</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">n_components</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>
    <span class="identifier">W</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros_like</span><span class="grouping">(</span><span class="identifier">U</span><span class="grouping">)</span>
    <span class="identifier">H</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros_like</span><span class="grouping">(</span><span class="identifier">V</span><span class="grouping">)</span>

    <span class="comment"># The leading singular triplet is non-negative</span>
    <span class="comment"># so it can be used as is for initialization.</span>
    <span class="identifier">W</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">S</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">U</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>
    <span class="identifier">H</span><span class="grouping">[</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">S</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">V</span><span class="grouping">[</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span><span class="grouping">)</span>

    <span class="keyword">for</span> <span class="identifier">j</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">n_components</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">x</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">U</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">j</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">V</span><span class="grouping">[</span><span class="identifier">j</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span>

        <span class="comment"># extract positive and negative parts of column vectors</span>
        <span class="identifier">x_p</span><span class="punctuation">,</span> <span class="identifier">y_p</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">maximum</span><span class="grouping">(</span><span class="identifier">x</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">maximum</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span>
        <span class="identifier">x_n</span><span class="punctuation">,</span> <span class="identifier">y_n</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">minimum</span><span class="grouping">(</span><span class="identifier">x</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">minimum</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="comment"># and their norms</span>
        <span class="identifier">x_p_nrm</span><span class="punctuation">,</span> <span class="identifier">y_p_nrm</span> <span class="arithmetic-assignment">=</span> <span class="identifier">norm</span><span class="grouping">(</span><span class="identifier">x_p</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">norm</span><span class="grouping">(</span><span class="identifier">y_p</span><span class="grouping">)</span>
        <span class="identifier">x_n_nrm</span><span class="punctuation">,</span> <span class="identifier">y_n_nrm</span> <span class="arithmetic-assignment">=</span> <span class="identifier">norm</span><span class="grouping">(</span><span class="identifier">x_n</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">norm</span><span class="grouping">(</span><span class="identifier">y_n</span><span class="grouping">)</span>

        <span class="identifier">m_p</span><span class="punctuation">,</span> <span class="identifier">m_n</span> <span class="arithmetic-assignment">=</span> <span class="identifier">x_p_nrm</span> <span class="arithmetic-operator">*</span> <span class="identifier">y_p_nrm</span><span class="punctuation">,</span> <span class="identifier">x_n_nrm</span> <span class="arithmetic-operator">*</span> <span class="identifier">y_n_nrm</span>

        <span class="comment"># choose update</span>
        <span class="keyword">if</span> <span class="identifier">m_p</span> <span class="relational-operator">&gt;</span> <span class="identifier">m_n</span><span class="punctuation">:</span>
            <span class="identifier">u</span> <span class="arithmetic-assignment">=</span> <span class="identifier">x_p</span> <span class="arithmetic-operator">/</span> <span class="identifier">x_p_nrm</span>
            <span class="identifier">v</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y_p</span> <span class="arithmetic-operator">/</span> <span class="identifier">y_p_nrm</span>
            <span class="identifier">sigma</span> <span class="arithmetic-assignment">=</span> <span class="identifier">m_p</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">u</span> <span class="arithmetic-assignment">=</span> <span class="identifier">x_n</span> <span class="arithmetic-operator">/</span> <span class="identifier">x_n_nrm</span>
            <span class="identifier">v</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y_n</span> <span class="arithmetic-operator">/</span> <span class="identifier">y_n_nrm</span>
            <span class="identifier">sigma</span> <span class="arithmetic-assignment">=</span> <span class="identifier">m_n</span>

        <span class="identifier">lbd</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">S</span><span class="grouping">[</span><span class="identifier">j</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">sigma</span><span class="grouping">)</span>
        <span class="identifier">W</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">j</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">lbd</span> <span class="arithmetic-operator">*</span> <span class="identifier">u</span>
        <span class="identifier">H</span><span class="grouping">[</span><span class="identifier">j</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">lbd</span> <span class="arithmetic-operator">*</span> <span class="identifier">v</span>

    <span class="identifier">W</span><span class="grouping">[</span><span class="identifier">W</span> <span class="relational-operator">&lt;</span> <span class="identifier">eps</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
    <span class="identifier">H</span><span class="grouping">[</span><span class="identifier">H</span> <span class="relational-operator">&lt;</span> <span class="identifier">eps</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>

    <span class="keyword">if</span> <span class="identifier">init</span> <span class="relational-operator">==</span> <span class="string-literal">"nndsvd"</span><span class="punctuation">:</span>
        <span class="keyword">pass</span>
    <span class="keyword">elif</span> <span class="identifier">init</span> <span class="relational-operator">==</span> <span class="string-literal">"nndsvda"</span><span class="punctuation">:</span>
        <span class="identifier">avg</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">W</span><span class="grouping">[</span><span class="identifier">W</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">avg</span>
        <span class="identifier">H</span><span class="grouping">[</span><span class="identifier">H</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">avg</span>
    <span class="keyword">elif</span> <span class="identifier">init</span> <span class="relational-operator">==</span> <span class="string-literal">"nndsvdar"</span><span class="punctuation">:</span>
        <span class="identifier">rng</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="identifier">avg</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">W</span><span class="grouping">[</span><span class="identifier">W</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">avg</span> <span class="arithmetic-operator">*</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">randn</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">W</span><span class="grouping">[</span><span class="identifier">W</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="int-literal">100</span><span class="grouping">)</span>
        <span class="identifier">H</span><span class="grouping">[</span><span class="identifier">H</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">avg</span> <span class="arithmetic-operator">*</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">randn</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">H</span><span class="grouping">[</span><span class="identifier">H</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="int-literal">100</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
            <span class="string-literal">'Invalid init parameter: got %r instead of one of %r'</span> <span class="arithmetic-operator">%</span>
            <span class="grouping">(</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="string-literal">'random', 'nndsvd', 'nndsvda', 'nndsvdar'</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span>


<span class="keyword">def</span> <span class="identifier">_update_coordinate_descent</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">Ht</span><span class="punctuation">,</span> <span class="identifier">l1_reg</span><span class="punctuation">,</span> <span class="identifier">l2_reg</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="punctuation">,</span>
                               <span class="identifier">random_state</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Helper function for _fit_coordinate_descent.

    Update W to minimize the objective function, iterating once over all
    coordinates. By symmetry, to update H, one can call
    _update_coordinate_descent(X.T, Ht, W, ...).

    """</span>
    <span class="identifier">n_components</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Ht</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>

    <span class="identifier">HHt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">Ht</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">Ht</span><span class="grouping">)</span>
    <span class="identifier">XHt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">Ht</span><span class="grouping">)</span>

    <span class="comment"># L2 regularization corresponds to increase of the diagonal of HHt</span>
    <span class="keyword">if</span> <span class="identifier">l2_reg</span> <span class="relational-operator">!=</span> <span class="int-literal">0</span><span class="punctuation">.</span><span class="punctuation">:</span>
        <span class="comment"># adds l2_reg only on the diagonal</span>
        <span class="identifier">HHt</span><span class="punctuation">.</span><span class="identifier">flat</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="identifier">n_components</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">l2_reg</span>
    <span class="comment"># L1 regularization corresponds to decrease of each element of XHt</span>
    <span class="keyword">if</span> <span class="identifier">l1_reg</span> <span class="relational-operator">!=</span> <span class="int-literal">0</span><span class="punctuation">.</span><span class="punctuation">:</span>
        <span class="identifier">XHt</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">l1_reg</span>

    <span class="keyword">if</span> <span class="identifier">shuffle</span><span class="punctuation">:</span>
        <span class="identifier">permutation</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span><span class="punctuation">.</span><span class="identifier">permutation</span><span class="grouping">(</span><span class="identifier">n_components</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">permutation</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">n_components</span><span class="grouping">)</span>
    <span class="comment"># The following seems to be required on 64-bit Windows w/ Python 3.5.</span>
    <span class="identifier">permutation</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">permutation</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">intp</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">_update_cdnmf_fast</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">HHt</span><span class="punctuation">,</span> <span class="identifier">XHt</span><span class="punctuation">,</span> <span class="identifier">permutation</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_fit_coordinate_descent</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">200</span><span class="punctuation">,</span> <span class="identifier">l1_reg_W</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span>
                            <span class="identifier">l1_reg_H</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">l2_reg_W</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">l2_reg_H</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">update_H</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                            <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Compute Non-negative Matrix Factorization (NMF) with Coordinate Descent

    The objective function is minimized with an alternating minimization of W
    and H. Each minimization is done with a cyclic (up to a permutation of the
    features) Coordinate Descent.

    Parameters
    ----------
    X : array-like of shape (n_samples, n_features)
        Constant matrix.

    W : array-like of shape (n_samples, n_components)
        Initial guess for the solution.

    H : array-like of shape (n_components, n_features)
        Initial guess for the solution.

    tol : float, default=1e-4
        Tolerance of the stopping condition.

    max_iter : int, default=200
        Maximum number of iterations before timing out.

    l1_reg_W : float, default=0.
        L1 regularization parameter for W.

    l1_reg_H : float, default=0.
        L1 regularization parameter for H.

    l2_reg_W : float, default=0.
        L2 regularization parameter for W.

    l2_reg_H : float, default=0.
        L2 regularization parameter for H.

    update_H : bool, default=True
        Set to True, both W and H will be estimated from initial guesses.
        Set to False, only W will be estimated.

    verbose : int, default=0
        The verbosity level.

    shuffle : bool, default=False
        If true, randomize the order of coordinates in the CD solver.

    random_state : int, RandomState instance or None, default=None
        Used to randomize the coordinates in the CD solver, when
        ``shuffle`` is set to ``True``. Pass an int for reproducible
        results across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    Returns
    -------
    W : ndarray of shape (n_samples, n_components)
        Solution to the non-negative least squares problem.

    H : ndarray of shape (n_components, n_features)
        Solution to the non-negative least squares problem.

    n_iter : int
        The number of iterations done by the algorithm.

    References
    ----------
    Cichocki, Andrzej, and Phan, Anh-Huy. "Fast local algorithms for
    large scale nonnegative matrix and tensor factorizations."
    IEICE transactions on fundamentals of electronics, communications and
    computer sciences 92.3: 708-721, 2009.
    """</span>
    <span class="comment"># so W and Ht are both in C order in memory</span>
    <span class="identifier">Ht</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">H</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'C'</span><span class="grouping">)</span>
    <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csr'</span><span class="grouping">)</span>

    <span class="identifier">rng</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">random_state</span><span class="grouping">)</span>

    <span class="keyword">for</span> <span class="identifier">n_iter</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">max_iter</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">violation</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>

        <span class="comment"># Update W</span>
        <span class="identifier">violation</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">_update_coordinate_descent</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">Ht</span><span class="punctuation">,</span> <span class="identifier">l1_reg_W</span><span class="punctuation">,</span>
                                                <span class="identifier">l2_reg_W</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="punctuation">,</span> <span class="identifier">rng</span><span class="grouping">)</span>
        <span class="comment"># Update H</span>
        <span class="keyword">if</span> <span class="identifier">update_H</span><span class="punctuation">:</span>
            <span class="identifier">violation</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">_update_coordinate_descent</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">Ht</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">l1_reg_H</span><span class="punctuation">,</span>
                                                    <span class="identifier">l2_reg_H</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="punctuation">,</span> <span class="identifier">rng</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">n_iter</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">violation_init</span> <span class="arithmetic-assignment">=</span> <span class="identifier">violation</span>

        <span class="keyword">if</span> <span class="identifier">violation_init</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">break</span>

        <span class="keyword">if</span> <span class="identifier">verbose</span><span class="punctuation">:</span>
            <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"violation:"</span><span class="punctuation">,</span> <span class="identifier">violation</span> <span class="arithmetic-operator">/</span> <span class="identifier">violation_init</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">violation</span> <span class="arithmetic-operator">/</span> <span class="identifier">violation_init</span> <span class="relational-operator">&lt;=</span> <span class="identifier">tol</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">verbose</span><span class="punctuation">:</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"Converged at iteration"</span><span class="punctuation">,</span> <span class="identifier">n_iter</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span>
            <span class="keyword">break</span>

    <span class="keyword">return</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">Ht</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">n_iter</span>


<span class="keyword">def</span> <span class="identifier">_multiplicative_update_w</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">beta_loss</span><span class="punctuation">,</span> <span class="identifier">l1_reg_W</span><span class="punctuation">,</span> <span class="identifier">l2_reg_W</span><span class="punctuation">,</span> <span class="identifier">gamma</span><span class="punctuation">,</span>
                             <span class="identifier">H_sum</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">HHt</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">XHt</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">update_H</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Update W in Multiplicative Update NMF."""</span>
    <span class="keyword">if</span> <span class="identifier">beta_loss</span> <span class="relational-operator">==</span> <span class="int-literal">2</span><span class="punctuation">:</span>
        <span class="comment"># Numerator</span>
        <span class="keyword">if</span> <span class="identifier">XHt</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">XHt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">update_H</span><span class="punctuation">:</span>
            <span class="comment"># avoid a copy of XHt, which will be re-computed (update_H=True)</span>
            <span class="identifier">numerator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">XHt</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># preserve the XHt, which is not re-computed (update_H=False)</span>
            <span class="identifier">numerator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">XHt</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="grouping">)</span>

        <span class="comment"># Denominator</span>
        <span class="keyword">if</span> <span class="identifier">HHt</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">HHt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span>
        <span class="identifier">denominator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">HHt</span><span class="grouping">)</span>

    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="comment"># Numerator</span>
        <span class="comment"># if X is sparse, compute WH only where X is non zero</span>
        <span class="identifier">WH_safe_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_special_sparse_dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">WH_safe_X_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">WH_safe_X</span><span class="punctuation">.</span><span class="identifier">data</span>
            <span class="identifier">X_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">data</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">WH_safe_X_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">WH_safe_X</span>
            <span class="identifier">X_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
            <span class="comment"># copy used in the Denominator</span>
            <span class="identifier">WH</span> <span class="arithmetic-assignment">=</span> <span class="identifier">WH_safe_X</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">beta_loss</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="punctuation">.</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
                <span class="identifier">WH</span><span class="grouping">[</span><span class="identifier">WH</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">EPSILON</span>

        <span class="comment"># to avoid taking a negative power of zero</span>
        <span class="keyword">if</span> <span class="identifier">beta_loss</span> <span class="arithmetic-operator">-</span> <span class="int-literal">2</span><span class="punctuation">.</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="identifier">WH_safe_X_data</span><span class="grouping">[</span><span class="identifier">WH_safe_X_data</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">EPSILON</span>

        <span class="keyword">if</span> <span class="identifier">beta_loss</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">divide</span><span class="grouping">(</span><span class="identifier">X_data</span><span class="punctuation">,</span> <span class="identifier">WH_safe_X_data</span><span class="punctuation">,</span> <span class="identifier">out</span><span class="arithmetic-assignment">=</span><span class="identifier">WH_safe_X_data</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">beta_loss</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="comment"># speeds up computation time</span>
            <span class="comment"># refer to /numpy/numpy/issues/9363</span>
            <span class="identifier">WH_safe_X_data</span> <span class="arithmetic-assignment">**=</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span>
            <span class="identifier">WH_safe_X_data</span> <span class="arithmetic-assignment">**=</span> <span class="int-literal">2</span>
            <span class="comment"># element-wise multiplication</span>
            <span class="identifier">WH_safe_X_data</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">X_data</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">WH_safe_X_data</span> <span class="arithmetic-assignment">**=</span> <span class="identifier">beta_loss</span> <span class="arithmetic-operator">-</span> <span class="int-literal">2</span>
            <span class="comment"># element-wise multiplication</span>
            <span class="identifier">WH_safe_X_data</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">X_data</span>

        <span class="comment"># here numerator = dot(X * (dot(W, H) ** (beta_loss - 2)), H.T)</span>
        <span class="identifier">numerator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">WH_safe_X</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span>

        <span class="comment"># Denominator</span>
        <span class="keyword">if</span> <span class="identifier">beta_loss</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">H_sum</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                <span class="identifier">H_sum</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span>  <span class="comment"># shape(n_components, )</span>
            <span class="identifier">denominator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">H_sum</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span>

        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># computation of WHHt = dot(dot(W, H) ** beta_loss - 1, H.T)</span>
            <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="comment"># memory efficient computation</span>
                <span class="comment"># (compute row by row, avoiding the dense matrix WH)</span>
                <span class="identifier">WHHt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span>
                <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">WHi</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="grouping">[</span><span class="identifier">i</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="grouping">)</span>
                    <span class="keyword">if</span> <span class="identifier">beta_loss</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
                        <span class="identifier">WHi</span><span class="grouping">[</span><span class="identifier">WHi</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">EPSILON</span>
                    <span class="identifier">WHi</span> <span class="arithmetic-assignment">**=</span> <span class="identifier">beta_loss</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span>
                    <span class="identifier">WHHt</span><span class="grouping">[</span><span class="identifier">i</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">WHi</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">WH</span> <span class="arithmetic-assignment">**=</span> <span class="identifier">beta_loss</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span>
                <span class="identifier">WHHt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">WH</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span>
            <span class="identifier">denominator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">WHHt</span>

    <span class="comment"># Add L1 and L2 regularization</span>
    <span class="keyword">if</span> <span class="identifier">l1_reg_W</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
        <span class="identifier">denominator</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">l1_reg_W</span>
    <span class="keyword">if</span> <span class="identifier">l2_reg_W</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
        <span class="identifier">denominator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">denominator</span> <span class="arithmetic-operator">+</span> <span class="identifier">l2_reg_W</span> <span class="arithmetic-operator">*</span> <span class="identifier">W</span>
    <span class="identifier">denominator</span><span class="grouping">[</span><span class="identifier">denominator</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">EPSILON</span>

    <span class="identifier">numerator</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">denominator</span>
    <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span><span class="invalid">W</span> <span class="arithmetic-assignment">=</span> <span class="identifier">numerator</span>

    <span class="comment"># gamma is in ]0, 1]</span>
    <span class="keyword">if</span> <span class="identifier">gamma</span> <span class="relational-operator">!=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span><span class="invalid">W</span> <span class="arithmetic-assignment">**=</span> <span class="identifier">gamma</span>

    <span class="keyword">return</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span><span class="invalid">W</span><span class="punctuation">,</span> <span class="identifier">H_sum</span><span class="punctuation">,</span> <span class="identifier">HHt</span><span class="punctuation">,</span> <span class="identifier">XHt</span>


<span class="keyword">def</span> <span class="identifier">_multiplicative_update_h</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">beta_loss</span><span class="punctuation">,</span> <span class="identifier">l1_reg_H</span><span class="punctuation">,</span> <span class="identifier">l2_reg_H</span><span class="punctuation">,</span> <span class="identifier">gamma</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Update H in Multiplicative Update NMF."""</span>
    <span class="keyword">if</span> <span class="identifier">beta_loss</span> <span class="relational-operator">==</span> <span class="int-literal">2</span><span class="punctuation">:</span>
        <span class="identifier">numerator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">denominator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">multi_dot</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">W</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="grouping">]</span><span class="grouping">)</span>

    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="comment"># Numerator</span>
        <span class="identifier">WH_safe_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_special_sparse_dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">WH_safe_X_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">WH_safe_X</span><span class="punctuation">.</span><span class="identifier">data</span>
            <span class="identifier">X_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">data</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">WH_safe_X_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">WH_safe_X</span>
            <span class="identifier">X_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
            <span class="comment"># copy used in the Denominator</span>
            <span class="identifier">WH</span> <span class="arithmetic-assignment">=</span> <span class="identifier">WH_safe_X</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">beta_loss</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="punctuation">.</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
                <span class="identifier">WH</span><span class="grouping">[</span><span class="identifier">WH</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">EPSILON</span>

        <span class="comment"># to avoid division by zero</span>
        <span class="keyword">if</span> <span class="identifier">beta_loss</span> <span class="arithmetic-operator">-</span> <span class="int-literal">2</span><span class="punctuation">.</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="identifier">WH_safe_X_data</span><span class="grouping">[</span><span class="identifier">WH_safe_X_data</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">EPSILON</span>

        <span class="keyword">if</span> <span class="identifier">beta_loss</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">divide</span><span class="grouping">(</span><span class="identifier">X_data</span><span class="punctuation">,</span> <span class="identifier">WH_safe_X_data</span><span class="punctuation">,</span> <span class="identifier">out</span><span class="arithmetic-assignment">=</span><span class="identifier">WH_safe_X_data</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">beta_loss</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="comment"># speeds up computation time</span>
            <span class="comment"># refer to /numpy/numpy/issues/9363</span>
            <span class="identifier">WH_safe_X_data</span> <span class="arithmetic-assignment">**=</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span>
            <span class="identifier">WH_safe_X_data</span> <span class="arithmetic-assignment">**=</span> <span class="int-literal">2</span>
            <span class="comment"># element-wise multiplication</span>
            <span class="identifier">WH_safe_X_data</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">X_data</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">WH_safe_X_data</span> <span class="arithmetic-assignment">**=</span> <span class="identifier">beta_loss</span> <span class="arithmetic-operator">-</span> <span class="int-literal">2</span>
            <span class="comment"># element-wise multiplication</span>
            <span class="identifier">WH_safe_X_data</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">X_data</span>

        <span class="comment"># here numerator = dot(W.T, (dot(W, H) ** (beta_loss - 2)) * X)</span>
        <span class="identifier">numerator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">WH_safe_X</span><span class="grouping">)</span>

        <span class="comment"># Denominator</span>
        <span class="keyword">if</span> <span class="identifier">beta_loss</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">W_sum</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>  <span class="comment"># shape(n_components, )</span>
            <span class="identifier">W_sum</span><span class="grouping">[</span><span class="identifier">W_sum</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span><span class="punctuation">.</span>
            <span class="identifier">denominator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">W_sum</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>

        <span class="comment"># beta_loss not in (1, 2)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># computation of WtWH = dot(W.T, dot(W, H) ** beta_loss - 1)</span>
            <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="comment"># memory efficient computation</span>
                <span class="comment"># (compute column by column, avoiding the dense matrix WH)</span>
                <span class="identifier">WtWH</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">H</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span>
                <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">WHi</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="grouping">]</span><span class="grouping">)</span>
                    <span class="keyword">if</span> <span class="identifier">beta_loss</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
                        <span class="identifier">WHi</span><span class="grouping">[</span><span class="identifier">WHi</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">EPSILON</span>
                    <span class="identifier">WHi</span> <span class="arithmetic-assignment">**=</span> <span class="identifier">beta_loss</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span>
                    <span class="identifier">WtWH</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">WHi</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">WH</span> <span class="arithmetic-assignment">**=</span> <span class="identifier">beta_loss</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span>
                <span class="identifier">WtWH</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">WH</span><span class="grouping">)</span>
            <span class="identifier">denominator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">WtWH</span>

    <span class="comment"># Add L1 and L2 regularization</span>
    <span class="keyword">if</span> <span class="identifier">l1_reg_H</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
        <span class="identifier">denominator</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">l1_reg_H</span>
    <span class="keyword">if</span> <span class="identifier">l2_reg_H</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
        <span class="identifier">denominator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">denominator</span> <span class="arithmetic-operator">+</span> <span class="identifier">l2_reg_H</span> <span class="arithmetic-operator">*</span> <span class="identifier">H</span>
    <span class="identifier">denominator</span><span class="grouping">[</span><span class="identifier">denominator</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">EPSILON</span>

    <span class="identifier">numerator</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">denominator</span>
    <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span><span class="invalid">H</span> <span class="arithmetic-assignment">=</span> <span class="identifier">numerator</span>

    <span class="comment"># gamma is in ]0, 1]</span>
    <span class="keyword">if</span> <span class="identifier">gamma</span> <span class="relational-operator">!=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span><span class="invalid">H</span> <span class="arithmetic-assignment">**=</span> <span class="identifier">gamma</span>

    <span class="keyword">return</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span><span class="invalid">H</span>


<span class="keyword">def</span> <span class="identifier">_fit_multiplicative_update</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">beta_loss</span><span class="arithmetic-assignment">=</span><span class="string-literal">'frobenius'</span><span class="punctuation">,</span>
                               <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">200</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span>
                               <span class="identifier">l1_reg_W</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">l1_reg_H</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">l2_reg_W</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">l2_reg_H</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span>
                               <span class="identifier">update_H</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Compute Non-negative Matrix Factorization with Multiplicative Update.

    The objective function is _beta_divergence(X, WH) and is minimized with an
    alternating minimization of W and H. Each minimization is done with a
    Multiplicative Update.

    Parameters
    ----------
    X : array-like of shape (n_samples, n_features)
        Constant input matrix.

    W : array-like of shape (n_samples, n_components)
        Initial guess for the solution.

    H : array-like of shape (n_components, n_features)
        Initial guess for the solution.

    beta_loss : float or {'frobenius', 'kullback-leibler', \
            'itakura-saito'}, default='frobenius'
        String must be in {'frobenius', 'kullback-leibler', 'itakura-saito'}.
        Beta divergence to be minimized, measuring the distance between X
        and the dot product WH. Note that values different from 'frobenius'
        (or 2) and 'kullback-leibler' (or 1) lead to significantly slower
        fits. Note that for beta_loss &lt;= 0 (or 'itakura-saito'), the input
        matrix X cannot contain zeros.

    max_iter : int, default=200
        Number of iterations.

    tol : float, default=1e-4
        Tolerance of the stopping condition.

    l1_reg_W : float, default=0.
        L1 regularization parameter for W.

    l1_reg_H : float, default=0.
        L1 regularization parameter for H.

    l2_reg_W : float, default=0.
        L2 regularization parameter for W.

    l2_reg_H : float, default=0.
        L2 regularization parameter for H.

    update_H : bool, default=True
        Set to True, both W and H will be estimated from initial guesses.
        Set to False, only W will be estimated.

    verbose : int, default=0
        The verbosity level.

    Returns
    -------
    W : ndarray of shape (n_samples, n_components)
        Solution to the non-negative least squares problem.

    H : ndarray of shape (n_components, n_features)
        Solution to the non-negative least squares problem.

    n_iter : int
        The number of iterations done by the algorithm.

    References
    ----------
    Fevotte, C., & Idier, J. (2011). Algorithms for nonnegative matrix
    factorization with the beta-divergence. Neural Computation, 23(9).
    """</span>
    <span class="identifier">start_time</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="punctuation">.</span><span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="identifier">beta_loss</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_beta_loss_to_float</span><span class="grouping">(</span><span class="identifier">beta_loss</span><span class="grouping">)</span>

    <span class="comment"># gamma for Maximization-Minimization (MM) algorithm [Fevotte 2011]</span>
    <span class="keyword">if</span> <span class="identifier">beta_loss</span> <span class="relational-operator">&lt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="identifier">gamma</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="int-literal">2</span><span class="punctuation">.</span> <span class="arithmetic-operator">-</span> <span class="identifier">beta_loss</span><span class="grouping">)</span>
    <span class="keyword">elif</span> <span class="identifier">beta_loss</span> <span class="relational-operator">&gt;</span> <span class="int-literal">2</span><span class="punctuation">:</span>
        <span class="identifier">gamma</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">beta_loss</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="punctuation">.</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">gamma</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span><span class="punctuation">.</span>

    <span class="comment"># used for the convergence criterion</span>
    <span class="identifier">error_at_init</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_beta_divergence</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">beta_loss</span><span class="punctuation">,</span> <span class="identifier">square_root</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
    <span class="identifier">previous_error</span> <span class="arithmetic-assignment">=</span> <span class="identifier">error_at_init</span>

    <span class="identifier">H_sum</span><span class="punctuation">,</span> <span class="identifier">HHt</span><span class="punctuation">,</span> <span class="identifier">XHt</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="punctuation">,</span> <span class="none-literal">None</span>
    <span class="keyword">for</span> <span class="identifier">n_iter</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">max_iter</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># update W</span>
        <span class="comment"># H_sum, HHt and XHt are saved and reused if not update_H</span>
        <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span><span class="invalid">W</span><span class="punctuation">,</span> <span class="identifier">H_sum</span><span class="punctuation">,</span> <span class="identifier">HHt</span><span class="punctuation">,</span> <span class="identifier">XHt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_multiplicative_update_w</span><span class="grouping">(</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">beta_loss</span><span class="punctuation">,</span> <span class="identifier">l1_reg_W</span><span class="punctuation">,</span> <span class="identifier">l2_reg_W</span><span class="punctuation">,</span> <span class="identifier">gamma</span><span class="punctuation">,</span>
            <span class="identifier">H_sum</span><span class="punctuation">,</span> <span class="identifier">HHt</span><span class="punctuation">,</span> <span class="identifier">XHt</span><span class="punctuation">,</span> <span class="identifier">update_H</span><span class="grouping">)</span>
        <span class="identifier">W</span> <span class="arithmetic-assignment">*=</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span><span class="invalid">W</span>

        <span class="comment"># necessary for stability with beta_loss &lt; 1</span>
        <span class="keyword">if</span> <span class="identifier">beta_loss</span> <span class="relational-operator">&lt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">W</span><span class="grouping">[</span><span class="identifier">W</span> <span class="relational-operator">&lt;</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>

        <span class="comment"># update H</span>
        <span class="keyword">if</span> <span class="identifier">update_H</span><span class="punctuation">:</span>
            <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span><span class="invalid">H</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_multiplicative_update_h</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">beta_loss</span><span class="punctuation">,</span> <span class="identifier">l1_reg_H</span><span class="punctuation">,</span>
                                               <span class="identifier">l2_reg_H</span><span class="punctuation">,</span> <span class="identifier">gamma</span><span class="grouping">)</span>
            <span class="identifier">H</span> <span class="arithmetic-assignment">*=</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span><span class="invalid">H</span>

            <span class="comment"># These values will be recomputed since H changed</span>
            <span class="identifier">H_sum</span><span class="punctuation">,</span> <span class="identifier">HHt</span><span class="punctuation">,</span> <span class="identifier">XHt</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="punctuation">,</span> <span class="none-literal">None</span>

            <span class="comment"># necessary for stability with beta_loss &lt; 1</span>
            <span class="keyword">if</span> <span class="identifier">beta_loss</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="identifier">H</span><span class="grouping">[</span><span class="identifier">H</span> <span class="relational-operator">&lt;</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>

        <span class="comment"># test convergence criterion every 10 iterations</span>
        <span class="keyword">if</span> <span class="identifier">tol</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span> <span class="logical-operator">and</span> <span class="identifier">n_iter</span> <span class="arithmetic-operator">%</span> <span class="int-literal">10</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="identifier">error</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_beta_divergence</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">beta_loss</span><span class="punctuation">,</span> <span class="identifier">square_root</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="identifier">verbose</span><span class="punctuation">:</span>
                <span class="identifier">iter_time</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="punctuation">.</span><span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"Epoch %02d reached after %.3f seconds, error: %f"</span> <span class="arithmetic-operator">%</span>
                      <span class="grouping">(</span><span class="identifier">n_iter</span><span class="punctuation">,</span> <span class="identifier">iter_time</span> <span class="arithmetic-operator">-</span> <span class="identifier">start_time</span><span class="punctuation">,</span> <span class="identifier">error</span><span class="grouping">)</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">previous_error</span> <span class="arithmetic-operator">-</span> <span class="identifier">error</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">error_at_init</span> <span class="relational-operator">&lt;</span> <span class="identifier">tol</span><span class="punctuation">:</span>
                <span class="keyword">break</span>
            <span class="identifier">previous_error</span> <span class="arithmetic-assignment">=</span> <span class="identifier">error</span>

    <span class="comment"># do not print if we have already printed in the convergence test</span>
    <span class="keyword">if</span> <span class="identifier">verbose</span> <span class="logical-operator">and</span> <span class="grouping">(</span><span class="identifier">tol</span> <span class="relational-operator">==</span> <span class="int-literal">0</span> <span class="logical-operator">or</span> <span class="identifier">n_iter</span> <span class="arithmetic-operator">%</span> <span class="int-literal">10</span> <span class="relational-operator">!=</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">end_time</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="punctuation">.</span><span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"Epoch %02d reached after %.3f seconds."</span> <span class="arithmetic-operator">%</span>
              <span class="grouping">(</span><span class="identifier">n_iter</span><span class="punctuation">,</span> <span class="identifier">end_time</span> <span class="arithmetic-operator">-</span> <span class="identifier">start_time</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">n_iter</span>


<span class="keyword">def</span> <span class="identifier">non_negative_factorization</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">n_components</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span>
                               <span class="identifier">init</span><span class="arithmetic-assignment">=</span><span class="string-literal">'warn', update_H=True, solver='cd'</span><span class="punctuation">,</span>
                               <span class="identifier">beta_loss</span><span class="arithmetic-assignment">=</span><span class="string-literal">'frobenius'</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span>
                               <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">200</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">.</span><span class="punctuation">,</span> <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">.</span><span class="punctuation">,</span>
                               <span class="identifier">regularization</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                               <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Compute Non-negative Matrix Factorization (NMF).

    Find two non-negative matrices (W, H) whose product approximates the non-
    negative matrix X. This factorization can be used for example for
    dimensionality reduction, source separation or topic extraction.

    The objective function is:

        .. math::

            0.5 * ||X - WH||_{loss}^2 + alpha * l1_{ratio} * ||vec(W)||_1

            + alpha * l1_{ratio} * ||vec(H)||_1

            + 0.5 * alpha * (1 - l1_{ratio}) * ||W||_{Fro}^2

            + 0.5 * alpha * (1 - l1_{ratio}) * ||H||_{Fro}^2

    Where:

    :math:`||A||_{Fro}^2 = \\sum_{i,j} A_{ij}^2` (Frobenius norm)

    :math:`||vec(A)||_1 = \\sum_{i,j} abs(A_{ij})` (Elementwise L1 norm)

    The generic norm :math:`||X - WH||_{loss}^2` may represent
    the Frobenius norm or another supported beta-divergence loss.
    The choice between options is controlled by the `beta_loss` parameter.

    The objective function is minimized with an alternating minimization of W
    and H. If H is given and update_H=False, it solves for W only.

    Parameters
    ----------
    X : array-like of shape (n_samples, n_features)
        Constant matrix.

    W : array-like of shape (n_samples, n_components), default=None
        If init='custom', it is used as initial guess for the solution.

    H : array-like of shape (n_components, n_features), default=None
        If init='custom', it is used as initial guess for the solution.
        If update_H=False, it is used as a constant, to solve for W only.

    n_components : int, default=None
        Number of components, if n_components is not set all features
        are kept.

    init : {'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'custom'}, default=None
        Method used to initialize the procedure.

        Valid options:

        - None: 'nndsvd' if n_components &lt; n_features, otherwise 'random'.

        - 'random': non-negative random matrices, scaled with:
            sqrt(X.mean() / n_components)

        - 'nndsvd': Nonnegative Double Singular Value Decomposition (NNDSVD)
            initialization (better for sparseness)

        - 'nndsvda': NNDSVD with zeros filled with the average of X
            (better when sparsity is not desired)

        - 'nndsvdar': NNDSVD with zeros filled with small random values
            (generally faster, less accurate alternative to NNDSVDa
            for when sparsity is not desired)

        - 'custom': use custom matrices W and H if `update_H=True`. If
          `update_H=False`, then only custom matrix H is used.

        .. versionchanged:: 0.23
            The default value of `init` changed from 'random' to None in 0.23.

    update_H : bool, default=True
        Set to True, both W and H will be estimated from initial guesses.
        Set to False, only W will be estimated.

    solver : {'cd', 'mu'}, default='cd'
        Numerical solver to use:

        - 'cd' is a Coordinate Descent solver that uses Fast Hierarchical
            Alternating Least Squares (Fast HALS).

        - 'mu' is a Multiplicative Update solver.

        .. versionadded:: 0.17
           Coordinate Descent solver.

        .. versionadded:: 0.19
           Multiplicative Update solver.

    beta_loss : float or {'frobenius', 'kullback-leibler', \
            'itakura-saito'}, default='frobenius'
        Beta divergence to be minimized, measuring the distance between X
        and the dot product WH. Note that values different from 'frobenius'
        (or 2) and 'kullback-leibler' (or 1) lead to significantly slower
        fits. Note that for beta_loss &lt;= 0 (or 'itakura-saito'), the input
        matrix X cannot contain zeros. Used only in 'mu' solver.

        .. versionadded:: 0.19

    tol : float, default=1e-4
        Tolerance of the stopping condition.

    max_iter : int, default=200
        Maximum number of iterations before timing out.

    alpha : float, default=0.
        Constant that multiplies the regularization terms.

    l1_ratio : float, default=0.
        The regularization mixing parameter, with 0 &lt;= l1_ratio &lt;= 1.
        For l1_ratio = 0 the penalty is an elementwise L2 penalty
        (aka Frobenius Norm).
        For l1_ratio = 1 it is an elementwise L1 penalty.
        For 0 &lt; l1_ratio &lt; 1, the penalty is a combination of L1 and L2.

    regularization : {'both', 'components', 'transformation'}, default=None
        Select whether the regularization affects the components (H), the
        transformation (W), both or none of them.

    random_state : int, RandomState instance or None, default=None
        Used for NMF initialisation (when ``init`` == 'nndsvdar' or
        'random'), and in Coordinate Descent. Pass an int for reproducible
        results across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    verbose : int, default=0
        The verbosity level.

    shuffle : bool, default=False
        If true, randomize the order of coordinates in the CD solver.

    Returns
    -------
    W : ndarray of shape (n_samples, n_components)
        Solution to the non-negative least squares problem.

    H : ndarray of shape (n_components, n_features)
        Solution to the non-negative least squares problem.

    n_iter : int
        Actual number of iterations.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; X = np.array([[1,1], [2, 1], [3, 1.2], [4, 1], [5, 0.8], [6, 1]])
    &gt;&gt;&gt; from sklearn.decomposition import non_negative_factorization
    &gt;&gt;&gt; W, H, n_iter = non_negative_factorization(X, n_components=2,
    ... init='random', random_state=0)

    References
    ----------
    Cichocki, Andrzej, and P. H. A. N. Anh-Huy. "Fast local algorithms for
    large scale nonnegative matrix and tensor factorizations."
    IEICE transactions on fundamentals of electronics, communications and
    computer sciences 92.3: 708-721, 2009.

    Fevotte, C., & Idier, J. (2011). Algorithms for nonnegative matrix
    factorization with the beta-divergence. Neural Computation, 23(9).
    """</span>
    <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="string-literal">'csr', 'csc'</span><span class="grouping">)</span><span class="punctuation">,</span>
                    <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="grouping">)</span>

    <span class="identifier">est</span> <span class="arithmetic-assignment">=</span> <span class="identifier">NMF</span><span class="grouping">(</span><span class="identifier">n_components</span><span class="arithmetic-assignment">=</span><span class="identifier">n_components</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="arithmetic-assignment">=</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="identifier">solver</span><span class="arithmetic-assignment">=</span><span class="identifier">solver</span><span class="punctuation">,</span>
              <span class="identifier">beta_loss</span><span class="arithmetic-assignment">=</span><span class="identifier">beta_loss</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
              <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="identifier">l1_ratio</span><span class="punctuation">,</span>
              <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="identifier">shuffle</span><span class="punctuation">,</span> <span class="identifier">regularization</span><span class="arithmetic-assignment">=</span><span class="identifier">regularization</span><span class="grouping">)</span>

    <span class="keyword">with</span> <span class="identifier">config_context</span><span class="grouping">(</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">n_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">est</span><span class="punctuation">.</span><span class="identifier">_fit_transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="arithmetic-assignment">=</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="arithmetic-assignment">=</span><span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">update_H</span><span class="arithmetic-assignment">=</span><span class="identifier">update_H</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">n_iter</span>


<span class="keyword">class</span> <span class="identifier">NMF</span><span class="grouping">(</span><span class="identifier">TransformerMixin</span><span class="punctuation">,</span> <span class="identifier">BaseEstimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Non-Negative Matrix Factorization (NMF).

    Find two non-negative matrices (W, H) whose product approximates the non-
    negative matrix X. This factorization can be used for example for
    dimensionality reduction, source separation or topic extraction.

    The objective function is:

        .. math::

            0.5 * ||X - WH||_{loss}^2 + alpha * l1_{ratio} * ||vec(W)||_1

            + alpha * l1_{ratio} * ||vec(H)||_1

            + 0.5 * alpha * (1 - l1_{ratio}) * ||W||_{Fro}^2

            + 0.5 * alpha * (1 - l1_{ratio}) * ||H||_{Fro}^2

    Where:

    :math:`||A||_{Fro}^2 = \\sum_{i,j} A_{ij}^2` (Frobenius norm)

    :math:`||vec(A)||_1 = \\sum_{i,j} abs(A_{ij})` (Elementwise L1 norm)

    The generic norm :math:`||X - WH||_{loss}` may represent
    the Frobenius norm or another supported beta-divergence loss.
    The choice between options is controlled by the `beta_loss` parameter.

    The objective function is minimized with an alternating minimization of W
    and H.

    Read more in the :ref:`User Guide &lt;NMF&gt;`.

    Parameters
    ----------
    n_components : int, default=None
        Number of components, if n_components is not set all features
        are kept.

    init : {'random', 'nndsvd', 'nndsvda', 'nndsvdar', 'custom'}, default=None
        Method used to initialize the procedure.
        Default: None.
        Valid options:

        - `None`: 'nndsvd' if n_components &lt;= min(n_samples, n_features),
          otherwise random.

        - `'random'`: non-negative random matrices, scaled with:
          sqrt(X.mean() / n_components)

        - `'nndsvd'`: Nonnegative Double Singular Value Decomposition (NNDSVD)
          initialization (better for sparseness)

        - `'nndsvda'`: NNDSVD with zeros filled with the average of X
          (better when sparsity is not desired)

        - `'nndsvdar'` NNDSVD with zeros filled with small random values
          (generally faster, less accurate alternative to NNDSVDa
          for when sparsity is not desired)

        - `'custom'`: use custom matrices W and H

    solver : {'cd', 'mu'}, default='cd'
        Numerical solver to use:
        'cd' is a Coordinate Descent solver.
        'mu' is a Multiplicative Update solver.

        .. versionadded:: 0.17
           Coordinate Descent solver.

        .. versionadded:: 0.19
           Multiplicative Update solver.

    beta_loss : float or {'frobenius', 'kullback-leibler', \
            'itakura-saito'}, default='frobenius'
        Beta divergence to be minimized, measuring the distance between X
        and the dot product WH. Note that values different from 'frobenius'
        (or 2) and 'kullback-leibler' (or 1) lead to significantly slower
        fits. Note that for beta_loss &lt;= 0 (or 'itakura-saito'), the input
        matrix X cannot contain zeros. Used only in 'mu' solver.

        .. versionadded:: 0.19

    tol : float, default=1e-4
        Tolerance of the stopping condition.

    max_iter : int, default=200
        Maximum number of iterations before timing out.

    random_state : int, RandomState instance or None, default=None
        Used for initialisation (when ``init`` == 'nndsvdar' or
        'random'), and in Coordinate Descent. Pass an int for reproducible
        results across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    alpha : float, default=0.
        Constant that multiplies the regularization terms. Set it to zero to
        have no regularization.

        .. versionadded:: 0.17
           *alpha* used in the Coordinate Descent solver.

    l1_ratio : float, default=0.
        The regularization mixing parameter, with 0 &lt;= l1_ratio &lt;= 1.
        For l1_ratio = 0 the penalty is an elementwise L2 penalty
        (aka Frobenius Norm).
        For l1_ratio = 1 it is an elementwise L1 penalty.
        For 0 &lt; l1_ratio &lt; 1, the penalty is a combination of L1 and L2.

        .. versionadded:: 0.17
           Regularization parameter *l1_ratio* used in the Coordinate Descent
           solver.

    verbose : int, default=0
        Whether to be verbose.

    shuffle : bool, default=False
        If true, randomize the order of coordinates in the CD solver.

        .. versionadded:: 0.17
           *shuffle* parameter used in the Coordinate Descent solver.

    regularization : {'both', 'components', 'transformation', None}, \
                     default='both'
        Select whether the regularization affects the components (H), the
        transformation (W), both or none of them.

        .. versionadded:: 0.24

    Attributes
    ----------
    components_ : ndarray of shape (n_components, n_features)
        Factorization matrix, sometimes called 'dictionary'.

    n_components_ : int
        The number of components. It is same as the `n_components` parameter
        if it was given. Otherwise, it will be same as the number of
        features.

    reconstruction_err_ : float
        Frobenius norm of the matrix difference, or beta-divergence, between
        the training data ``X`` and the reconstructed data ``WH`` from
        the fitted model.

    n_iter_ : int
        Actual number of iterations.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; X = np.array([[1, 1], [2, 1], [3, 1.2], [4, 1], [5, 0.8], [6, 1]])
    &gt;&gt;&gt; from sklearn.decomposition import NMF
    &gt;&gt;&gt; model = NMF(n_components=2, init='random', random_state=0)
    &gt;&gt;&gt; W = model.fit_transform(X)
    &gt;&gt;&gt; H = model.components_

    References
    ----------
    Cichocki, Andrzej, and P. H. A. N. Anh-Huy. "Fast local algorithms for
    large scale nonnegative matrix and tensor factorizations."
    IEICE transactions on fundamentals of electronics, communications and
    computer sciences 92.3: 708-721, 2009.

    Fevotte, C., & Idier, J. (2011). Algorithms for nonnegative matrix
    factorization with the beta-divergence. Neural Computation, 23(9).
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">n_components</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="arithmetic-assignment">=</span><span class="string-literal">'warn', solver='cd'</span><span class="punctuation">,</span>
                 <span class="identifier">beta_loss</span><span class="arithmetic-assignment">=</span><span class="string-literal">'frobenius'</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">200</span><span class="punctuation">,</span>
                 <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">.</span><span class="punctuation">,</span> <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">.</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span>
                 <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">regularization</span><span class="arithmetic-assignment">=</span><span class="string-literal">'both'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_components</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init</span> <span class="arithmetic-assignment">=</span> <span class="identifier">init</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">solver</span> <span class="arithmetic-assignment">=</span> <span class="identifier">solver</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">beta_loss</span> <span class="arithmetic-assignment">=</span> <span class="identifier">beta_loss</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span> <span class="arithmetic-assignment">=</span> <span class="identifier">tol</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l1_ratio</span> <span class="arithmetic-assignment">=</span> <span class="identifier">l1_ratio</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">verbose</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">shuffle</span> <span class="arithmetic-assignment">=</span> <span class="identifier">shuffle</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">regularization</span> <span class="arithmetic-assignment">=</span> <span class="identifier">regularization</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'requires_positive_X'</span><span class="punctuation">:</span> <span class="bool-literal">True</span><span class="grouping">}</span>

    <span class="keyword">def</span> <span class="identifier">_check_params</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_components</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_components</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_components</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_components</span><span class="punctuation">,</span> <span class="identifier">numbers</span><span class="punctuation">.</span><span class="identifier">Integral</span>
        <span class="grouping">)</span> <span class="logical-operator">or</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_components</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Number of components must be a positive integer;"</span>
                             <span class="string-literal">" got (n_components=%r)"</span> <span class="arithmetic-operator">%</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_components</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">numbers</span><span class="punctuation">.</span><span class="identifier">Integral</span>
        <span class="grouping">)</span> <span class="logical-operator">or</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Maximum number of iterations must be a positive "</span>
                             <span class="string-literal">"integer; got (max_iter=%r)"</span> <span class="arithmetic-operator">%</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">numbers</span><span class="punctuation">.</span><span class="identifier">Number</span><span class="grouping">)</span> <span class="logical-operator">or</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Tolerance for stopping criteria must be "</span>
                             <span class="string-literal">"positive; got (tol=%r)"</span> <span class="arithmetic-operator">%</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">_check_w_h</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">update_H</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># check W and H, or initialize them</span>
        <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init</span> <span class="relational-operator">==</span> <span class="string-literal">'custom'</span> <span class="logical-operator">and</span> <span class="identifier">update_H</span><span class="punctuation">:</span>
            <span class="identifier">_check_init</span><span class="grouping">(</span><span class="identifier">H</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_components</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="string-literal">"NMF (input H)"</span><span class="grouping">)</span>
            <span class="identifier">_check_init</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_components</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="string-literal">"NMF (input W)"</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">H</span><span class="punctuation">.</span><span class="identifier">dtype</span> <span class="relational-operator">!=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span> <span class="logical-operator">or</span> <span class="identifier">W</span><span class="punctuation">.</span><span class="identifier">dtype</span> <span class="relational-operator">!=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">"H and W should have the same dtype as X. Got "</span>
                                <span class="string-literal">"H.dtype = {} and W.dtype = {}."</span>
                                <span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">H</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="logical-operator">not</span> <span class="identifier">update_H</span><span class="punctuation">:</span>
            <span class="identifier">_check_init</span><span class="grouping">(</span><span class="identifier">H</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_components</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="string-literal">"NMF (input H)"</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">H</span><span class="punctuation">.</span><span class="identifier">dtype</span> <span class="relational-operator">!=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">"H should have the same dtype as X. Got "</span>
                                <span class="string-literal">"H.dtype = {}."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">H</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="comment"># 'mu' solver should not be initialized by zeros</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">solver</span> <span class="relational-operator">==</span> <span class="string-literal">'mu'</span><span class="punctuation">:</span>
                <span class="identifier">avg</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_components</span><span class="grouping">)</span>
                <span class="identifier">W</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">full</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_components</span><span class="grouping">)</span><span class="punctuation">,</span>
                            <span class="identifier">avg</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">W</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_components</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_initialize_nmf</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_components</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init</span><span class="punctuation">,</span>
                                   <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span>

    <span class="keyword">def</span> <span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Learn a NMF model for the data X and returns the transformed data.

        This is more efficient than calling fit followed by transform.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            Data matrix to be decomposed

        y : Ignored

        W : array-like of shape (n_samples, n_components)
            If init='custom', it is used as initial guess for the solution.

        H : array-like of shape (n_components, n_features)
            If init='custom', it is used as initial guess for the solution.

        Returns
        -------
        W : ndarray of shape (n_samples, n_components)
            Transformed data.
        """</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="string-literal">'csr', 'csc'</span><span class="grouping">)</span><span class="punctuation">,</span>
                                <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="keyword">with</span> <span class="identifier">config_context</span><span class="grouping">(</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">n_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_fit_transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="arithmetic-assignment">=</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="arithmetic-assignment">=</span><span class="identifier">H</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">reconstruction_err_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_beta_divergence</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_beta_loss</span><span class="punctuation">,</span>
                                                    <span class="identifier">square_root</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">H</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">components_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">H</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_iter</span>

        <span class="keyword">return</span> <span class="identifier">W</span>

    <span class="keyword">def</span> <span class="identifier">_fit_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">update_H</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Learn a NMF model for the data X and returns the transformed data.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            Data matrix to be decomposed

        y : Ignored

        W : array-like of shape (n_samples, n_components)
            If init='custom', it is used as initial guess for the solution.

        H : array-like of shape (n_components, n_features)
            If init='custom', it is used as initial guess for the solution.
            If update_H=False, it is used as a constant, to solve for W only.

        update_H : bool, default=True
            If True, both W and H will be estimated from initial guesses,
            this corresponds to a call to the 'fit_transform' method.
            If False, only W will be estimated, this corresponds to a call
            to the 'transform' method.

        Returns
        -------
        W : ndarray of shape (n_samples, n_components)
            Transformed data.

        H : ndarray of shape (n_components, n_features)
            Factorization matrix, sometimes called 'dictionary'.

        n_iter_ : int
            Actual number of iterations.
        """</span>
        <span class="identifier">check_non_negative</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="string-literal">"NMF (input X)"</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_beta_loss</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_string_param</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">solver</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">regularization</span><span class="punctuation">,</span>
                                              <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">beta_loss</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">min</span><span class="grouping">(</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">0</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_beta_loss</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"When beta_loss &lt;= 0 and X contains zeros, "</span>
                             <span class="string-literal">"the solver may diverge. Please add small values "</span>
                             <span class="string-literal">"to X, or use a positive beta_loss."</span><span class="grouping">)</span>

        <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>

        <span class="comment"># check parameters</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_params</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

        <span class="comment"># initialize or check W and H</span>
        <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_w_h</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">update_H</span><span class="grouping">)</span>

        <span class="identifier">l1_reg_W</span><span class="punctuation">,</span> <span class="identifier">l1_reg_H</span><span class="punctuation">,</span> <span class="identifier">l2_reg_W</span><span class="punctuation">,</span> <span class="identifier">l2_reg_H</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_compute_regularization</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l1_ratio</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">regularization</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">solver</span> <span class="relational-operator">==</span> <span class="string-literal">'cd'</span><span class="punctuation">:</span>
            <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">n_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_fit_coordinate_descent</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">l1_reg_W</span><span class="punctuation">,</span> <span class="identifier">l1_reg_H</span><span class="punctuation">,</span>
                <span class="identifier">l2_reg_W</span><span class="punctuation">,</span> <span class="identifier">l2_reg_H</span><span class="punctuation">,</span> <span class="identifier">update_H</span><span class="arithmetic-assignment">=</span><span class="identifier">update_H</span><span class="punctuation">,</span>
                <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">shuffle</span><span class="punctuation">,</span>
                <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">solver</span> <span class="relational-operator">==</span> <span class="string-literal">'mu'</span><span class="punctuation">:</span>
            <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">n_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_fit_multiplicative_update</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_beta_loss</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span><span class="punctuation">,</span>
                <span class="identifier">l1_reg_W</span><span class="punctuation">,</span> <span class="identifier">l1_reg_H</span><span class="punctuation">,</span> <span class="identifier">l2_reg_W</span><span class="punctuation">,</span> <span class="identifier">l2_reg_H</span><span class="punctuation">,</span>
                <span class="identifier">update_H</span><span class="arithmetic-assignment">=</span><span class="identifier">update_H</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Invalid solver parameter '%s'."</span> <span class="arithmetic-operator">%</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">solver</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">n_iter</span> <span class="relational-operator">==</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">"Maximum number of iterations %d reached. Increase "</span>
                          <span class="string-literal">"it to improve convergence."</span> <span class="arithmetic-operator">%</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
                          <span class="identifier">ConvergenceWarning</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="punctuation">,</span> <span class="identifier">n_iter</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">params</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Learn a NMF model for the data X.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            Data matrix to be decomposed

        y : Ignored

        Returns
        -------
        self
        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">params</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Transform the data X according to the fitted NMF model.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            Data matrix to be transformed by the model.

        Returns
        -------
        W : ndarray of shape (n_samples, n_components)
            Transformed data.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="string-literal">'csr', 'csc'</span><span class="grouping">)</span><span class="punctuation">,</span>
                                <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="punctuation">,</span>
                                <span class="identifier">reset</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

        <span class="keyword">with</span> <span class="identifier">config_context</span><span class="grouping">(</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">W</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_fit_transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">H</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">components_</span><span class="punctuation">,</span> <span class="identifier">update_H</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">W</span>

    <span class="keyword">def</span> <span class="identifier">inverse_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">W</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Transform data back to its original space.

        Parameters
        ----------
        W : {ndarray, sparse matrix} of shape (n_samples, n_components)
            Transformed data matrix.

        Returns
        -------
        X : {ndarray, sparse matrix} of shape (n_samples, n_features)
            Data matrix of original shape.

        .. versionadded:: 0.18
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">W</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">components_</span><span class="grouping">)</span>

    </pre>
  </body>
</html>