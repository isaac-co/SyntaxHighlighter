<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""
The :mod:`sklearn.model_selection._split` module includes classes and
functions to split the data based on a preset strategy.
"""</span>

<span class="comment"># Author: Alexandre Gramfort &lt;alexandre.gramfort@inria.fr&gt;</span>
<span class="comment">#         Gael Varoquaux &lt;gael.varoquaux@normalesup.org&gt;</span>
<span class="comment">#         Olivier Grisel &lt;olivier.grisel@ensta.org&gt;</span>
<span class="comment">#         Raghav RV &lt;rvraghav93@gmail.com&gt;</span>
<span class="comment">#         Leandro Hermida &lt;hermidal@cs.umd.edu&gt;</span>
<span class="comment">#         Rodion Martynov &lt;marrodion@gmail.com&gt;</span>
<span class="comment"># License: BSD 3 clause</span>

<span class="keyword">from</span> <span class="identifier">collections</span><span class="punctuation">.</span><span class="identifier">abc</span> <span class="keyword">import</span> <span class="identifier">Iterable</span>
<span class="keyword">from</span> <span class="identifier">collections</span> <span class="keyword">import</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">d</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">t</span>
<span class="keyword">import</span> <span class="identifier">warnings</span>
<span class="keyword">from</span> <span class="identifier">itertools</span> <span class="keyword">import</span> <span class="identifier">chain</span><span class="punctuation">,</span> <span class="identifier">combinations</span>
<span class="keyword">from</span> <span class="identifier">math</span> <span class="keyword">import</span> <span class="identifier">ceil</span><span class="punctuation">,</span> <span class="identifier">floor</span>
<span class="keyword">import</span> <span class="identifier">numbers</span>
<span class="keyword">from</span> <span class="identifier">abc</span> <span class="keyword">import</span> <span class="identifier">ABCMeta</span><span class="punctuation">,</span> <span class="identifier">abstractmethod</span>
<span class="keyword">from</span> <span class="identifier">inspect</span> <span class="keyword">import</span> <span class="identifier">signature</span>

<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">from</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">special</span> <span class="keyword">import</span> <span class="identifier">comb</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">indexable</span><span class="punctuation">,</span> <span class="identifier">check_random_state</span><span class="punctuation">,</span> <span class="identifier">_safe_indexing</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">_approximate_mode</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">_num_samples</span><span class="punctuation">,</span> <span class="identifier">column_or_1d</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_array</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">multiclass</span> <span class="keyword">import</span> <span class="identifier">type_of_target</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">_pprint</span>

<span class="identifier">__all__</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="string-literal">'BaseCrossValidator'</span><span class="punctuation">,</span>
           <span class="string-literal">'KFold'</span><span class="punctuation">,</span>
           <span class="string-literal">'GroupKFold'</span><span class="punctuation">,</span>
           <span class="string-literal">'LeaveOneGroupOut'</span><span class="punctuation">,</span>
           <span class="string-literal">'LeaveOneOut'</span><span class="punctuation">,</span>
           <span class="string-literal">'LeavePGroupsOut'</span><span class="punctuation">,</span>
           <span class="string-literal">'LeavePOut'</span><span class="punctuation">,</span>
           <span class="string-literal">'RepeatedStratifiedKFold'</span><span class="punctuation">,</span>
           <span class="string-literal">'RepeatedKFold'</span><span class="punctuation">,</span>
           <span class="string-literal">'ShuffleSplit'</span><span class="punctuation">,</span>
           <span class="string-literal">'GroupShuffleSplit'</span><span class="punctuation">,</span>
           <span class="string-literal">'StratifiedKFold'</span><span class="punctuation">,</span>
           <span class="string-literal">'StratifiedGroupKFold'</span><span class="punctuation">,</span>
           <span class="string-literal">'StratifiedShuffleSplit'</span><span class="punctuation">,</span>
           <span class="string-literal">'PredefinedSplit'</span><span class="punctuation">,</span>
           <span class="string-literal">'train_test_split'</span><span class="punctuation">,</span>
           <span class="string-literal">'check_cv'</span><span class="grouping">]</span>


<span class="keyword">class</span> <span class="identifier">BaseCrossValidator</span><span class="grouping">(</span><span class="identifier">metaclass</span><span class="arithmetic-assignment">=</span><span class="identifier">ABCMeta</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Base class for all cross-validators

    Implementations must define `_iter_test_masks` or `_iter_test_indices`.
    """</span>
    <span class="keyword">def</span> <span class="identifier">split</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generate indices to split data into training and test set.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples
            and n_features is the number of features.

        y : array-like of shape (n_samples,)
            The target variable for supervised learning problems.

        groups : array-like of shape (n_samples,), default=None
            Group labels for the samples used while splitting the dataset into
            train/test set.

        Yields
        ------
        train : ndarray
            The training set indices for that split.

        test : ndarray
            The testing set indices for that split.
        """</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">indexable</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span>
        <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">test_index</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter_test_masks</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">train_index</span> <span class="arithmetic-assignment">=</span> <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">logical_not</span><span class="grouping">(</span><span class="identifier">test_index</span><span class="grouping">)</span><span class="grouping">]</span>
            <span class="identifier">test_index</span> <span class="arithmetic-assignment">=</span> <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">test_index</span><span class="grouping">]</span>
            <span class="keyword">yield</span> <span class="identifier">train_index</span><span class="punctuation">,</span> <span class="identifier">test_index</span>

    <span class="comment"># Since subclasses must implement either _iter_test_masks or</span>
    <span class="comment"># _iter_test_indices, neither can be abstract.</span>
    <span class="keyword">def</span> <span class="identifier">_iter_test_masks</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generates boolean masks corresponding to test sets.

        By default, delegates to _iter_test_indices(X, y, groups)
        """</span>
        <span class="keyword">for</span> <span class="identifier">test_index</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter_test_indices</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">test_mask</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">bool</span><span class="grouping">)</span>
            <span class="identifier">test_mask</span><span class="grouping">[</span><span class="identifier">test_index</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>
            <span class="keyword">yield</span> <span class="identifier">test_mask</span>

    <span class="keyword">def</span> <span class="identifier">_iter_test_indices</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generates integer indices corresponding to test sets."""</span>
        <span class="keyword">raise</span> <span class="identifier">NotImplementedError</span>

    <span class="punctuation">@</span><span class="identifier">abstractmethod</span>
    <span class="keyword">def</span> <span class="identifier">get_n_splits</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Returns the number of splitting iterations in the cross-validator"""</span>

    <span class="keyword">def</span> <span class="identifier">__repr__</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">_build_repr</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">LeaveOneOut</span><span class="grouping">(</span><span class="identifier">BaseCrossValidator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Leave-One-Out cross-validator

    Provides train/test indices to split data in train/test sets. Each
    sample is used once as a test set (singleton) while the remaining
    samples form the training set.

    Note: ``LeaveOneOut()`` is equivalent to ``KFold(n_splits=n)`` and
    ``LeavePOut(p=1)`` where ``n`` is the number of samples.

    Due to the high number of test sets (which is the same as the
    number of samples) this cross-validation method can be very costly.
    For large datasets one should favor :class:`KFold`, :class:`ShuffleSplit`
    or :class:`StratifiedKFold`.

    Read more in the :ref:`User Guide &lt;leave_one_out&gt;`.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import LeaveOneOut
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4]])
    &gt;&gt;&gt; y = np.array([1, 2])
    &gt;&gt;&gt; loo = LeaveOneOut()
    &gt;&gt;&gt; loo.get_n_splits(X)
    2
    &gt;&gt;&gt; print(loo)
    LeaveOneOut()
    &gt;&gt;&gt; for train_index, test_index in loo.split(X):
    ...     print("TRAIN:", train_index, "TEST:", test_index)
    ...     X_train, X_test = X[train_index], X[test_index]
    ...     y_train, y_test = y[train_index], y[test_index]
    ...     print(X_train, X_test, y_train, y_test)
    TRAIN: [1] TEST: [0]
    [[3 4]] [[1 2]] [2] [1]
    TRAIN: [0] TEST: [1]
    [[1 2]] [[3 4]] [1] [2]

    See Also
    --------
    LeaveOneGroupOut : For splitting the data according to explicit,
        domain-specific stratification of the dataset.
    GroupKFold : K-fold iterator variant with non-overlapping groups.
    """</span>

    <span class="keyword">def</span> <span class="identifier">_iter_test_indices</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">n_samples</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">'Cannot perform LeaveOneOut with n_samples={}.'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span>
                    <span class="identifier">n_samples</span><span class="grouping">)</span>
            <span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">get_n_splits</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Returns the number of splitting iterations in the cross-validator

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples
            and n_features is the number of features.

        y : object
            Always ignored, exists for compatibility.

        groups : object
            Always ignored, exists for compatibility.

        Returns
        -------
        n_splits : int
            Returns the number of splitting iterations in the cross-validator.
        """</span>
        <span class="keyword">if</span> <span class="identifier">X</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"The 'X' parameter should not be None."</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">LeavePOut</span><span class="grouping">(</span><span class="identifier">BaseCrossValidator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Leave-P-Out cross-validator

    Provides train/test indices to split data in train/test sets. This results
    in testing on all distinct samples of size p, while the remaining n - p
    samples form the training set in each iteration.

    Note: ``LeavePOut(p)`` is NOT equivalent to
    ``KFold(n_splits=n_samples // p)`` which creates non-overlapping test sets.

    Due to the high number of iterations which grows combinatorically with the
    number of samples this cross-validation method can be very costly. For
    large datasets one should favor :class:`KFold`, :class:`StratifiedKFold`
    or :class:`ShuffleSplit`.

    Read more in the :ref:`User Guide &lt;leave_p_out&gt;`.

    Parameters
    ----------
    p : int
        Size of the test sets. Must be strictly less than the number of
        samples.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import LeavePOut
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])
    &gt;&gt;&gt; y = np.array([1, 2, 3, 4])
    &gt;&gt;&gt; lpo = LeavePOut(2)
    &gt;&gt;&gt; lpo.get_n_splits(X)
    6
    &gt;&gt;&gt; print(lpo)
    LeavePOut(p=2)
    &gt;&gt;&gt; for train_index, test_index in lpo.split(X):
    ...     print("TRAIN:", train_index, "TEST:", test_index)
    ...     X_train, X_test = X[train_index], X[test_index]
    ...     y_train, y_test = y[train_index], y[test_index]
    TRAIN: [2 3] TEST: [0 1]
    TRAIN: [1 3] TEST: [0 2]
    TRAIN: [1 2] TEST: [0 3]
    TRAIN: [0 3] TEST: [1 2]
    TRAIN: [0 2] TEST: [1 3]
    TRAIN: [0 1] TEST: [2 3]
    """</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">p</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">p</span> <span class="arithmetic-assignment">=</span> <span class="identifier">p</span>

    <span class="keyword">def</span> <span class="identifier">_iter_test_indices</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">n_samples</span> <span class="relational-operator">&lt;=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">p</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">'p={} must be strictly less than the number of '</span>
                <span class="string-literal">'samples={}'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">p</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="grouping">)</span>
            <span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">combination</span> <span class="relational-operator">in</span> <span class="identifier">combinations</span><span class="grouping">(</span><span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">p</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">yield</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="identifier">combination</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">get_n_splits</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Returns the number of splitting iterations in the cross-validator

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples
            and n_features is the number of features.

        y : object
            Always ignored, exists for compatibility.

        groups : object
            Always ignored, exists for compatibility.
        """</span>
        <span class="keyword">if</span> <span class="identifier">X</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"The 'X' parameter should not be None."</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">int</span><span class="grouping">(</span><span class="identifier">comb</span><span class="grouping">(</span><span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">p</span><span class="punctuation">,</span> <span class="identifier">exact</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">_BaseKFold</span><span class="grouping">(</span><span class="identifier">BaseCrossValidator</span><span class="punctuation">,</span> <span class="identifier">metaclass</span><span class="arithmetic-assignment">=</span><span class="identifier">ABCMeta</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Base class for KFold, GroupKFold, and StratifiedKFold"""</span>

    <span class="punctuation">@</span><span class="identifier">abstractmethod</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="identifier">numbers</span><span class="punctuation">.</span><span class="identifier">Integral</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'The number of folds must be of Integral type. '</span>
                             <span class="string-literal">'%s of type %s was passed.'</span>
                             <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="identifier">type</span><span class="grouping">(</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">n_splits</span> <span class="arithmetic-assignment">=</span> <span class="identifier">int</span><span class="grouping">(</span><span class="identifier">n_splits</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">n_splits</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">"k-fold cross-validation requires at least one"</span>
                <span class="string-literal">" train/test split by setting n_splits=2 or more,"</span>
                <span class="string-literal">" got n_splits={0}."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">shuffle</span><span class="punctuation">,</span> <span class="identifier">bool</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">"shuffle must be True or False;"</span>
                            <span class="string-literal">" got {0}"</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">shuffle</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">shuffle</span> <span class="logical-operator">and</span> <span class="identifier">random_state</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>  <span class="comment"># None is the default</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">'Setting a random_state has no effect since shuffle is '</span>
                <span class="string-literal">'False. You should leave '</span>
                <span class="string-literal">'random_state to its default (None), or set shuffle=True.'</span><span class="punctuation">,</span>
            <span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_splits</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">shuffle</span> <span class="arithmetic-assignment">=</span> <span class="identifier">shuffle</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>

    <span class="keyword">def</span> <span class="identifier">split</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generate indices to split data into training and test set.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples
            and n_features is the number of features.

        y : array-like of shape (n_samples,), default=None
            The target variable for supervised learning problems.

        groups : array-like of shape (n_samples,), default=None
            Group labels for the samples used while splitting the dataset into
            train/test set.

        Yields
        ------
        train : ndarray
            The training set indices for that split.

        test : ndarray
            The testing set indices for that split.
        """</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">indexable</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span> <span class="relational-operator">&gt;</span> <span class="identifier">n_samples</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="grouping">(</span><span class="string-literal">"Cannot have number of splits n_splits={0} greater"</span>
                 <span class="string-literal">" than the number of samples: n_samples={1}."</span><span class="grouping">)</span>
                <span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">for</span> <span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span> <span class="relational-operator">in</span> <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">yield</span> <span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span>

    <span class="keyword">def</span> <span class="identifier">get_n_splits</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Returns the number of splitting iterations in the cross-validator

        Parameters
        ----------
        X : object
            Always ignored, exists for compatibility.

        y : object
            Always ignored, exists for compatibility.

        groups : object
            Always ignored, exists for compatibility.

        Returns
        -------
        n_splits : int
            Returns the number of splitting iterations in the cross-validator.
        """</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span>


<span class="keyword">class</span> <span class="identifier">KFold</span><span class="grouping">(</span><span class="identifier">_BaseKFold</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""K-Folds cross-validator

    Provides train/test indices to split data in train/test sets. Split
    dataset into k consecutive folds (without shuffling by default).

    Each fold is then used once as a validation while the k - 1 remaining
    folds form the training set.

    Read more in the :ref:`User Guide &lt;k_fold&gt;`.

    Parameters
    ----------
    n_splits : int, default=5
        Number of folds. Must be at least 2.

        .. versionchanged:: 0.22
            ``n_splits`` default value changed from 3 to 5.

    shuffle : bool, default=False
        Whether to shuffle the data before splitting into batches.
        Note that the samples within each split will not be shuffled.

    random_state : int, RandomState instance or None, default=None
        When `shuffle` is True, `random_state` affects the ordering of the
        indices, which controls the randomness of each fold. Otherwise, this
        parameter has no effect.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import KFold
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])
    &gt;&gt;&gt; y = np.array([1, 2, 3, 4])
    &gt;&gt;&gt; kf = KFold(n_splits=2)
    &gt;&gt;&gt; kf.get_n_splits(X)
    2
    &gt;&gt;&gt; print(kf)
    KFold(n_splits=2, random_state=None, shuffle=False)
    &gt;&gt;&gt; for train_index, test_index in kf.split(X):
    ...     print("TRAIN:", train_index, "TEST:", test_index)
    ...     X_train, X_test = X[train_index], X[test_index]
    ...     y_train, y_test = y[train_index], y[test_index]
    TRAIN: [2 3] TEST: [0 1]
    TRAIN: [0 1] TEST: [2 3]

    Notes
    -----
    The first ``n_samples % n_splits`` folds have size
    ``n_samples // n_splits + 1``, other folds have size
    ``n_samples // n_splits``, where ``n_samples`` is the number of samples.

    Randomized CV splitters may return different results for each call of
    split. You can make the results identical by setting `random_state`
    to an integer.

    See Also
    --------
    StratifiedKFold : Takes group information into account to avoid building
        folds with imbalanced class distributions (for binary or multiclass
        classification tasks).

    GroupKFold : K-fold iterator variant with non-overlapping groups.

    RepeatedKFold : Repeats K-Fold n times.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="int-literal">5</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                 <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="identifier">shuffle</span><span class="punctuation">,</span>
                         <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_iter_test_indices</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">shuffle</span><span class="punctuation">:</span>
            <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">shuffle</span><span class="grouping">(</span><span class="identifier">indices</span><span class="grouping">)</span>

        <span class="identifier">n_splits</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span>
        <span class="identifier">fold_sizes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">full</span><span class="grouping">(</span><span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="identifier">n_samples</span> <span class="arithmetic-operator">//</span> <span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">int</span><span class="grouping">)</span>
        <span class="identifier">fold_sizes</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_samples</span> <span class="arithmetic-operator">%</span> <span class="identifier">n_splits</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">1</span>
        <span class="identifier">current</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
        <span class="keyword">for</span> <span class="identifier">fold_size</span> <span class="relational-operator">in</span> <span class="identifier">fold_sizes</span><span class="punctuation">:</span>
            <span class="identifier">start</span><span class="punctuation">,</span> <span class="identifier">stop</span> <span class="arithmetic-assignment">=</span> <span class="identifier">current</span><span class="punctuation">,</span> <span class="identifier">current</span> <span class="arithmetic-operator">+</span> <span class="identifier">fold_size</span>
            <span class="keyword">yield</span> <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">start</span><span class="punctuation">:</span><span class="identifier">stop</span><span class="grouping">]</span>
            <span class="identifier">current</span> <span class="arithmetic-assignment">=</span> <span class="identifier">stop</span>


<span class="keyword">class</span> <span class="identifier">GroupKFold</span><span class="grouping">(</span><span class="identifier">_BaseKFold</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""K-fold iterator variant with non-overlapping groups.

    The same group will not appear in two different folds (the number of
    distinct groups has to be at least equal to the number of folds).

    The folds are approximately balanced in the sense that the number of
    distinct groups is approximately the same in each fold.

    Read more in the :ref:`User Guide &lt;group_k_fold&gt;`.

    Parameters
    ----------
    n_splits : int, default=5
        Number of folds. Must be at least 2.

        .. versionchanged:: 0.22
            ``n_splits`` default value changed from 3 to 5.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import GroupKFold
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])
    &gt;&gt;&gt; y = np.array([1, 2, 3, 4])
    &gt;&gt;&gt; groups = np.array([0, 0, 2, 2])
    &gt;&gt;&gt; group_kfold = GroupKFold(n_splits=2)
    &gt;&gt;&gt; group_kfold.get_n_splits(X, y, groups)
    2
    &gt;&gt;&gt; print(group_kfold)
    GroupKFold(n_splits=2)
    &gt;&gt;&gt; for train_index, test_index in group_kfold.split(X, y, groups):
    ...     print("TRAIN:", train_index, "TEST:", test_index)
    ...     X_train, X_test = X[train_index], X[test_index]
    ...     y_train, y_test = y[train_index], y[test_index]
    ...     print(X_train, X_test, y_train, y_test)
    ...
    TRAIN: [0 1] TEST: [2 3]
    [[1 2]
     [3 4]] [[5 6]
     [7 8]] [1 2] [3 4]
    TRAIN: [2 3] TEST: [0 1]
    [[5 6]
     [7 8]] [[1 2]
     [3 4]] [3 4] [1 2]

    See Also
    --------
    LeaveOneGroupOut : For splitting the data according to explicit
        domain-specific stratification of the dataset.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="int-literal">5</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_iter_test_indices</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">groups</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"The 'groups' parameter should not be None."</span><span class="grouping">)</span>
        <span class="identifier">groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">groups</span><span class="punctuation">,</span> <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span>

        <span class="identifier">unique_groups</span><span class="punctuation">,</span> <span class="identifier">groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">groups</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">v</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">s</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">n_groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">unique_groups</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span> <span class="relational-operator">&gt;</span> <span class="identifier">n_groups</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Cannot have number of splits n_splits=%d greater"</span>
                             <span class="string-literal">" than the number of groups: %d."</span>
                             <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="identifier">n_groups</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="comment"># Weight groups by their number of occurrences</span>
        <span class="identifier">n_samples_per_group</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">bincount</span><span class="grouping">(</span><span class="identifier">groups</span><span class="grouping">)</span>

        <span class="comment"># Distribute the most frequent groups first</span>
        <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argsort</span><span class="grouping">(</span><span class="identifier">n_samples_per_group</span><span class="grouping">)</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span>
        <span class="identifier">n_samples_per_group</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_samples_per_group</span><span class="grouping">[</span><span class="identifier">indices</span><span class="grouping">]</span>

        <span class="comment"># Total weight of each fold</span>
        <span class="identifier">n_samples_per_fold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="grouping">)</span>

        <span class="comment"># Mapping from group index to fold index</span>
        <span class="identifier">group_to_fold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">unique_groups</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="comment"># Distribute samples by adding the largest weight to the lightest fold</span>
        <span class="keyword">for</span> <span class="identifier">group_index</span><span class="punctuation">,</span> <span class="identifier">weight</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">n_samples_per_group</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">lightest_fold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argmin</span><span class="grouping">(</span><span class="identifier">n_samples_per_fold</span><span class="grouping">)</span>
            <span class="identifier">n_samples_per_fold</span><span class="grouping">[</span><span class="identifier">lightest_fold</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">weight</span>
            <span class="identifier">group_to_fold</span><span class="grouping">[</span><span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">group_index</span><span class="grouping">]</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">lightest_fold</span>

        <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">group_to_fold</span><span class="grouping">[</span><span class="identifier">groups</span><span class="grouping">]</span>

        <span class="keyword">for</span> <span class="identifier">f</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">yield</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">where</span><span class="grouping">(</span><span class="identifier">indices</span> <span class="relational-operator">==</span> <span class="identifier">f</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">split</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generate indices to split data into training and test set.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples
            and n_features is the number of features.

        y : array-like of shape (n_samples,), default=None
            The target variable for supervised learning problems.

        groups : array-like of shape (n_samples,)
            Group labels for the samples used while splitting the dataset into
            train/test set.

        Yields
        ------
        train : ndarray
            The training set indices for that split.

        test : ndarray
            The testing set indices for that split.
        """</span>
        <span class="keyword">return</span> <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">StratifiedKFold</span><span class="grouping">(</span><span class="identifier">_BaseKFold</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Stratified K-Folds cross-validator.

    Provides train/test indices to split data in train/test sets.

    This cross-validation object is a variation of KFold that returns
    stratified folds. The folds are made by preserving the percentage of
    samples for each class.

    Read more in the :ref:`User Guide &lt;stratified_k_fold&gt;`.

    Parameters
    ----------
    n_splits : int, default=5
        Number of folds. Must be at least 2.

        .. versionchanged:: 0.22
            ``n_splits`` default value changed from 3 to 5.

    shuffle : bool, default=False
        Whether to shuffle each class's samples before splitting into batches.
        Note that the samples within each split will not be shuffled.

    random_state : int, RandomState instance or None, default=None
        When `shuffle` is True, `random_state` affects the ordering of the
        indices, which controls the randomness of each fold for each class.
        Otherwise, leave `random_state` as `None`.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import StratifiedKFold
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])
    &gt;&gt;&gt; y = np.array([0, 0, 1, 1])
    &gt;&gt;&gt; skf = StratifiedKFold(n_splits=2)
    &gt;&gt;&gt; skf.get_n_splits(X, y)
    2
    &gt;&gt;&gt; print(skf)
    StratifiedKFold(n_splits=2, random_state=None, shuffle=False)
    &gt;&gt;&gt; for train_index, test_index in skf.split(X, y):
    ...     print("TRAIN:", train_index, "TEST:", test_index)
    ...     X_train, X_test = X[train_index], X[test_index]
    ...     y_train, y_test = y[train_index], y[test_index]
    TRAIN: [1 3] TEST: [0 2]
    TRAIN: [0 2] TEST: [1 3]

    Notes
    -----
    The implementation is designed to:

    * Generate test sets such that all contain the same distribution of
      classes, or as close as possible.
    * Be invariant to class label: relabelling ``y = ["Happy", "Sad"]`` to
      ``y = [1, 0]`` should not change the indices generated.
    * Preserve order dependencies in the dataset ordering, when
      ``shuffle=False``: all samples from class k in some test set were
      contiguous in y, or separated in y by samples from classes other than k.
    * Generate test sets where the smallest and largest differ by at most one
      sample.

    .. versionchanged:: 0.22
        The previous implementation did not follow the last constraint.

    See Also
    --------
    RepeatedStratifiedKFold : Repeats Stratified K-Fold n times.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="int-literal">5</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="identifier">shuffle</span><span class="punctuation">,</span>
                         <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_make_test_folds</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">rng</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="identifier">type_of_target_y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">type_of_target</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="identifier">allowed_target_types</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="string-literal">'binary', 'multiclass'</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">type_of_target_y</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="identifier">allowed_target_types</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">'Supported target types are: {}. Got {!r} instead.'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span>
                    <span class="identifier">allowed_target_types</span><span class="punctuation">,</span> <span class="identifier">type_of_target_y</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>

        <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">y_idx</span><span class="punctuation">,</span> <span class="identifier">y_inv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">x</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">v</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">s</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="comment"># y_inv encodes y according to lexicographic order. We invert y_idx to</span>
        <span class="comment"># map the classes so that they are encoded by order of appearance:</span>
        <span class="comment"># 0 represents the first label appearing in y, 1 the second, etc.</span>
        <span class="identifier">_</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">m</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">y_idx</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">v</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">s</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">y_encoded</span> <span class="arithmetic-assignment">=</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">m</span><span class="grouping">[</span><span class="identifier">y_inv</span><span class="grouping">]</span>

        <span class="identifier">n_classes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y_idx</span><span class="grouping">)</span>
        <span class="identifier">y_counts</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">bincount</span><span class="grouping">(</span><span class="identifier">y_encoded</span><span class="grouping">)</span>
        <span class="identifier">min_groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">min</span><span class="grouping">(</span><span class="identifier">y_counts</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">all</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span> <span class="relational-operator">&gt;</span> <span class="identifier">y_counts</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"n_splits=%d cannot be greater than the"</span>
                             <span class="string-literal">" number of members in each class."</span>
                             <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span> <span class="relational-operator">&gt;</span> <span class="identifier">min_groups</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="grouping">(</span><span class="string-literal">"The least populated class in y has only %d"</span>
                           <span class="string-literal">" members, which is less than n_splits=%d."</span>
                           <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">min_groups</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">UserWarning</span><span class="grouping">)</span>

        <span class="comment"># Determine the optimal number of samples from each class in each fold,</span>
        <span class="comment"># using round robin over the sorted y. (This can be done direct from</span>
        <span class="comment"># counts, but that code is unreadable.)</span>
        <span class="identifier">y_order</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sort</span><span class="grouping">(</span><span class="identifier">y_encoded</span><span class="grouping">)</span>
        <span class="identifier">allocation</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span>
            <span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">bincount</span><span class="grouping">(</span><span class="identifier">y_order</span><span class="grouping">[</span><span class="identifier">i</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">minlength</span><span class="arithmetic-assignment">=</span><span class="identifier">n_classes</span><span class="grouping">)</span>
             <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="comment"># To maintain the data order dependencies as best as possible within</span>
        <span class="comment"># the stratification constraint, we assign samples from each class in</span>
        <span class="comment"># blocks (and then mess that up when shuffle=True).</span>
        <span class="identifier">test_folds</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="string-literal">'i'</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">k</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_classes</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># since the kth column of allocation stores the number of samples</span>
            <span class="comment"># of class k in each test set, this generates blocks of fold</span>
            <span class="comment"># indices corresponding to the allocation for class k.</span>
            <span class="identifier">folds_for_class</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">repeat</span><span class="grouping">(</span><span class="identifier">allocation</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">k</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">shuffle</span><span class="punctuation">:</span>
                <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">shuffle</span><span class="grouping">(</span><span class="identifier">folds_for_class</span><span class="grouping">)</span>
            <span class="identifier">test_folds</span><span class="grouping">[</span><span class="identifier">y_encoded</span> <span class="relational-operator">==</span> <span class="identifier">k</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">folds_for_class</span>
        <span class="keyword">return</span> <span class="identifier">test_folds</span>

    <span class="keyword">def</span> <span class="identifier">_iter_test_masks</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">test_folds</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_make_test_folds</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">yield</span> <span class="identifier">test_folds</span> <span class="relational-operator">==</span> <span class="identifier">i</span>

    <span class="keyword">def</span> <span class="identifier">split</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generate indices to split data into training and test set.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples
            and n_features is the number of features.

            Note that providing ``y`` is sufficient to generate the splits and
            hence ``np.zeros(n_samples)`` may be used as a placeholder for
            ``X`` instead of actual training data.

        y : array-like of shape (n_samples,)
            The target variable for supervised learning problems.
            Stratification is done based on the y labels.

        groups : object
            Always ignored, exists for compatibility.

        Yields
        ------
        train : ndarray
            The training set indices for that split.

        test : ndarray
            The testing set indices for that split.

        Notes
        -----
        Randomized CV splitters may return different results for each call of
        split. You can make the results identical by setting `random_state`
        to an integer.
        """</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">StratifiedGroupKFold</span><span class="grouping">(</span><span class="identifier">_BaseKFold</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Stratified K-Folds iterator variant with non-overlapping groups.

    This cross-validation object is a variation of StratifiedKFold attempts to
    return stratified folds with non-overlapping groups. The folds are made by
    preserving the percentage of samples for each class.

    The same group will not appear in two different folds (the number of
    distinct groups has to be at least equal to the number of folds).

    The difference between GroupKFold and StratifiedGroupKFold is that
    the former attempts to create balanced folds such that the number of
    distinct groups is approximately the same in each fold, whereas
    StratifiedGroupKFold attempts to create folds which preserve the
    percentage of samples for each class as much as possible given the
    constraint of non-overlapping groups between splits.

    Read more in the :ref:`User Guide &lt;cross_validation&gt;`.

    Parameters
    ----------
    n_splits : int, default=5
        Number of folds. Must be at least 2.

    shuffle : bool, default=False
        Whether to shuffle each class's samples before splitting into batches.
        Note that the samples within each split will not be shuffled.
        This implementation can only shuffle groups that have approximately the
        same y distribution, no global shuffle will be performed.

    random_state : int or RandomState instance, default=None
        When `shuffle` is True, `random_state` affects the ordering of the
        indices, which controls the randomness of each fold for each class.
        Otherwise, leave `random_state` as `None`.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import StratifiedGroupKFold
    &gt;&gt;&gt; X = np.ones((17, 2))
    &gt;&gt;&gt; y = np.array([0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0])
    &gt;&gt;&gt; groups = np.array([1, 1, 2, 2, 3, 3, 3, 4, 5, 5, 5, 5, 6, 6, 7, 8, 8])
    &gt;&gt;&gt; cv = StratifiedGroupKFold(n_splits=3)
    &gt;&gt;&gt; for train_idxs, test_idxs in cv.split(X, y, groups):
    ...     print("TRAIN:", groups[train_idxs])
    ...     print("      ", y[train_idxs])
    ...     print(" TEST:", groups[test_idxs])
    ...     print("      ", y[test_idxs])
    TRAIN: [1 1 2 2 4 5 5 5 5 8 8]
           [0 0 1 1 1 0 0 0 0 0 0]
     TEST: [3 3 3 6 6 7]
           [1 1 1 0 0 0]
    TRAIN: [3 3 3 4 5 5 5 5 6 6 7]
           [1 1 1 1 0 0 0 0 0 0 0]
     TEST: [1 1 2 2 8 8]
           [0 0 1 1 0 0]
    TRAIN: [1 1 2 2 3 3 3 6 6 7 8 8]
           [0 0 1 1 1 1 1 0 0 0 0 0]
     TEST: [4 5 5 5 5]
           [1 0 0 0 0]

    Notes
    -----
    The implementation is designed to:

    * Mimic the behavior of StratifiedKFold as much as possible for trivial
      groups (e.g. when each group contains only one sample).
    * Be invariant to class label: relabelling ``y = ["Happy", "Sad"]`` to
      ``y = [1, 0]`` should not change the indices generated.
    * Stratify based on samples as much as possible while keeping
      non-overlapping groups constraint. That means that in some cases when
      there is a small number of groups containing a large number of samples
      the stratification will not be possible and the behavior will be close
      to GroupKFold.

    See also
    --------
    StratifiedKFold: Takes class information into account to build folds which
        retain class distributions (for binary or multiclass classification
        tasks).

    GroupKFold: K-fold iterator variant with non-overlapping groups.
    """</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="int-literal">5</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="identifier">shuffle</span><span class="punctuation">,</span>
                         <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_iter_test_indices</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># Implementation is based on this kaggle kernel:</span>
        <span class="comment"># https://www.kaggle.com/jakubwasikowski/stratified-group-k-fold-cross-validation</span>
        <span class="comment"># and is a subject to Apache 2.0 License. You may obtain a copy of the</span>
        <span class="comment"># License at http://www.apache.org/licenses/LICENSE-2.0</span>
        <span class="comment"># Changelist:</span>
        <span class="comment"># - Refactored function to a class following scikit-learn KFold</span>
        <span class="comment">#   interface.</span>
        <span class="comment"># - Added heuristic for assigning group to the least populated fold in</span>
        <span class="comment">#   cases when all other criteria are equal</span>
        <span class="comment"># - Swtch from using python ``Counter`` to ``np.unique`` to get class</span>
        <span class="comment">#   distribution</span>
        <span class="comment"># - Added scikit-learn checks for input: checking that target is binary</span>
        <span class="comment">#   or multiclass, checking passed random state, checking that number</span>
        <span class="comment">#   of splits is less than number of members in each class, checking</span>
        <span class="comment">#   that least populated class has more members than there are splits.</span>
        <span class="identifier">rng</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="identifier">type_of_target_y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">type_of_target</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="identifier">allowed_target_types</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="string-literal">'binary', 'multiclass'</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">type_of_target_y</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="identifier">allowed_target_types</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">'Supported target types are: {}. Got {!r} instead.'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span>
                    <span class="identifier">allowed_target_types</span><span class="punctuation">,</span> <span class="identifier">type_of_target_y</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">y_inv</span><span class="punctuation">,</span> <span class="identifier">y_cnt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">v</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">s</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">u</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">all</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span> <span class="relational-operator">&gt;</span> <span class="identifier">y_cnt</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"n_splits=%d cannot be greater than the"</span>
                             <span class="string-literal">" number of members in each class."</span>
                             <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">n_smallest_class</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">min</span><span class="grouping">(</span><span class="identifier">y_cnt</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span> <span class="relational-operator">&gt;</span> <span class="identifier">n_smallest_class</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="grouping">(</span><span class="string-literal">"The least populated class in y has only %d"</span>
                           <span class="string-literal">" members, which is less than n_splits=%d."</span>
                           <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">n_smallest_class</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">UserWarning</span><span class="grouping">)</span>
        <span class="identifier">n_classes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y_cnt</span><span class="grouping">)</span>

        <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">groups_inv</span><span class="punctuation">,</span> <span class="identifier">groups_cnt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span>
            <span class="identifier">groups</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">v</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">s</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">u</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">y_counts_per_group</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">groups_cnt</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">n_classes</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">d</span><span class="invalid">x</span><span class="punctuation">,</span> <span class="identifier">group_idx</span> <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">y_inv</span><span class="punctuation">,</span> <span class="identifier">groups_inv</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">y_counts_per_group</span><span class="grouping">[</span><span class="identifier">group_idx</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">d</span><span class="invalid">x</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">1</span>

        <span class="identifier">y_counts_per_fold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="identifier">n_classes</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">groups_per_fold</span> <span class="arithmetic-assignment">=</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">d</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">set</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">shuffle</span><span class="punctuation">:</span>
            <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">shuffle</span><span class="grouping">(</span><span class="identifier">y_counts_per_group</span><span class="grouping">)</span>

        <span class="comment"># Stable sort to keep shuffled order for groups with the same</span>
        <span class="comment"># class distribution variance</span>
        <span class="identifier">sorted_groups_idx</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argsort</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">std</span><span class="grouping">(</span><span class="identifier">y_counts_per_group</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">,</span>
                                       <span class="identifier">kind</span><span class="arithmetic-assignment">=</span><span class="string-literal">'mergesort'</span><span class="grouping">)</span>

        <span class="keyword">for</span> <span class="identifier">group_idx</span> <span class="relational-operator">in</span> <span class="identifier">sorted_groups_idx</span><span class="punctuation">:</span>
            <span class="identifier">group_y_counts</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y_counts_per_group</span><span class="grouping">[</span><span class="identifier">group_idx</span><span class="grouping">]</span>
            <span class="identifier">best_fold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_find_best_fold</span><span class="grouping">(</span>
                <span class="identifier">y_counts_per_fold</span><span class="arithmetic-assignment">=</span><span class="identifier">y_counts_per_fold</span><span class="punctuation">,</span> <span class="identifier">y_cnt</span><span class="arithmetic-assignment">=</span><span class="identifier">y_cnt</span><span class="punctuation">,</span>
                <span class="identifier">group_y_counts</span><span class="arithmetic-assignment">=</span><span class="identifier">group_y_counts</span><span class="grouping">)</span>
            <span class="identifier">y_counts_per_fold</span><span class="grouping">[</span><span class="identifier">best_fold</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">group_y_counts</span>
            <span class="identifier">groups_per_fold</span><span class="grouping">[</span><span class="identifier">best_fold</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">add</span><span class="grouping">(</span><span class="identifier">group_idx</span><span class="grouping">)</span>

        <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">test_indices</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">idx</span> <span class="keyword">for</span> <span class="identifier">idx</span><span class="punctuation">,</span> <span class="identifier">group_idx</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">groups_inv</span><span class="grouping">)</span>
                            <span class="keyword">if</span> <span class="identifier">group_idx</span> <span class="relational-operator">in</span> <span class="identifier">groups_per_fold</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">]</span>
            <span class="keyword">yield</span> <span class="identifier">test_indices</span>

    <span class="keyword">def</span> <span class="identifier">_find_best_fold</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y_counts_per_fold</span><span class="punctuation">,</span> <span class="identifier">y_cnt</span><span class="punctuation">,</span> <span class="identifier">group_y_counts</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">best_fold</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
        <span class="identifier">min_eval</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">inf</span>
        <span class="identifier">min_samples_in_fold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">inf</span>
        <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">y_counts_per_fold</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">group_y_counts</span>
            <span class="comment"># Summarise the distribution over classes in each proposed fold</span>
            <span class="identifier">std_per_class</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">std</span><span class="grouping">(</span>
                <span class="identifier">y_counts_per_fold</span> <span class="arithmetic-operator">/</span> <span class="identifier">y_cnt</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">,</span>
                <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
            <span class="identifier">y_counts_per_fold</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">group_y_counts</span>
            <span class="identifier">fold_eval</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="identifier">std_per_class</span><span class="grouping">)</span>
            <span class="identifier">samples_in_fold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">y_counts_per_fold</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="identifier">is_current_fold_better</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span>
                <span class="identifier">fold_eval</span> <span class="relational-operator">&lt;</span> <span class="identifier">min_eval</span> <span class="logical-operator">or</span>
                <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">isclose</span><span class="grouping">(</span><span class="identifier">fold_eval</span><span class="punctuation">,</span> <span class="identifier">min_eval</span><span class="grouping">)</span>
                <span class="logical-operator">and</span> <span class="identifier">samples_in_fold</span> <span class="relational-operator">&lt;</span> <span class="identifier">min_samples_in_fold</span>
            <span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">is_current_fold_better</span><span class="punctuation">:</span>
                <span class="identifier">min_eval</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fold_eval</span>
                <span class="identifier">min_samples_in_fold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">samples_in_fold</span>
                <span class="identifier">best_fold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">i</span>
        <span class="keyword">return</span> <span class="identifier">best_fold</span>


<span class="keyword">class</span> <span class="identifier">TimeSeriesSplit</span><span class="grouping">(</span><span class="identifier">_BaseKFold</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Time Series cross-validator

    Provides train/test indices to split time series data samples
    that are observed at fixed time intervals, in train/test sets.
    In each split, test indices must be higher than before, and thus shuffling
    in cross validator is inappropriate.

    This cross-validation object is a variation of :class:`KFold`.
    In the kth split, it returns first k folds as train set and the
    (k+1)th fold as test set.

    Note that unlike standard cross-validation methods, successive
    training sets are supersets of those that come before them.

    Read more in the :ref:`User Guide &lt;time_series_split&gt;`.

    .. versionadded:: 0.18

    Parameters
    ----------
    n_splits : int, default=5
        Number of splits. Must be at least 2.

        .. versionchanged:: 0.22
            ``n_splits`` default value changed from 3 to 5.

    max_train_size : int, default=None
        Maximum size for a single training set.

    test_size : int, default=None
        Used to limit the size of the test set. Defaults to
        ``n_samples // (n_splits + 1)``, which is the maximum allowed value
        with ``gap=0``.

        .. versionadded:: 0.24

    gap : int, default=0
        Number of samples to exclude from the end of each train set before
        the test set.

        .. versionadded:: 0.24

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import TimeSeriesSplit
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])
    &gt;&gt;&gt; y = np.array([1, 2, 3, 4, 5, 6])
    &gt;&gt;&gt; tscv = TimeSeriesSplit()
    &gt;&gt;&gt; print(tscv)
    TimeSeriesSplit(gap=0, max_train_size=None, n_splits=5, test_size=None)
    &gt;&gt;&gt; for train_index, test_index in tscv.split(X):
    ...     print("TRAIN:", train_index, "TEST:", test_index)
    ...     X_train, X_test = X[train_index], X[test_index]
    ...     y_train, y_test = y[train_index], y[test_index]
    TRAIN: [0] TEST: [1]
    TRAIN: [0 1] TEST: [2]
    TRAIN: [0 1 2] TEST: [3]
    TRAIN: [0 1 2 3] TEST: [4]
    TRAIN: [0 1 2 3 4] TEST: [5]
    &gt;&gt;&gt; # Fix test_size to 2 with 12 samples
    &gt;&gt;&gt; X = np.random.randn(12, 2)
    &gt;&gt;&gt; y = np.random.randint(0, 2, 12)
    &gt;&gt;&gt; tscv = TimeSeriesSplit(n_splits=3, test_size=2)
    &gt;&gt;&gt; for train_index, test_index in tscv.split(X):
    ...    print("TRAIN:", train_index, "TEST:", test_index)
    ...    X_train, X_test = X[train_index], X[test_index]
    ...    y_train, y_test = y[train_index], y[test_index]
    TRAIN: [0 1 2 3 4 5] TEST: [6 7]
    TRAIN: [0 1 2 3 4 5 6 7] TEST: [8 9]
    TRAIN: [0 1 2 3 4 5 6 7 8 9] TEST: [10 11]
    &gt;&gt;&gt; # Add in a 2 period gap
    &gt;&gt;&gt; tscv = TimeSeriesSplit(n_splits=3, test_size=2, gap=2)
    &gt;&gt;&gt; for train_index, test_index in tscv.split(X):
    ...    print("TRAIN:", train_index, "TEST:", test_index)
    ...    X_train, X_test = X[train_index], X[test_index]
    ...    y_train, y_test = y[train_index], y[test_index]
    TRAIN: [0 1 2 3] TEST: [6 7]
    TRAIN: [0 1 2 3 4 5] TEST: [8 9]
    TRAIN: [0 1 2 3 4 5 6 7] TEST: [10 11]

    Notes
    -----
    The training set has size ``i * n_samples // (n_splits + 1)
    + n_samples % (n_splits + 1)`` in the ``i`` th split,
    with a test set of size ``n_samples//(n_splits + 1)`` by default,
    where ``n_samples`` is the number of samples.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span>
                 <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="int-literal">5</span><span class="punctuation">,</span>
                 <span class="arithmetic-operator">*</span><span class="punctuation">,</span>
                 <span class="identifier">max_train_size</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">test_size</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">gap</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_train_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_train_size</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">test_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">test_size</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">gap</span> <span class="arithmetic-assignment">=</span> <span class="identifier">gap</span>

    <span class="keyword">def</span> <span class="identifier">split</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generate indices to split data into training and test set.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples
            and n_features is the number of features.

        y : array-like of shape (n_samples,)
            Always ignored, exists for compatibility.

        groups : array-like of shape (n_samples,)
            Always ignored, exists for compatibility.

        Yields
        ------
        train : ndarray
            The training set indices for that split.

        test : ndarray
            The testing set indices for that split.
        """</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">indexable</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">n_splits</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span>
        <span class="identifier">n_folds</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_splits</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span>
        <span class="identifier">gap</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">gap</span>
        <span class="identifier">test_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">test_size</span> <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">test_size</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="invalid">\</span>
            <span class="keyword">else</span> <span class="identifier">n_samples</span> <span class="arithmetic-operator">//</span> <span class="identifier">n_folds</span>

        <span class="comment"># Make sure we have enough samples for the given split parameters</span>
        <span class="keyword">if</span> <span class="identifier">n_folds</span> <span class="relational-operator">&gt;</span> <span class="identifier">n_samples</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Cannot have number of folds={n_folds} greater"</span>
                 <span class="identifier">f</span><span class="string-literal">" than the number of samples={n_samples}."</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">n_samples</span> <span class="arithmetic-operator">-</span> <span class="identifier">gap</span> <span class="arithmetic-operator">-</span> <span class="grouping">(</span><span class="identifier">test_size</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_splits</span><span class="grouping">)</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Too many splits={n_splits} for number of samples"</span>
                 <span class="identifier">f</span><span class="string-literal">"={n_samples} with test_size={test_size} and gap={gap}."</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="grouping">)</span>
        <span class="identifier">test_starts</span> <span class="arithmetic-assignment">=</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_samples</span> <span class="arithmetic-operator">-</span> <span class="identifier">n_splits</span> <span class="arithmetic-operator">*</span> <span class="identifier">test_size</span><span class="punctuation">,</span>
                            <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">test_size</span><span class="grouping">)</span>

        <span class="keyword">for</span> <span class="identifier">test_start</span> <span class="relational-operator">in</span> <span class="identifier">test_starts</span><span class="punctuation">:</span>
            <span class="identifier">train_end</span> <span class="arithmetic-assignment">=</span> <span class="identifier">test_start</span> <span class="arithmetic-operator">-</span> <span class="identifier">gap</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_train_size</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_train_size</span> <span class="relational-operator">&lt;</span> <span class="identifier">train_end</span><span class="punctuation">:</span>
                <span class="keyword">yield</span> <span class="grouping">(</span><span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">train_end</span> <span class="arithmetic-operator">-</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_train_size</span><span class="punctuation">:</span><span class="identifier">train_end</span><span class="grouping">]</span><span class="punctuation">,</span>
                       <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">test_start</span><span class="punctuation">:</span><span class="identifier">test_start</span> <span class="arithmetic-operator">+</span> <span class="identifier">test_size</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="keyword">yield</span> <span class="grouping">(</span><span class="identifier">indices</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">train_end</span><span class="grouping">]</span><span class="punctuation">,</span>
                       <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">test_start</span><span class="punctuation">:</span><span class="identifier">test_start</span> <span class="arithmetic-operator">+</span> <span class="identifier">test_size</span><span class="grouping">]</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">LeaveOneGroupOut</span><span class="grouping">(</span><span class="identifier">BaseCrossValidator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Leave One Group Out cross-validator

    Provides train/test indices to split data according to a third-party
    provided group. This group information can be used to encode arbitrary
    domain specific stratifications of the samples as integers.

    For instance the groups could be the year of collection of the samples
    and thus allow for cross-validation against time-based splits.

    Read more in the :ref:`User Guide &lt;leave_one_group_out&gt;`.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import LeaveOneGroupOut
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])
    &gt;&gt;&gt; y = np.array([1, 2, 1, 2])
    &gt;&gt;&gt; groups = np.array([1, 1, 2, 2])
    &gt;&gt;&gt; logo = LeaveOneGroupOut()
    &gt;&gt;&gt; logo.get_n_splits(X, y, groups)
    2
    &gt;&gt;&gt; logo.get_n_splits(groups=groups)  # 'groups' is always required
    2
    &gt;&gt;&gt; print(logo)
    LeaveOneGroupOut()
    &gt;&gt;&gt; for train_index, test_index in logo.split(X, y, groups):
    ...     print("TRAIN:", train_index, "TEST:", test_index)
    ...     X_train, X_test = X[train_index], X[test_index]
    ...     y_train, y_test = y[train_index], y[test_index]
    ...     print(X_train, X_test, y_train, y_test)
    TRAIN: [2 3] TEST: [0 1]
    [[5 6]
     [7 8]] [[1 2]
     [3 4]] [1 2] [1 2]
    TRAIN: [0 1] TEST: [2 3]
    [[1 2]
     [3 4]] [[5 6]
     [7 8]] [1 2] [1 2]

    """</span>

    <span class="keyword">def</span> <span class="identifier">_iter_test_masks</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">groups</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"The 'groups' parameter should not be None."</span><span class="grouping">)</span>
        <span class="comment"># We make a copy of groups to avoid side-effects during iteration</span>
        <span class="identifier">groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">groups</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span>
        <span class="identifier">unique_groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">groups</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">unique_groups</span><span class="grouping">)</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">"The groups parameter contains fewer than 2 unique groups "</span>
                <span class="string-literal">"(%s). LeaveOneGroupOut expects at least 2."</span> <span class="arithmetic-operator">%</span> <span class="identifier">unique_groups</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">unique_groups</span><span class="punctuation">:</span>
            <span class="keyword">yield</span> <span class="identifier">groups</span> <span class="relational-operator">==</span> <span class="identifier">i</span>

    <span class="keyword">def</span> <span class="identifier">get_n_splits</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Returns the number of splitting iterations in the cross-validator

        Parameters
        ----------
        X : object
            Always ignored, exists for compatibility.

        y : object
            Always ignored, exists for compatibility.

        groups : array-like of shape (n_samples,)
            Group labels for the samples used while splitting the dataset into
            train/test set. This 'groups' parameter must always be specified to
            calculate the number of splits, though the other parameters can be
            omitted.

        Returns
        -------
        n_splits : int
            Returns the number of splitting iterations in the cross-validator.
        """</span>
        <span class="keyword">if</span> <span class="identifier">groups</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"The 'groups' parameter should not be None."</span><span class="grouping">)</span>
        <span class="identifier">groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">groups</span><span class="punctuation">,</span> <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">groups</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">split</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generate indices to split data into training and test set.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples
            and n_features is the number of features.

        y : array-like of shape (n_samples,), default=None
            The target variable for supervised learning problems.

        groups : array-like of shape (n_samples,)
            Group labels for the samples used while splitting the dataset into
            train/test set.

        Yields
        ------
        train : ndarray
            The training set indices for that split.

        test : ndarray
            The testing set indices for that split.
        """</span>
        <span class="keyword">return</span> <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">LeavePGroupsOut</span><span class="grouping">(</span><span class="identifier">BaseCrossValidator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Leave P Group(s) Out cross-validator

    Provides train/test indices to split data according to a third-party
    provided group. This group information can be used to encode arbitrary
    domain specific stratifications of the samples as integers.

    For instance the groups could be the year of collection of the samples
    and thus allow for cross-validation against time-based splits.

    The difference between LeavePGroupsOut and LeaveOneGroupOut is that
    the former builds the test sets with all the samples assigned to
    ``p`` different values of the groups while the latter uses samples
    all assigned the same groups.

    Read more in the :ref:`User Guide &lt;leave_p_groups_out&gt;`.

    Parameters
    ----------
    n_groups : int
        Number of groups (``p``) to leave out in the test split.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import LeavePGroupsOut
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [5, 6]])
    &gt;&gt;&gt; y = np.array([1, 2, 1])
    &gt;&gt;&gt; groups = np.array([1, 2, 3])
    &gt;&gt;&gt; lpgo = LeavePGroupsOut(n_groups=2)
    &gt;&gt;&gt; lpgo.get_n_splits(X, y, groups)
    3
    &gt;&gt;&gt; lpgo.get_n_splits(groups=groups)  # 'groups' is always required
    3
    &gt;&gt;&gt; print(lpgo)
    LeavePGroupsOut(n_groups=2)
    &gt;&gt;&gt; for train_index, test_index in lpgo.split(X, y, groups):
    ...     print("TRAIN:", train_index, "TEST:", test_index)
    ...     X_train, X_test = X[train_index], X[test_index]
    ...     y_train, y_test = y[train_index], y[test_index]
    ...     print(X_train, X_test, y_train, y_test)
    TRAIN: [2] TEST: [0 1]
    [[5 6]] [[1 2]
     [3 4]] [1] [1 2]
    TRAIN: [1] TEST: [0 2]
    [[3 4]] [[1 2]
     [5 6]] [2] [1 1]
    TRAIN: [0] TEST: [1 2]
    [[1 2]] [[3 4]
     [5 6]] [1] [2 1]

    See Also
    --------
    GroupKFold : K-fold iterator variant with non-overlapping groups.
    """</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">n_groups</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_groups</span>

    <span class="keyword">def</span> <span class="identifier">_iter_test_masks</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">groups</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"The 'groups' parameter should not be None."</span><span class="grouping">)</span>
        <span class="identifier">groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">groups</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span>
        <span class="identifier">unique_groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">groups</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_groups</span> <span class="relational-operator">&gt;=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">unique_groups</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">"The groups parameter contains fewer than (or equal to) "</span>
                <span class="string-literal">"n_groups (%d) numbers of unique groups (%s). LeavePGroupsOut "</span>
                <span class="string-literal">"expects that at least n_groups + 1 (%d) unique groups be "</span>
                <span class="string-literal">"present"</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_groups</span><span class="punctuation">,</span> <span class="identifier">unique_groups</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_groups</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">combi</span> <span class="arithmetic-assignment">=</span> <span class="identifier">combinations</span><span class="grouping">(</span><span class="identifier">range</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">unique_groups</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_groups</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">indices</span> <span class="relational-operator">in</span> <span class="identifier">combi</span><span class="punctuation">:</span>
            <span class="identifier">test_index</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">bool</span><span class="grouping">)</span>
            <span class="keyword">for</span> <span class="identifier">l</span> <span class="relational-operator">in</span> <span class="identifier">unique_groups</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="identifier">indices</span><span class="grouping">)</span><span class="grouping">]</span><span class="punctuation">:</span>
                <span class="identifier">test_index</span><span class="grouping">[</span><span class="identifier">groups</span> <span class="relational-operator">==</span> <span class="identifier">l</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>
            <span class="keyword">yield</span> <span class="identifier">test_index</span>

    <span class="keyword">def</span> <span class="identifier">get_n_splits</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Returns the number of splitting iterations in the cross-validator

        Parameters
        ----------
        X : object
            Always ignored, exists for compatibility.

        y : object
            Always ignored, exists for compatibility.

        groups : array-like of shape (n_samples,)
            Group labels for the samples used while splitting the dataset into
            train/test set. This 'groups' parameter must always be specified to
            calculate the number of splits, though the other parameters can be
            omitted.

        Returns
        -------
        n_splits : int
            Returns the number of splitting iterations in the cross-validator.
        """</span>
        <span class="keyword">if</span> <span class="identifier">groups</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"The 'groups' parameter should not be None."</span><span class="grouping">)</span>
        <span class="identifier">groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">groups</span><span class="punctuation">,</span> <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">int</span><span class="grouping">(</span><span class="identifier">comb</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">groups</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_groups</span><span class="punctuation">,</span> <span class="identifier">exact</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">split</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generate indices to split data into training and test set.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples
            and n_features is the number of features.

        y : array-like of shape (n_samples,), default=None
            The target variable for supervised learning problems.

        groups : array-like of shape (n_samples,)
            Group labels for the samples used while splitting the dataset into
            train/test set.

        Yields
        ------
        train : ndarray
            The training set indices for that split.

        test : ndarray
            The testing set indices for that split.
        """</span>
        <span class="keyword">return</span> <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">_RepeatedSplits</span><span class="grouping">(</span><span class="identifier">metaclass</span><span class="arithmetic-assignment">=</span><span class="identifier">ABCMeta</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Repeated splits for an arbitrary randomized CV splitter.

    Repeats splits for cross-validators n times with different randomization
    in each repetition.

    Parameters
    ----------
    cv : callable
        Cross-validator class.

    n_repeats : int, default=10
        Number of times cross-validator needs to be repeated.

    random_state : int, RandomState instance or None, default=None
        Passes `random_state` to the arbitrary repeating cross validator.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    **cvargs : additional params
        Constructor parameters for cv. Must not contain random_state
        and shuffle.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">n_repeats</span><span class="arithmetic-assignment">=</span><span class="int-literal">10</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">cvargs</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">n_repeats</span><span class="punctuation">,</span> <span class="identifier">numbers</span><span class="punctuation">.</span><span class="identifier">Integral</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Number of repetitions must be of Integral type."</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">n_repeats</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Number of repetitions must be greater than 0."</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">any</span><span class="grouping">(</span><span class="identifier">key</span> <span class="relational-operator">in</span> <span class="identifier">cvargs</span> <span class="keyword">for</span> <span class="identifier">key</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="string-literal">'random_state', 'shuffle'</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">"cvargs must not contain random_state or shuffle."</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cv</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_repeats</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_repeats</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cvargs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cvargs</span>

    <span class="keyword">def</span> <span class="identifier">split</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generates indices to split data into training and test set.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples
            and n_features is the number of features.

        y : array-like of shape (n_samples,)
            The target variable for supervised learning problems.

        groups : array-like of shape (n_samples,), default=None
            Group labels for the samples used while splitting the dataset into
            train/test set.

        Yields
        ------
        train : ndarray
            The training set indices for that split.

        test : ndarray
            The testing set indices for that split.
        """</span>
        <span class="identifier">n_repeats</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_repeats</span>
        <span class="identifier">rng</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span>

        <span class="keyword">for</span> <span class="identifier">idx</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_repeats</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span><span class="grouping">(</span><span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">rng</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                         <span class="arithmetic-operator">**</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cvargs</span><span class="grouping">)</span>
            <span class="keyword">for</span> <span class="identifier">train_index</span><span class="punctuation">,</span> <span class="identifier">test_index</span> <span class="relational-operator">in</span> <span class="identifier">cv</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">yield</span> <span class="identifier">train_index</span><span class="punctuation">,</span> <span class="identifier">test_index</span>

    <span class="keyword">def</span> <span class="identifier">get_n_splits</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Returns the number of splitting iterations in the cross-validator

        Parameters
        ----------
        X : object
            Always ignored, exists for compatibility.
            ``np.zeros(n_samples)`` may be used as a placeholder.

        y : object
            Always ignored, exists for compatibility.
            ``np.zeros(n_samples)`` may be used as a placeholder.

        groups : array-like of shape (n_samples,), default=None
            Group labels for the samples used while splitting the dataset into
            train/test set.

        Returns
        -------
        n_splits : int
            Returns the number of splitting iterations in the cross-validator.
        """</span>
        <span class="identifier">rng</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span><span class="grouping">(</span><span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">rng</span><span class="punctuation">,</span> <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                     <span class="arithmetic-operator">**</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cvargs</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">cv</span><span class="punctuation">.</span><span class="identifier">get_n_splits</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_repeats</span>

    <span class="keyword">def</span> <span class="identifier">__repr__</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">_build_repr</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">RepeatedKFold</span><span class="grouping">(</span><span class="identifier">_RepeatedSplits</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Repeated K-Fold cross validator.

    Repeats K-Fold n times with different randomization in each repetition.

    Read more in the :ref:`User Guide &lt;repeated_k_fold&gt;`.

    Parameters
    ----------
    n_splits : int, default=5
        Number of folds. Must be at least 2.

    n_repeats : int, default=10
        Number of times cross-validator needs to be repeated.

    random_state : int, RandomState instance or None, default=None
        Controls the randomness of each repeated cross-validation instance.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import RepeatedKFold
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])
    &gt;&gt;&gt; y = np.array([0, 0, 1, 1])
    &gt;&gt;&gt; rkf = RepeatedKFold(n_splits=2, n_repeats=2, random_state=2652124)
    &gt;&gt;&gt; for train_index, test_index in rkf.split(X):
    ...     print("TRAIN:", train_index, "TEST:", test_index)
    ...     X_train, X_test = X[train_index], X[test_index]
    ...     y_train, y_test = y[train_index], y[test_index]
    ...
    TRAIN: [0 1] TEST: [2 3]
    TRAIN: [2 3] TEST: [0 1]
    TRAIN: [1 2] TEST: [0 3]
    TRAIN: [0 3] TEST: [1 2]

    Notes
    -----
    Randomized CV splitters may return different results for each call of
    split. You can make the results identical by setting `random_state`
    to an integer.

    See Also
    --------
    RepeatedStratifiedKFold : Repeats Stratified K-Fold n times.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="int-literal">5</span><span class="punctuation">,</span> <span class="identifier">n_repeats</span><span class="arithmetic-assignment">=</span><span class="int-literal">10</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">KFold</span><span class="punctuation">,</span> <span class="identifier">n_repeats</span><span class="arithmetic-assignment">=</span><span class="identifier">n_repeats</span><span class="punctuation">,</span>
            <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="punctuation">,</span> <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="identifier">n_splits</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">RepeatedStratifiedKFold</span><span class="grouping">(</span><span class="identifier">_RepeatedSplits</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Repeated Stratified K-Fold cross validator.

    Repeats Stratified K-Fold n times with different randomization in each
    repetition.

    Read more in the :ref:`User Guide &lt;repeated_k_fold&gt;`.

    Parameters
    ----------
    n_splits : int, default=5
        Number of folds. Must be at least 2.

    n_repeats : int, default=10
        Number of times cross-validator needs to be repeated.

    random_state : int, RandomState instance or None, default=None
        Controls the generation of the random states for each repetition.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import RepeatedStratifiedKFold
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])
    &gt;&gt;&gt; y = np.array([0, 0, 1, 1])
    &gt;&gt;&gt; rskf = RepeatedStratifiedKFold(n_splits=2, n_repeats=2,
    ...     random_state=36851234)
    &gt;&gt;&gt; for train_index, test_index in rskf.split(X, y):
    ...     print("TRAIN:", train_index, "TEST:", test_index)
    ...     X_train, X_test = X[train_index], X[test_index]
    ...     y_train, y_test = y[train_index], y[test_index]
    ...
    TRAIN: [1 2] TEST: [0 3]
    TRAIN: [0 3] TEST: [1 2]
    TRAIN: [1 3] TEST: [0 2]
    TRAIN: [0 2] TEST: [1 3]

    Notes
    -----
    Randomized CV splitters may return different results for each call of
    split. You can make the results identical by setting `random_state`
    to an integer.

    See Also
    --------
    RepeatedKFold : Repeats K-Fold n times.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="int-literal">5</span><span class="punctuation">,</span> <span class="identifier">n_repeats</span><span class="arithmetic-assignment">=</span><span class="int-literal">10</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">StratifiedKFold</span><span class="punctuation">,</span> <span class="identifier">n_repeats</span><span class="arithmetic-assignment">=</span><span class="identifier">n_repeats</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="punctuation">,</span>
            <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="identifier">n_splits</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">BaseShuffleSplit</span><span class="grouping">(</span><span class="identifier">metaclass</span><span class="arithmetic-assignment">=</span><span class="identifier">ABCMeta</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Base class for ShuffleSplit and StratifiedShuffleSplit"""</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="int-literal">10</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">test_size</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">train_size</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_splits</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">test_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">test_size</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">train_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">train_size</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_default_test_size</span> <span class="arithmetic-assignment">=</span> <span class="float-literal">0.1</span>

    <span class="keyword">def</span> <span class="identifier">split</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generate indices to split data into training and test set.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples
            and n_features is the number of features.

        y : array-like of shape (n_samples,)
            The target variable for supervised learning problems.

        groups : array-like of shape (n_samples,), default=None
            Group labels for the samples used while splitting the dataset into
            train/test set.

        Yields
        ------
        train : ndarray
            The training set indices for that split.

        test : ndarray
            The testing set indices for that split.

        Notes
        -----
        Randomized CV splitters may return different results for each call of
        split. You can make the results identical by setting `random_state`
        to an integer.
        """</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">indexable</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter_indices</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">yield</span> <span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span>

    <span class="punctuation">@</span><span class="identifier">abstractmethod</span>
    <span class="keyword">def</span> <span class="identifier">_iter_indices</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generate (train, test) indices"""</span>

    <span class="keyword">def</span> <span class="identifier">get_n_splits</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Returns the number of splitting iterations in the cross-validator

        Parameters
        ----------
        X : object
            Always ignored, exists for compatibility.

        y : object
            Always ignored, exists for compatibility.

        groups : object
            Always ignored, exists for compatibility.

        Returns
        -------
        n_splits : int
            Returns the number of splitting iterations in the cross-validator.
        """</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span>

    <span class="keyword">def</span> <span class="identifier">__repr__</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">_build_repr</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">ShuffleSplit</span><span class="grouping">(</span><span class="identifier">BaseShuffleSplit</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Random permutation cross-validator

    Yields indices to split data into training and test sets.

    Note: contrary to other cross-validation strategies, random splits
    do not guarantee that all folds will be different, although this is
    still very likely for sizeable datasets.

    Read more in the :ref:`User Guide &lt;ShuffleSplit&gt;`.

    Parameters
    ----------
    n_splits : int, default=10
        Number of re-shuffling & splitting iterations.

    test_size : float or int, default=None
        If float, should be between 0.0 and 1.0 and represent the proportion
        of the dataset to include in the test split. If int, represents the
        absolute number of test samples. If None, the value is set to the
        complement of the train size. If ``train_size`` is also None, it will
        be set to 0.1.

    train_size : float or int, default=None
        If float, should be between 0.0 and 1.0 and represent the
        proportion of the dataset to include in the train split. If
        int, represents the absolute number of train samples. If None,
        the value is automatically set to the complement of the test size.

    random_state : int, RandomState instance or None, default=None
        Controls the randomness of the training and testing indices produced.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import ShuffleSplit
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [3, 4], [5, 6]])
    &gt;&gt;&gt; y = np.array([1, 2, 1, 2, 1, 2])
    &gt;&gt;&gt; rs = ShuffleSplit(n_splits=5, test_size=.25, random_state=0)
    &gt;&gt;&gt; rs.get_n_splits(X)
    5
    &gt;&gt;&gt; print(rs)
    ShuffleSplit(n_splits=5, random_state=0, test_size=0.25, train_size=None)
    &gt;&gt;&gt; for train_index, test_index in rs.split(X):
    ...     print("TRAIN:", train_index, "TEST:", test_index)
    TRAIN: [1 3 0 4] TEST: [5 2]
    TRAIN: [4 0 2 5] TEST: [1 3]
    TRAIN: [1 2 4 0] TEST: [3 5]
    TRAIN: [3 4 1 0] TEST: [5 2]
    TRAIN: [3 5 1 0] TEST: [2 4]
    &gt;&gt;&gt; rs = ShuffleSplit(n_splits=5, train_size=0.5, test_size=.25,
    ...                   random_state=0)
    &gt;&gt;&gt; for train_index, test_index in rs.split(X):
    ...     print("TRAIN:", train_index, "TEST:", test_index)
    TRAIN: [1 3 0] TEST: [5 2]
    TRAIN: [4 0 2] TEST: [1 3]
    TRAIN: [1 2 4] TEST: [3 5]
    TRAIN: [3 4 1] TEST: [5 2]
    TRAIN: [3 5 1] TEST: [2 4]
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="int-literal">10</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">test_size</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">train_size</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="identifier">n_splits</span><span class="punctuation">,</span>
            <span class="identifier">test_size</span><span class="arithmetic-assignment">=</span><span class="identifier">test_size</span><span class="punctuation">,</span>
            <span class="identifier">train_size</span><span class="arithmetic-assignment">=</span><span class="identifier">train_size</span><span class="punctuation">,</span>
            <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_default_test_size</span> <span class="arithmetic-assignment">=</span> <span class="float-literal">0.1</span>

    <span class="keyword">def</span> <span class="identifier">_iter_indices</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">n_train</span><span class="punctuation">,</span> <span class="identifier">n_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_validate_shuffle_split</span><span class="grouping">(</span>
            <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">test_size</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">train_size</span><span class="punctuation">,</span>
            <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">z</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_default_test_size</span><span class="grouping">)</span>

        <span class="identifier">rng</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># random partition</span>
            <span class="identifier">permutation</span> <span class="arithmetic-assignment">=</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">permutation</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="grouping">)</span>
            <span class="identifier">ind_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">permutation</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_test</span><span class="grouping">]</span>
            <span class="identifier">ind_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">permutation</span><span class="grouping">[</span><span class="identifier">n_test</span><span class="punctuation">:</span><span class="grouping">(</span><span class="identifier">n_test</span> <span class="arithmetic-operator">+</span> <span class="identifier">n_train</span><span class="grouping">)</span><span class="grouping">]</span>
            <span class="keyword">yield</span> <span class="identifier">ind_train</span><span class="punctuation">,</span> <span class="identifier">ind_test</span>


<span class="keyword">class</span> <span class="identifier">GroupShuffleSplit</span><span class="grouping">(</span><span class="identifier">ShuffleSplit</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">'''Shuffle-Group(s)-Out cross-validation iterator

    Provides randomized train/test indices to split data according to a
    third-party provided group. This group information can be used to encode
    arbitrary domain specific stratifications of the samples as integers.

    For instance the groups could be the year of collection of the samples
    and thus allow for cross-validation against time-based splits.

    The difference between LeavePGroupsOut and GroupShuffleSplit is that
    the former generates splits using all subsets of size ``p`` unique groups,
    whereas GroupShuffleSplit generates a user-determined number of random
    test splits, each with a user-determined fraction of unique groups.

    For example, a less computationally intensive alternative to
    ``LeavePGroupsOut(p=10)`` would be
    ``GroupShuffleSplit(test_size=10, n_splits=100)``.

    Note: The parameters ``test_size`` and ``train_size`` refer to groups, and
    not to samples, as in ShuffleSplit.

    Read more in the :ref:`User Guide &lt;group_shuffle_split&gt;`.

    Parameters
    ----------
    n_splits : int, default=5
        Number of re-shuffling & splitting iterations.

    test_size : float, int, default=0.2
        If float, should be between 0.0 and 1.0 and represent the proportion
        of groups to include in the test split (rounded up). If int,
        represents the absolute number of test groups. If None, the value is
        set to the complement of the train size.
        The default will change in version 0.21. It will remain 0.2 only
        if ``train_size`` is unspecified, otherwise it will complement
        the specified ``train_size``.

    train_size : float or int, default=None
        If float, should be between 0.0 and 1.0 and represent the
        proportion of the groups to include in the train split. If
        int, represents the absolute number of train groups. If None,
        the value is automatically set to the complement of the test size.

    random_state : int, RandomState instance or None, default=None
        Controls the randomness of the training and testing indices produced.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import GroupShuffleSplit
    &gt;&gt;&gt; X = np.ones(shape=(8, 2))
    &gt;&gt;&gt; y = np.ones(shape=(8, 1))
    &gt;&gt;&gt; groups = np.array([1, 1, 2, 2, 2, 3, 3, 3])
    &gt;&gt;&gt; print(groups.shape)
    (8,)
    &gt;&gt;&gt; gss = GroupShuffleSplit(n_splits=2, train_size=.7, random_state=42)
    &gt;&gt;&gt; gss.get_n_splits()
    2
    &gt;&gt;&gt; for train_idx, test_idx in gss.split(X, y, groups):
    ...     print("TRAIN:", train_idx, "TEST:", test_idx)
    TRAIN: [2 3 4 5 6 7] TEST: [0 1]
    TRAIN: [0 1 5 6 7] TEST: [2 3 4]
    '''</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="int-literal">5</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">test_size</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">train_size</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="identifier">n_splits</span><span class="punctuation">,</span>
            <span class="identifier">test_size</span><span class="arithmetic-assignment">=</span><span class="identifier">test_size</span><span class="punctuation">,</span>
            <span class="identifier">train_size</span><span class="arithmetic-assignment">=</span><span class="identifier">train_size</span><span class="punctuation">,</span>
            <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_default_test_size</span> <span class="arithmetic-assignment">=</span> <span class="float-literal">0.2</span>

    <span class="keyword">def</span> <span class="identifier">_iter_indices</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">groups</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"The 'groups' parameter should not be None."</span><span class="grouping">)</span>
        <span class="identifier">groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">groups</span><span class="punctuation">,</span> <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span>
        <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="punctuation">,</span> <span class="identifier">group_indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">groups</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">v</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">s</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">group_train</span><span class="punctuation">,</span> <span class="identifier">group_test</span> <span class="relational-operator">in</span> <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">_iter_indices</span><span class="grouping">(</span><span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># these are the indices of classes in the partition</span>
            <span class="comment"># invert them into data indices</span>

            <span class="identifier">train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">flatnonzero</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">in1d</span><span class="grouping">(</span><span class="identifier">group_indices</span><span class="punctuation">,</span> <span class="identifier">group_train</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">flatnonzero</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">in1d</span><span class="grouping">(</span><span class="identifier">group_indices</span><span class="punctuation">,</span> <span class="identifier">group_test</span><span class="grouping">)</span><span class="grouping">)</span>

            <span class="keyword">yield</span> <span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span>

    <span class="keyword">def</span> <span class="identifier">split</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generate indices to split data into training and test set.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples
            and n_features is the number of features.

        y : array-like of shape (n_samples,), default=None
            The target variable for supervised learning problems.

        groups : array-like of shape (n_samples,)
            Group labels for the samples used while splitting the dataset into
            train/test set.

        Yields
        ------
        train : ndarray
            The training set indices for that split.

        test : ndarray
            The testing set indices for that split.

        Notes
        -----
        Randomized CV splitters may return different results for each call of
        split. You can make the results identical by setting `random_state`
        to an integer.
        """</span>
        <span class="keyword">return</span> <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">StratifiedShuffleSplit</span><span class="grouping">(</span><span class="identifier">BaseShuffleSplit</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Stratified ShuffleSplit cross-validator

    Provides train/test indices to split data in train/test sets.

    This cross-validation object is a merge of StratifiedKFold and
    ShuffleSplit, which returns stratified randomized folds. The folds
    are made by preserving the percentage of samples for each class.

    Note: like the ShuffleSplit strategy, stratified random splits
    do not guarantee that all folds will be different, although this is
    still very likely for sizeable datasets.

    Read more in the :ref:`User Guide &lt;stratified_shuffle_split&gt;`.

    Parameters
    ----------
    n_splits : int, default=10
        Number of re-shuffling & splitting iterations.

    test_size : float or int, default=None
        If float, should be between 0.0 and 1.0 and represent the proportion
        of the dataset to include in the test split. If int, represents the
        absolute number of test samples. If None, the value is set to the
        complement of the train size. If ``train_size`` is also None, it will
        be set to 0.1.

    train_size : float or int, default=None
        If float, should be between 0.0 and 1.0 and represent the
        proportion of the dataset to include in the train split. If
        int, represents the absolute number of train samples. If None,
        the value is automatically set to the complement of the test size.

    random_state : int, RandomState instance or None, default=None
        Controls the randomness of the training and testing indices produced.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import StratifiedShuffleSplit
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])
    &gt;&gt;&gt; y = np.array([0, 0, 0, 1, 1, 1])
    &gt;&gt;&gt; sss = StratifiedShuffleSplit(n_splits=5, test_size=0.5, random_state=0)
    &gt;&gt;&gt; sss.get_n_splits(X, y)
    5
    &gt;&gt;&gt; print(sss)
    StratifiedShuffleSplit(n_splits=5, random_state=0, ...)
    &gt;&gt;&gt; for train_index, test_index in sss.split(X, y):
    ...     print("TRAIN:", train_index, "TEST:", test_index)
    ...     X_train, X_test = X[train_index], X[test_index]
    ...     y_train, y_test = y[train_index], y[test_index]
    TRAIN: [5 2 3] TEST: [4 1 0]
    TRAIN: [5 1 4] TEST: [0 2 3]
    TRAIN: [5 0 2] TEST: [4 3 1]
    TRAIN: [4 1 0] TEST: [2 3 5]
    TRAIN: [0 5 1] TEST: [3 4 2]
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="int-literal">10</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">test_size</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">train_size</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">n_splits</span><span class="arithmetic-assignment">=</span><span class="identifier">n_splits</span><span class="punctuation">,</span>
            <span class="identifier">test_size</span><span class="arithmetic-assignment">=</span><span class="identifier">test_size</span><span class="punctuation">,</span>
            <span class="identifier">train_size</span><span class="arithmetic-assignment">=</span><span class="identifier">train_size</span><span class="punctuation">,</span>
            <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_default_test_size</span> <span class="arithmetic-assignment">=</span> <span class="float-literal">0.1</span>

    <span class="keyword">def</span> <span class="identifier">_iter_indices</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span>
        <span class="identifier">n_train</span><span class="punctuation">,</span> <span class="identifier">n_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_validate_shuffle_split</span><span class="grouping">(</span>
            <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">test_size</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">train_size</span><span class="punctuation">,</span>
            <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">z</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_default_test_size</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">2</span><span class="punctuation">:</span>
            <span class="comment"># for multi-label y, map each distinct row to a string repr</span>
            <span class="comment"># using join because str(row) uses an ellipsis if len(row) &gt; 1000</span>
            <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span><span class="string-literal">' '.join(row.astype('str'</span><span class="grouping">)</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">row</span> <span class="relational-operator">in</span> <span class="identifier">y</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="punctuation">,</span> <span class="identifier">y_indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">v</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">s</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">n_classes</span> <span class="arithmetic-assignment">=</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

        <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">u</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">s</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">bincount</span><span class="grouping">(</span><span class="identifier">y_indices</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">min</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">u</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">s</span><span class="grouping">)</span> <span class="relational-operator">&lt;</span> <span class="int-literal">2</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"The least populated class in y has only 1"</span>
                             <span class="string-literal">" member, which is too few. The minimum"</span>
                             <span class="string-literal">" number of groups for any class cannot"</span>
                             <span class="string-literal">" be less than 2."</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">n_train</span> <span class="relational-operator">&lt;</span> <span class="identifier">n_classes</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'The train_size = %d should be greater or '</span>
                             <span class="string-literal">'equal to the number of classes = %d'</span> <span class="arithmetic-operator">%</span>
                             <span class="grouping">(</span><span class="identifier">n_train</span><span class="punctuation">,</span> <span class="identifier">n_classes</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">n_test</span> <span class="relational-operator">&lt;</span> <span class="identifier">n_classes</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'The test_size = %d should be greater or '</span>
                             <span class="string-literal">'equal to the number of classes = %d'</span> <span class="arithmetic-operator">%</span>
                             <span class="grouping">(</span><span class="identifier">n_test</span><span class="punctuation">,</span> <span class="identifier">n_classes</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="comment"># Find the sorted list of instances for each class:</span>
        <span class="comment"># (np.unique above performs a sort, so code is O(n logn) already)</span>
        <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">d</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">s</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argsort</span><span class="grouping">(</span><span class="identifier">y_indices</span><span class="punctuation">,</span> <span class="identifier">kind</span><span class="arithmetic-assignment">=</span><span class="string-literal">'mergesort'</span><span class="grouping">)</span><span class="punctuation">,</span>
                                 <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">cumsum</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">u</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">s</span><span class="grouping">)</span><span class="grouping">[</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="identifier">rng</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span>

        <span class="keyword">for</span> <span class="identifier">_</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># if there are ties in the class-counts, we want</span>
            <span class="comment"># to make sure to break them anew in each iteration</span>
            <span class="identifier">n_i</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_approximate_mode</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">u</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">s</span><span class="punctuation">,</span> <span class="identifier">n_train</span><span class="punctuation">,</span> <span class="identifier">rng</span><span class="grouping">)</span>
            <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">u</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">g</span> <span class="arithmetic-assignment">=</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">u</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">s</span> <span class="arithmetic-operator">-</span> <span class="identifier">n_i</span>
            <span class="identifier">t_i</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_approximate_mode</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">u</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">g</span><span class="punctuation">,</span> <span class="identifier">n_test</span><span class="punctuation">,</span> <span class="identifier">rng</span><span class="grouping">)</span>

            <span class="identifier">train</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
            <span class="identifier">test</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>

            <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_classes</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">permutation</span> <span class="arithmetic-assignment">=</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">permutation</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">u</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">s</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">)</span>
                <span class="identifier">perm_indices_class_i</span> <span class="arithmetic-assignment">=</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">d</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">take</span><span class="grouping">(</span><span class="identifier">permutation</span><span class="punctuation">,</span>
                                                             <span class="identifier">mode</span><span class="arithmetic-assignment">=</span><span class="string-literal">'clip'</span><span class="grouping">)</span>

                <span class="identifier">train</span><span class="punctuation">.</span><span class="identifier">extend</span><span class="grouping">(</span><span class="identifier">perm_indices_class_i</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_i</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">]</span><span class="grouping">)</span>
                <span class="identifier">test</span><span class="punctuation">.</span><span class="identifier">extend</span><span class="grouping">(</span><span class="identifier">perm_indices_class_i</span><span class="grouping">[</span><span class="identifier">n_i</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">:</span><span class="identifier">n_i</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-operator">+</span> <span class="identifier">t_i</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">]</span><span class="grouping">)</span>

            <span class="identifier">train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">permutation</span><span class="grouping">(</span><span class="identifier">train</span><span class="grouping">)</span>
            <span class="identifier">test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">permutation</span><span class="grouping">(</span><span class="identifier">test</span><span class="grouping">)</span>

            <span class="keyword">yield</span> <span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span>

    <span class="keyword">def</span> <span class="identifier">split</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generate indices to split data into training and test set.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples
            and n_features is the number of features.

            Note that providing ``y`` is sufficient to generate the splits and
            hence ``np.zeros(n_samples)`` may be used as a placeholder for
            ``X`` instead of actual training data.

        y : array-like of shape (n_samples,) or (n_samples, n_labels)
            The target variable for supervised learning problems.
            Stratification is done based on the y labels.

        groups : object
            Always ignored, exists for compatibility.

        Yields
        ------
        train : ndarray
            The training set indices for that split.

        test : ndarray
            The testing set indices for that split.

        Notes
        -----
        Randomized CV splitters may return different results for each call of
        split. You can make the results identical by setting `random_state`
        to an integer.
        """</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_validate_shuffle_split</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">test_size</span><span class="punctuation">,</span> <span class="identifier">train_size</span><span class="punctuation">,</span>
                            <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">z</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""
    Validation helper to check if the test/test sizes are meaningful wrt to the
    size of the data (n_samples)
    """</span>
    <span class="keyword">if</span> <span class="identifier">test_size</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">train_size</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">test_size</span> <span class="arithmetic-assignment">=</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">z</span><span class="invalid">e</span>

    <span class="identifier">test_size_type</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">test_size</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">.</span><span class="identifier">kind</span>
    <span class="identifier">train_size_type</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">train_size</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">.</span><span class="identifier">kind</span>

    <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">test_size_type</span> <span class="relational-operator">==</span> <span class="string-literal">'i'</span> <span class="logical-operator">and</span> <span class="grouping">(</span><span class="identifier">test_size</span> <span class="relational-operator">&gt;=</span> <span class="identifier">n_samples</span> <span class="logical-operator">or</span> <span class="identifier">test_size</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="grouping">)</span>
       <span class="logical-operator">or</span> <span class="identifier">test_size_type</span> <span class="relational-operator">==</span> <span class="string-literal">'f'</span> <span class="logical-operator">and</span> <span class="grouping">(</span><span class="identifier">test_size</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span> <span class="logical-operator">or</span> <span class="identifier">test_size</span> <span class="relational-operator">&gt;=</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'test_size={0} should be either positive and smaller'</span>
                         <span class="string-literal">' than the number of samples {1} or a float in the '</span>
                         <span class="string-literal">'(0, 1) range'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">test_size</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">train_size_type</span> <span class="relational-operator">==</span> <span class="string-literal">'i'</span> <span class="logical-operator">and</span> <span class="grouping">(</span><span class="identifier">train_size</span> <span class="relational-operator">&gt;=</span> <span class="identifier">n_samples</span> <span class="logical-operator">or</span> <span class="identifier">train_size</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="grouping">)</span>
       <span class="logical-operator">or</span> <span class="identifier">train_size_type</span> <span class="relational-operator">==</span> <span class="string-literal">'f'</span> <span class="logical-operator">and</span> <span class="grouping">(</span><span class="identifier">train_size</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span> <span class="logical-operator">or</span> <span class="identifier">train_size</span> <span class="relational-operator">&gt;=</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'train_size={0} should be either positive and smaller'</span>
                         <span class="string-literal">' than the number of samples {1} or a float in the '</span>
                         <span class="string-literal">'(0, 1) range'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">train_size</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">train_size</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">train_size_type</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="string-literal">'i', 'f'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Invalid value for train_size: {}"</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">train_size</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">test_size</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">test_size_type</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="string-literal">'i', 'f'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Invalid value for test_size: {}"</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">test_size</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">train_size_type</span> <span class="relational-operator">==</span> <span class="string-literal">'f' and test_size_type == 'f'</span> <span class="logical-operator">and</span>
            <span class="identifier">train_size</span> <span class="arithmetic-operator">+</span> <span class="identifier">test_size</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
            <span class="string-literal">'The sum of test_size and train_size = {}, should be in the (0, 1)'</span>
            <span class="string-literal">' range. Reduce test_size and/or train_size.'</span>
            <span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">train_size</span> <span class="arithmetic-operator">+</span> <span class="identifier">test_size</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">test_size_type</span> <span class="relational-operator">==</span> <span class="string-literal">'f'</span><span class="punctuation">:</span>
        <span class="identifier">n_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">ceil</span><span class="grouping">(</span><span class="identifier">test_size</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_samples</span><span class="grouping">)</span>
    <span class="keyword">elif</span> <span class="identifier">test_size_type</span> <span class="relational-operator">==</span> <span class="string-literal">'i'</span><span class="punctuation">:</span>
        <span class="identifier">n_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">float</span><span class="grouping">(</span><span class="identifier">test_size</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">train_size_type</span> <span class="relational-operator">==</span> <span class="string-literal">'f'</span><span class="punctuation">:</span>
        <span class="identifier">n_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">floor</span><span class="grouping">(</span><span class="identifier">train_size</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_samples</span><span class="grouping">)</span>
    <span class="keyword">elif</span> <span class="identifier">train_size_type</span> <span class="relational-operator">==</span> <span class="string-literal">'i'</span><span class="punctuation">:</span>
        <span class="identifier">n_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">float</span><span class="grouping">(</span><span class="identifier">train_size</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">train_size</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">n_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_samples</span> <span class="arithmetic-operator">-</span> <span class="identifier">n_test</span>
    <span class="keyword">elif</span> <span class="identifier">test_size</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">n_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_samples</span> <span class="arithmetic-operator">-</span> <span class="identifier">n_train</span>

    <span class="keyword">if</span> <span class="identifier">n_train</span> <span class="arithmetic-operator">+</span> <span class="identifier">n_test</span> <span class="relational-operator">&gt;</span> <span class="identifier">n_samples</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'The sum of train_size and test_size = %d, '</span>
                         <span class="string-literal">'should be smaller than the number of '</span>
                         <span class="string-literal">'samples %d. Reduce test_size and/or '</span>
                         <span class="string-literal">'train_size.'</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">n_train</span> <span class="arithmetic-operator">+</span> <span class="identifier">n_test</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="identifier">n_train</span><span class="punctuation">,</span> <span class="identifier">n_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">int</span><span class="grouping">(</span><span class="identifier">n_train</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">int</span><span class="grouping">(</span><span class="identifier">n_test</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">n_train</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
            <span class="string-literal">'With n_samples={}, test_size={} and train_size={}, the '</span>
            <span class="string-literal">'resulting train set will be empty. Adjust any of the '</span>
            <span class="string-literal">'aforementioned parameters.'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">test_size</span><span class="punctuation">,</span>
                                                <span class="identifier">train_size</span><span class="grouping">)</span>
        <span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">n_train</span><span class="punctuation">,</span> <span class="identifier">n_test</span>


<span class="keyword">class</span> <span class="identifier">PredefinedSplit</span><span class="grouping">(</span><span class="identifier">BaseCrossValidator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Predefined split cross-validator

    Provides train/test indices to split data into train/test sets using a
    predefined scheme specified by the user with the ``test_fold`` parameter.

    Read more in the :ref:`User Guide &lt;predefined_split&gt;`.

    .. versionadded:: 0.16

    Parameters
    ----------
    test_fold : array-like of shape (n_samples,)
        The entry ``test_fold[i]`` represents the index of the test set that
        sample ``i`` belongs to. It is possible to exclude sample ``i`` from
        any test set (i.e. include sample ``i`` in every training set) by
        setting ``test_fold[i]`` equal to -1.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import PredefinedSplit
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])
    &gt;&gt;&gt; y = np.array([0, 0, 1, 1])
    &gt;&gt;&gt; test_fold = [0, 1, -1, 1]
    &gt;&gt;&gt; ps = PredefinedSplit(test_fold)
    &gt;&gt;&gt; ps.get_n_splits()
    2
    &gt;&gt;&gt; print(ps)
    PredefinedSplit(test_fold=array([ 0,  1, -1,  1]))
    &gt;&gt;&gt; for train_index, test_index in ps.split():
    ...     print("TRAIN:", train_index, "TEST:", test_index)
    ...     X_train, X_test = X[train_index], X[test_index]
    ...     y_train, y_test = y[train_index], y[test_index]
    TRAIN: [1 2 3] TEST: [0]
    TRAIN: [0 2] TEST: [1 3]
    """</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">test_fold</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">test_fold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="identifier">test_fold</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">int</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">test_fold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">test_fold</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">unique_folds</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">test_fold</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">unique_folds</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">unique_folds</span><span class="grouping">[</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">unique_folds</span> <span class="relational-operator">!=</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">split</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generate indices to split data into training and test set.

        Parameters
        ----------
        X : object
            Always ignored, exists for compatibility.

        y : object
            Always ignored, exists for compatibility.

        groups : object
            Always ignored, exists for compatibility.

        Yields
        ------
        train : ndarray
            The training set indices for that split.

        test : ndarray
            The testing set indices for that split.
        """</span>
        <span class="identifier">ind</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">test_fold</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">test_index</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter_test_masks</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">train_index</span> <span class="arithmetic-assignment">=</span> <span class="identifier">ind</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">logical_not</span><span class="grouping">(</span><span class="identifier">test_index</span><span class="grouping">)</span><span class="grouping">]</span>
            <span class="identifier">test_index</span> <span class="arithmetic-assignment">=</span> <span class="identifier">ind</span><span class="grouping">[</span><span class="identifier">test_index</span><span class="grouping">]</span>
            <span class="keyword">yield</span> <span class="identifier">train_index</span><span class="punctuation">,</span> <span class="identifier">test_index</span>

    <span class="keyword">def</span> <span class="identifier">_iter_test_masks</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generates boolean masks corresponding to test sets."""</span>
        <span class="keyword">for</span> <span class="identifier">f</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">unique_folds</span><span class="punctuation">:</span>
            <span class="identifier">test_index</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">where</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">test_fold</span> <span class="relational-operator">==</span> <span class="identifier">f</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
            <span class="identifier">test_mask</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">test_fold</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">bool</span><span class="grouping">)</span>
            <span class="identifier">test_mask</span><span class="grouping">[</span><span class="identifier">test_index</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>
            <span class="keyword">yield</span> <span class="identifier">test_mask</span>

    <span class="keyword">def</span> <span class="identifier">get_n_splits</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Returns the number of splitting iterations in the cross-validator

        Parameters
        ----------
        X : object
            Always ignored, exists for compatibility.

        y : object
            Always ignored, exists for compatibility.

        groups : object
            Always ignored, exists for compatibility.

        Returns
        -------
        n_splits : int
            Returns the number of splitting iterations in the cross-validator.
        """</span>
        <span class="keyword">return</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">unique_folds</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">_CVIterableWrapper</span><span class="grouping">(</span><span class="identifier">BaseCrossValidator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Wrapper class for old style cv objects and iterables."""</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">list</span><span class="grouping">(</span><span class="identifier">cv</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">get_n_splits</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Returns the number of splitting iterations in the cross-validator

        Parameters
        ----------
        X : object
            Always ignored, exists for compatibility.

        y : object
            Always ignored, exists for compatibility.

        groups : object
            Always ignored, exists for compatibility.

        Returns
        -------
        n_splits : int
            Returns the number of splitting iterations in the cross-validator.
        """</span>
        <span class="keyword">return</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">split</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Generate indices to split data into training and test set.

        Parameters
        ----------
        X : object
            Always ignored, exists for compatibility.

        y : object
            Always ignored, exists for compatibility.

        groups : object
            Always ignored, exists for compatibility.

        Yields
        ------
        train : ndarray
            The training set indices for that split.

        test : ndarray
            The testing set indices for that split.
        """</span>
        <span class="keyword">for</span> <span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span><span class="punctuation">:</span>
            <span class="keyword">yield</span> <span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span>


<span class="keyword">def</span> <span class="identifier">check_cv</span><span class="grouping">(</span><span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="int-literal">5</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Input checker utility for building a cross-validator

    Parameters
    ----------
    cv : int, cross-validation generator or an iterable, default=None
        Determines the cross-validation splitting strategy.
        Possible inputs for cv are:
        - None, to use the default 5-fold cross validation,
        - integer, to specify the number of folds.
        - :term:`CV splitter`,
        - An iterable yielding (train, test) splits as arrays of indices.

        For integer/None inputs, if classifier is True and ``y`` is either
        binary or multiclass, :class:`StratifiedKFold` is used. In all other
        cases, :class:`KFold` is used.

        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
        cross-validation strategies that can be used here.

        .. versionchanged:: 0.22
            ``cv`` default value changed from 3-fold to 5-fold.

    y : array-like, default=None
        The target variable for supervised learning problems.

    classifier : bool, default=False
        Whether the task is a classification task, in which case
        stratified KFold will be used.

    Returns
    -------
    checked_cv : a cross-validator instance.
        The return value is a cross-validator which generates the train/test
        splits via the ``split`` method.
    """</span>
    <span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">5</span> <span class="keyword">if</span> <span class="identifier">cv</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="keyword">else</span> <span class="identifier">cv</span>
    <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="identifier">numbers</span><span class="punctuation">.</span><span class="identifier">Integral</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">e</span><span class="invalid">r</span> <span class="logical-operator">and</span> <span class="grouping">(</span><span class="identifier">y</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="grouping">)</span> <span class="logical-operator">and</span>
                <span class="grouping">(</span><span class="identifier">type_of_target</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="string-literal">'binary', 'multiclass'</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">StratifiedKFold</span><span class="grouping">(</span><span class="identifier">cv</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">KFold</span><span class="grouping">(</span><span class="identifier">cv</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="string-literal">'split'</span><span class="grouping">)</span> <span class="logical-operator">or</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="identifier">Iterable</span><span class="grouping">)</span> <span class="logical-operator">or</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Expected cv as an integer, cross-validation "</span>
                             <span class="string-literal">"object (from sklearn.model_selection) "</span>
                             <span class="string-literal">"or an iterable. Got %s."</span> <span class="arithmetic-operator">%</span> <span class="identifier">cv</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">_CVIterableWrapper</span><span class="grouping">(</span><span class="identifier">cv</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">cv</span>  <span class="comment"># New style cv objects are passed without any modification</span>


<span class="keyword">def</span> <span class="identifier">train_test_split</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">arrays</span><span class="punctuation">,</span>
                     <span class="identifier">test_size</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                     <span class="identifier">train_size</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                     <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                     <span class="identifier">shuffle</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                     <span class="identifier">stratify</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Split arrays or matrices into random train and test subsets

    Quick utility that wraps input validation and
    ``next(ShuffleSplit().split(X, y))`` and application to input data
    into a single call for splitting (and optionally subsampling) data in a
    oneliner.

    Read more in the :ref:`User Guide &lt;cross_validation&gt;`.

    Parameters
    ----------
    *arrays : sequence of indexables with same length / shape[0]
        Allowed inputs are lists, numpy arrays, scipy-sparse
        matrices or pandas dataframes.

    test_size : float or int, default=None
        If float, should be between 0.0 and 1.0 and represent the proportion
        of the dataset to include in the test split. If int, represents the
        absolute number of test samples. If None, the value is set to the
        complement of the train size. If ``train_size`` is also None, it will
        be set to 0.25.

    train_size : float or int, default=None
        If float, should be between 0.0 and 1.0 and represent the
        proportion of the dataset to include in the train split. If
        int, represents the absolute number of train samples. If None,
        the value is automatically set to the complement of the test size.

    random_state : int, RandomState instance or None, default=None
        Controls the shuffling applied to the data before applying the split.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.


    shuffle : bool, default=True
        Whether or not to shuffle the data before splitting. If shuffle=False
        then stratify must be None.

    stratify : array-like, default=None
        If not None, data is split in a stratified fashion, using this as
        the class labels.
        Read more in the :ref:`User Guide &lt;stratification&gt;`.

    Returns
    -------
    splitting : list, length=2 * len(arrays)
        List containing train-test split of inputs.

        .. versionadded:: 0.16
            If the input is sparse, the output will be a
            ``scipy.sparse.csr_matrix``. Else, output type is the same as the
            input type.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.model_selection import train_test_split
    &gt;&gt;&gt; X, y = np.arange(10).reshape((5, 2)), range(5)
    &gt;&gt;&gt; X
    array([[0, 1],
           [2, 3],
           [4, 5],
           [6, 7],
           [8, 9]])
    &gt;&gt;&gt; list(y)
    [0, 1, 2, 3, 4]

    &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(
    ...     X, y, test_size=0.33, random_state=42)
    ...
    &gt;&gt;&gt; X_train
    array([[4, 5],
           [0, 1],
           [6, 7]])
    &gt;&gt;&gt; y_train
    [2, 0, 3]
    &gt;&gt;&gt; X_test
    array([[2, 3],
           [8, 9]])
    &gt;&gt;&gt; y_test
    [1, 4]

    &gt;&gt;&gt; train_test_split(y, shuffle=False)
    [[0, 1, 2], [3, 4]]

    """</span>
    <span class="identifier">n_arrays</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">arrays</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">n_arrays</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"At least one array required as input"</span><span class="grouping">)</span>

    <span class="identifier">arrays</span> <span class="arithmetic-assignment">=</span> <span class="identifier">indexable</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">arrays</span><span class="grouping">)</span>

    <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">arrays</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>
    <span class="identifier">n_train</span><span class="punctuation">,</span> <span class="identifier">n_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_validate_shuffle_split</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">test_size</span><span class="punctuation">,</span> <span class="identifier">train_size</span><span class="punctuation">,</span>
                                              <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">z</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.25</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">shuffle</span> <span class="relational-operator">is</span> <span class="bool-literal">False</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">stratify</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">"Stratified train/test split is not implemented for "</span>
                <span class="string-literal">"shuffle=False"</span><span class="grouping">)</span>

        <span class="identifier">train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">n_train</span><span class="grouping">)</span>
        <span class="identifier">test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">n_train</span><span class="punctuation">,</span> <span class="identifier">n_train</span> <span class="arithmetic-operator">+</span> <span class="identifier">n_test</span><span class="grouping">)</span>

    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">stratify</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">CVClass</span> <span class="arithmetic-assignment">=</span> <span class="identifier">StratifiedShuffleSplit</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">CVClass</span> <span class="arithmetic-assignment">=</span> <span class="identifier">ShuffleSplit</span>

        <span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">CVClass</span><span class="grouping">(</span><span class="identifier">test_size</span><span class="arithmetic-assignment">=</span><span class="identifier">n_test</span><span class="punctuation">,</span>
                     <span class="identifier">train_size</span><span class="arithmetic-assignment">=</span><span class="identifier">n_train</span><span class="punctuation">,</span>
                     <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>

        <span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">next</span><span class="grouping">(</span><span class="identifier">cv</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="identifier">arrays</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="identifier">stratify</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">list</span><span class="grouping">(</span><span class="identifier">chain</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">r</span><span class="invalid">o</span><span class="invalid">m</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">b</span><span class="invalid">l</span><span class="invalid">e</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">_safe_indexing</span><span class="grouping">(</span><span class="identifier">a</span><span class="punctuation">,</span> <span class="identifier">train</span><span class="grouping">)</span><span class="punctuation">,</span>
                                     <span class="identifier">_safe_indexing</span><span class="grouping">(</span><span class="identifier">a</span><span class="punctuation">,</span> <span class="identifier">test</span><span class="grouping">)</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">a</span> <span class="relational-operator">in</span> <span class="identifier">arrays</span><span class="grouping">)</span><span class="grouping">)</span>


<span class="comment"># Tell nose that train_test_split is not a test.</span>
<span class="comment"># (Needed for external libraries that may use nose.)</span>
<span class="comment"># Use setattr to avoid mypy errors when monkeypatching.</span>
<span class="identifier">setattr</span><span class="grouping">(</span><span class="identifier">train_test_split</span><span class="punctuation">,</span> <span class="string-literal">'__test__'</span><span class="punctuation">,</span> <span class="bool-literal">False</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_build_repr</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment"># XXX This is copied from BaseEstimator's get_params</span>
    <span class="identifier">cls</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__class__</span>
    <span class="identifier">init</span> <span class="arithmetic-assignment">=</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">cls</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="punctuation">,</span> <span class="string-literal">'deprecated_original'</span><span class="punctuation">,</span> <span class="identifier">cls</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">)</span>
    <span class="comment"># Ignore varargs, kw and default values and pop self</span>
    <span class="identifier">init_signature</span> <span class="arithmetic-assignment">=</span> <span class="identifier">signature</span><span class="grouping">(</span><span class="identifier">init</span><span class="grouping">)</span>
    <span class="comment"># Consider the constructor parameters excluding 'self'</span>
    <span class="keyword">if</span> <span class="identifier">init</span> <span class="relational-operator">is</span> <span class="identifier">object</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="punctuation">:</span>
        <span class="identifier">args</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">args</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sorted</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">p</span><span class="punctuation">.</span><span class="identifier">name</span> <span class="keyword">for</span> <span class="identifier">p</span> <span class="relational-operator">in</span> <span class="identifier">init_signature</span><span class="punctuation">.</span><span class="identifier">parameters</span><span class="punctuation">.</span><span class="identifier">values</span><span class="grouping">(</span><span class="grouping">)</span>
                       <span class="keyword">if</span> <span class="identifier">p</span><span class="punctuation">.</span><span class="identifier">name</span> <span class="relational-operator">!=</span> <span class="string-literal">'self'</span> <span class="logical-operator">and</span> <span class="identifier">p</span><span class="punctuation">.</span><span class="identifier">kind</span> <span class="relational-operator">!=</span> <span class="identifier">p</span><span class="punctuation">.</span><span class="identifier">VAR_KEYWORD</span><span class="grouping">]</span><span class="grouping">)</span>
    <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">a</span><span class="invalid">m</span><span class="invalid">e</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__class__</span><span class="punctuation">.</span><span class="identifier">__name__</span>
    <span class="identifier">params</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dict</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="keyword">for</span> <span class="identifier">key</span> <span class="relational-operator">in</span> <span class="identifier">args</span><span class="punctuation">:</span>
        <span class="comment"># We need deprecation warnings to always be on in order to</span>
        <span class="comment"># catch deprecated param values.</span>
        <span class="comment"># This is set in utils/__init__.py but it gets overwritten</span>
        <span class="comment"># when running under python3 somehow.</span>
        <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">simplefilter</span><span class="grouping">(</span><span class="string-literal">"always"</span><span class="punctuation">,</span> <span class="identifier">FutureWarning</span><span class="grouping">)</span>
        <span class="keyword">try</span><span class="punctuation">:</span>
            <span class="keyword">with</span> <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">catch_warnings</span><span class="grouping">(</span><span class="identifier">record</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span> <span class="keyword">as</span> <span class="identifier">w</span><span class="punctuation">:</span>
                <span class="identifier">value</span> <span class="arithmetic-assignment">=</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">key</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">)</span>
                <span class="keyword">if</span> <span class="identifier">value</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">'cvargs'</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">value</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cvargs</span><span class="punctuation">.</span><span class="identifier">get</span><span class="grouping">(</span><span class="identifier">key</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">w</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">w</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">category</span> <span class="relational-operator">==</span> <span class="identifier">FutureWarning</span><span class="punctuation">:</span>
                <span class="comment"># if the parameter is deprecated, don't show it</span>
                <span class="keyword">continue</span>
        <span class="keyword">finally</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">filters</span><span class="punctuation">.</span><span class="identifier">pop</span><span class="grouping">(</span><span class="int-literal">0</span><span class="grouping">)</span>
        <span class="identifier">params</span><span class="grouping">[</span><span class="identifier">key</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">value</span>

    <span class="keyword">return</span> <span class="string-literal">'%s(%s)'</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">a</span><span class="invalid">m</span><span class="invalid">e</span><span class="punctuation">,</span> <span class="identifier">_pprint</span><span class="grouping">(</span><span class="identifier">params</span><span class="punctuation">,</span> <span class="identifier">offset</span><span class="arithmetic-assignment">=</span><span class="identifier">len</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">a</span><span class="invalid">m</span><span class="invalid">e</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_yields_constant_splits</span><span class="grouping">(</span><span class="identifier">cv</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment"># Return True if calling cv.split() always returns the same splits</span>
    <span class="comment"># We assume that if a cv doesn't have a shuffle parameter, it shuffles by</span>
    <span class="comment"># default (e.g. ShuffleSplit). If it actually doesn't shuffle (e.g.</span>
    <span class="comment"># LeaveOneOut), then it won't have a random_state parameter anyway, in</span>
    <span class="comment"># which case it will default to 0, leading to output=True</span>
    <span class="identifier">shuffle</span> <span class="arithmetic-assignment">=</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="string-literal">'shuffle'</span><span class="punctuation">,</span> <span class="bool-literal">True</span><span class="grouping">)</span>
    <span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="string-literal">'random_state'</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">random_state</span><span class="punctuation">,</span> <span class="identifier">numbers</span><span class="punctuation">.</span><span class="identifier">Integral</span><span class="grouping">)</span> <span class="logical-operator">or</span> <span class="logical-operator">not</span> <span class="identifier">shuffle</span>

    </pre>
  </body>
</html>