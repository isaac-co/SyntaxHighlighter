<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment"># Authors: Manoj Kumar &lt;manojkumarsivaraj334@gmail.com&gt;</span>
<span class="comment">#          Alexandre Gramfort &lt;alexandre.gramfort@telecom-paristech.fr&gt;</span>
<span class="comment">#          Joel Nothman &lt;joel.nothman@gmail.com&gt;</span>
<span class="comment"># License: BSD 3 clause</span>

<span class="keyword">import</span> <span class="identifier">warnings</span>
<span class="keyword">import</span> <span class="identifier">numbers</span>
<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">from</span> <span class="identifier">scipy</span> <span class="keyword">import</span> <span class="identifier">sparse</span>
<span class="keyword">from</span> <span class="identifier">math</span> <span class="keyword">import</span> <span class="identifier">sqrt</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">metrics</span> <span class="keyword">import</span> <span class="identifier">pairwise_distances_argmin</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">metrics</span><span class="punctuation">.</span><span class="identifier">pairwise</span> <span class="keyword">import</span> <span class="identifier">euclidean_distances</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">TransformerMixin</span><span class="punctuation">,</span> <span class="identifier">ClusterMixin</span><span class="punctuation">,</span> <span class="identifier">BaseEstimator</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">extmath</span> <span class="keyword">import</span> <span class="identifier">row_norms</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">deprecated</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_is_fitted</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="invalid">e</span><span class="invalid">x</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="invalid">i</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">s</span> <span class="keyword">import</span> <span class="identifier">ConvergenceWarning</span>
<span class="keyword">from</span> <span class="punctuation">.</span> <span class="keyword">import</span> <span class="identifier">AgglomerativeClustering</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">_config</span> <span class="keyword">import</span> <span class="identifier">config_context</span>


<span class="keyword">def</span> <span class="identifier">_iterate_sparse_X</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""This little hack returns a densified row when iterating over a sparse
    matrix, instead of constructing a sparse matrix for every row that is
    expensive.
    """</span>
    <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
    <span class="identifier">X_indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">indices</span>
    <span class="identifier">X_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">data</span>
    <span class="identifier">X_indptr</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">indptr</span>

    <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">row</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="identifier">startptr</span><span class="punctuation">,</span> <span class="identifier">endptr</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_indptr</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X_indptr</span><span class="grouping">[</span><span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span>
        <span class="identifier">nonzero_indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_indices</span><span class="grouping">[</span><span class="identifier">startptr</span><span class="punctuation">:</span><span class="identifier">endptr</span><span class="grouping">]</span>
        <span class="identifier">row</span><span class="grouping">[</span><span class="identifier">nonzero_indices</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_data</span><span class="grouping">[</span><span class="identifier">startptr</span><span class="punctuation">:</span><span class="identifier">endptr</span><span class="grouping">]</span>
        <span class="keyword">yield</span> <span class="identifier">row</span>


<span class="keyword">def</span> <span class="identifier">_split_node</span><span class="grouping">(</span><span class="identifier">node</span><span class="punctuation">,</span> <span class="identifier">threshold</span><span class="punctuation">,</span> <span class="identifier">branching_factor</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""The node has to be split if there is no place for a new subcluster
    in the node.
    1. Two empty nodes and two empty subclusters are initialized.
    2. The pair of distant subclusters are found.
    3. The properties of the empty subclusters and nodes are updated
       according to the nearest distance between the subclusters to the
       pair of distant subclusters.
    4. The two nodes are set as children to the two subclusters.
    """</span>
    <span class="identifier">new_subcluster1</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_CFSubcluster</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="identifier">new_subcluster2</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_CFSubcluster</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="identifier">new_node1</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_CFNode</span><span class="grouping">(</span>
        <span class="identifier">threshold</span><span class="arithmetic-assignment">=</span><span class="identifier">threshold</span><span class="punctuation">,</span> <span class="identifier">branching_factor</span><span class="arithmetic-assignment">=</span><span class="identifier">branching_factor</span><span class="punctuation">,</span>
        <span class="identifier">is_leaf</span><span class="arithmetic-assignment">=</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">is_leaf</span><span class="punctuation">,</span>
        <span class="identifier">n_features</span><span class="arithmetic-assignment">=</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">n_features</span><span class="grouping">)</span>
    <span class="identifier">new_node2</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_CFNode</span><span class="grouping">(</span>
        <span class="identifier">threshold</span><span class="arithmetic-assignment">=</span><span class="identifier">threshold</span><span class="punctuation">,</span> <span class="identifier">branching_factor</span><span class="arithmetic-assignment">=</span><span class="identifier">branching_factor</span><span class="punctuation">,</span>
        <span class="identifier">is_leaf</span><span class="arithmetic-assignment">=</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">is_leaf</span><span class="punctuation">,</span>
        <span class="identifier">n_features</span><span class="arithmetic-assignment">=</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">n_features</span><span class="grouping">)</span>
    <span class="identifier">new_subcluster1</span><span class="punctuation">.</span><span class="identifier">child_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_node1</span>
    <span class="identifier">new_subcluster2</span><span class="punctuation">.</span><span class="identifier">child_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_node2</span>

    <span class="keyword">if</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">is_leaf</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">prev_leaf_</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">prev_leaf_</span><span class="punctuation">.</span><span class="identifier">next_leaf_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_node1</span>
        <span class="identifier">new_node1</span><span class="punctuation">.</span><span class="identifier">prev_leaf_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">prev_leaf_</span>
        <span class="identifier">new_node1</span><span class="punctuation">.</span><span class="identifier">next_leaf_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_node2</span>
        <span class="identifier">new_node2</span><span class="punctuation">.</span><span class="identifier">prev_leaf_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_node1</span>
        <span class="identifier">new_node2</span><span class="punctuation">.</span><span class="identifier">next_leaf_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">next_leaf_</span>
        <span class="keyword">if</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">next_leaf_</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">next_leaf_</span><span class="punctuation">.</span><span class="identifier">prev_leaf_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_node2</span>

    <span class="identifier">dist</span> <span class="arithmetic-assignment">=</span> <span class="identifier">euclidean_distances</span><span class="grouping">(</span>
        <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">centroids_</span><span class="punctuation">,</span> <span class="identifier">Y_norm_squared</span><span class="arithmetic-assignment">=</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">squared_norm_</span><span class="punctuation">,</span> <span class="identifier">squared</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
    <span class="identifier">n_clusters</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dist</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

    <span class="identifier">farthest_idx</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unravel_index</span><span class="grouping">(</span>
        <span class="identifier">dist</span><span class="punctuation">.</span><span class="identifier">argmax</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="identifier">n_clusters</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="identifier">node1_dist</span><span class="punctuation">,</span> <span class="identifier">node2_dist</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dist</span><span class="grouping">[</span><span class="grouping">(</span><span class="identifier">farthest_idx</span><span class="punctuation">,</span><span class="grouping">)</span><span class="grouping">]</span>

    <span class="identifier">node1_closer</span> <span class="arithmetic-assignment">=</span> <span class="identifier">node1_dist</span> <span class="relational-operator">&lt;</span> <span class="identifier">node2_dist</span>
    <span class="keyword">for</span> <span class="identifier">idx</span><span class="punctuation">,</span> <span class="identifier">subcluster</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">subclusters_</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">node1_closer</span><span class="grouping">[</span><span class="identifier">idx</span><span class="grouping">]</span><span class="punctuation">:</span>
            <span class="identifier">new_node1</span><span class="punctuation">.</span><span class="identifier">append_subcluster</span><span class="grouping">(</span><span class="identifier">subcluster</span><span class="grouping">)</span>
            <span class="identifier">new_subcluster1</span><span class="punctuation">.</span><span class="identifier">update</span><span class="grouping">(</span><span class="identifier">subcluster</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">new_node2</span><span class="punctuation">.</span><span class="identifier">append_subcluster</span><span class="grouping">(</span><span class="identifier">subcluster</span><span class="grouping">)</span>
            <span class="identifier">new_subcluster2</span><span class="punctuation">.</span><span class="identifier">update</span><span class="grouping">(</span><span class="identifier">subcluster</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">new_subcluster1</span><span class="punctuation">,</span> <span class="identifier">new_subcluster2</span>


<span class="keyword">class</span> <span class="identifier">_CFNode</span><span class="punctuation">:</span>
    <span class="comment">"""Each node in a CFTree is called a CFNode.

    The CFNode can have a maximum of branching_factor
    number of CFSubclusters.

    Parameters
    ----------
    threshold : float
        Threshold needed for a new subcluster to enter a CFSubcluster.

    branching_factor : int
        Maximum number of CF subclusters in each node.

    is_leaf : bool
        We need to know if the CFNode is a leaf or not, in order to
        retrieve the final subclusters.

    n_features : int
        The number of features.

    Attributes
    ----------
    subclusters_ : list
        List of subclusters for a particular CFNode.

    prev_leaf_ : _CFNode
        Useful only if is_leaf is True.

    next_leaf_ : _CFNode
        next_leaf. Useful only if is_leaf is True.
        the final subclusters.

    init_centroids_ : ndarray of shape (branching_factor + 1, n_features)
        Manipulate ``init_centroids_`` throughout rather than centroids_ since
        the centroids are just a view of the ``init_centroids_`` .

    init_sq_norm_ : ndarray of shape (branching_factor + 1,)
        manipulate init_sq_norm_ throughout. similar to ``init_centroids_``.

    centroids_ : ndarray of shape (branching_factor + 1, n_features)
        View of ``init_centroids_``.

    squared_norm_ : ndarray of shape (branching_factor + 1,)
        View of ``init_sq_norm_``.

    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">threshold</span><span class="punctuation">,</span> <span class="identifier">branching_factor</span><span class="punctuation">,</span> <span class="identifier">is_leaf</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">threshold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">threshold</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">branching_factor</span> <span class="arithmetic-assignment">=</span> <span class="identifier">branching_factor</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">is_leaf</span> <span class="arithmetic-assignment">=</span> <span class="identifier">is_leaf</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_features</span>

        <span class="comment"># The list of subclusters, centroids and squared norms</span>
        <span class="comment"># to manipulate throughout.</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subclusters_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_centroids_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">branching_factor</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_sq_norm_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">branching_factor</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">squared_norm_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">prev_leaf_</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">next_leaf_</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>

    <span class="keyword">def</span> <span class="identifier">append_subcluster</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">subcluster</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subclusters_</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subclusters_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">subcluster</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_centroids_</span><span class="grouping">[</span><span class="identifier">n_samples</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">subcluster</span><span class="punctuation">.</span><span class="identifier">centroid_</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_sq_norm_</span><span class="grouping">[</span><span class="identifier">n_samples</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">subcluster</span><span class="punctuation">.</span><span class="identifier">sq_norm_</span>

        <span class="comment"># Keep centroids and squared norm as views. In this way</span>
        <span class="comment"># if we change init_centroids and init_sq_norm_, it is</span>
        <span class="comment"># sufficient,</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">centroids_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_centroids_</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_samples</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">squared_norm_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_sq_norm_</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_samples</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">update_split_subclusters</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">subcluster</span><span class="punctuation">,</span>
                                 <span class="identifier">new_subcluster1</span><span class="punctuation">,</span> <span class="identifier">new_subcluster2</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Remove a subcluster from a node and update it with the
        split subclusters.
        """</span>
        <span class="identifier">ind</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subclusters_</span><span class="punctuation">.</span><span class="identifier">index</span><span class="grouping">(</span><span class="identifier">subcluster</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subclusters_</span><span class="grouping">[</span><span class="identifier">ind</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_subcluster1</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_centroids_</span><span class="grouping">[</span><span class="identifier">ind</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_subcluster1</span><span class="punctuation">.</span><span class="identifier">centroid_</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_sq_norm_</span><span class="grouping">[</span><span class="identifier">ind</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_subcluster1</span><span class="punctuation">.</span><span class="identifier">sq_norm_</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">append_subcluster</span><span class="grouping">(</span><span class="identifier">new_subcluster2</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">insert_cf_subcluster</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">subcluster</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Insert a new subcluster into the node."""</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subclusters_</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">append_subcluster</span><span class="grouping">(</span><span class="identifier">subcluster</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="bool-literal">False</span>

        <span class="identifier">threshold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">threshold</span>
        <span class="identifier">branching_factor</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">branching_factor</span>
        <span class="comment"># We need to find the closest subcluster among all the</span>
        <span class="comment"># subclusters so that we can insert our new subcluster.</span>
        <span class="identifier">dist_matrix</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">centroids_</span><span class="punctuation">,</span> <span class="identifier">subcluster</span><span class="punctuation">.</span><span class="identifier">centroid_</span><span class="grouping">)</span>
        <span class="identifier">dist_matrix</span> <span class="arithmetic-assignment">*=</span> <span class="arithmetic-operator">-</span><span class="int-literal">2</span><span class="punctuation">.</span>
        <span class="identifier">dist_matrix</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">squared_norm_</span>
        <span class="identifier">closest_index</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argmin</span><span class="grouping">(</span><span class="identifier">dist_matrix</span><span class="grouping">)</span>
        <span class="identifier">closest_subcluster</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subclusters_</span><span class="grouping">[</span><span class="identifier">closest_index</span><span class="grouping">]</span>

        <span class="comment"># If the subcluster has a child, we need a recursive strategy.</span>
        <span class="keyword">if</span> <span class="identifier">closest_subcluster</span><span class="punctuation">.</span><span class="identifier">child_</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">split_child</span> <span class="arithmetic-assignment">=</span> <span class="identifier">closest_subcluster</span><span class="punctuation">.</span><span class="identifier">child_</span><span class="punctuation">.</span><span class="identifier">insert_cf_subcluster</span><span class="grouping">(</span>
                <span class="identifier">subcluster</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">split_child</span><span class="punctuation">:</span>
                <span class="comment"># If it is determined that the child need not be split, we</span>
                <span class="comment"># can just update the closest_subcluster</span>
                <span class="identifier">closest_subcluster</span><span class="punctuation">.</span><span class="identifier">update</span><span class="grouping">(</span><span class="identifier">subcluster</span><span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_centroids_</span><span class="grouping">[</span><span class="identifier">closest_index</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subclusters_</span><span class="grouping">[</span><span class="identifier">closest_index</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">centroid_</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_sq_norm_</span><span class="grouping">[</span><span class="identifier">closest_index</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subclusters_</span><span class="grouping">[</span><span class="identifier">closest_index</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">sq_norm_</span>
                <span class="keyword">return</span> <span class="bool-literal">False</span>

            <span class="comment"># things not too good. we need to redistribute the subclusters in</span>
            <span class="comment"># our child node, and add a new subcluster in the parent</span>
            <span class="comment"># subcluster to accommodate the new child.</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">new_subcluster1</span><span class="punctuation">,</span> <span class="identifier">new_subcluster2</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_split_node</span><span class="grouping">(</span>
                    <span class="identifier">closest_subcluster</span><span class="punctuation">.</span><span class="identifier">child_</span><span class="punctuation">,</span> <span class="identifier">threshold</span><span class="punctuation">,</span> <span class="identifier">branching_factor</span><span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">update_split_subclusters</span><span class="grouping">(</span>
                    <span class="identifier">closest_subcluster</span><span class="punctuation">,</span> <span class="identifier">new_subcluster1</span><span class="punctuation">,</span> <span class="identifier">new_subcluster2</span><span class="grouping">)</span>

                <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subclusters_</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">branching_factor</span><span class="punctuation">:</span>
                    <span class="keyword">return</span> <span class="bool-literal">True</span>
                <span class="keyword">return</span> <span class="bool-literal">False</span>

        <span class="comment"># good to go!</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">merged</span> <span class="arithmetic-assignment">=</span> <span class="identifier">closest_subcluster</span><span class="punctuation">.</span><span class="identifier">merge_subcluster</span><span class="grouping">(</span>
                <span class="identifier">subcluster</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">threshold</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">merged</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_centroids_</span><span class="grouping">[</span><span class="identifier">closest_index</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
                    <span class="identifier">closest_subcluster</span><span class="punctuation">.</span><span class="identifier">centroid_</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_sq_norm_</span><span class="grouping">[</span><span class="identifier">closest_index</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
                    <span class="identifier">closest_subcluster</span><span class="punctuation">.</span><span class="identifier">sq_norm_</span>
                <span class="keyword">return</span> <span class="bool-literal">False</span>

            <span class="comment"># not close to any other subclusters, and we still</span>
            <span class="comment"># have space, so add.</span>
            <span class="keyword">elif</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subclusters_</span><span class="grouping">)</span> <span class="relational-operator">&lt;</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">branching_factor</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">append_subcluster</span><span class="grouping">(</span><span class="identifier">subcluster</span><span class="grouping">)</span>
                <span class="keyword">return</span> <span class="bool-literal">False</span>

            <span class="comment"># We do not have enough space nor is it closer to an</span>
            <span class="comment"># other subcluster. We need to split.</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">append_subcluster</span><span class="grouping">(</span><span class="identifier">subcluster</span><span class="grouping">)</span>
                <span class="keyword">return</span> <span class="bool-literal">True</span>


<span class="keyword">class</span> <span class="identifier">_CFSubcluster</span><span class="punctuation">:</span>
    <span class="comment">"""Each subcluster in a CFNode is called a CFSubcluster.

    A CFSubcluster can have a CFNode has its child.

    Parameters
    ----------
    linear_sum : ndarray of shape (n_features,), default=None
        Sample. This is kept optional to allow initialization of empty
        subclusters.

    Attributes
    ----------
    n_samples_ : int
        Number of samples that belong to each subcluster.

    linear_sum_ : ndarray
        Linear sum of all the samples in a subcluster. Prevents holding
        all sample data in memory.

    squared_sum_ : float
        Sum of the squared l2 norms of all samples belonging to a subcluster.

    centroid_ : ndarray of shape (branching_factor + 1, n_features)
        Centroid of the subcluster. Prevent recomputing of centroids when
        ``CFNode.centroids_`` is called.

    child_ : _CFNode
        Child Node of the subcluster. Once a given _CFNode is set as the child
        of the _CFNode, it is set to ``self.child_``.

    sq_norm_ : ndarray of shape (branching_factor + 1,)
        Squared norm of the subcluster. Used to prevent recomputing when
        pairwise minimum distances are computed.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">linear_sum</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">linear_sum</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_samples_</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">squared_sum_</span> <span class="arithmetic-assignment">=</span> <span class="float-literal">0.0</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">centroid_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">linear_sum_</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_samples_</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">centroid_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">linear_sum_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linear_sum</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">squared_sum_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sq_norm_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">linear_sum_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">linear_sum_</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">child_</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>

    <span class="keyword">def</span> <span class="identifier">update</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">subcluster</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_samples_</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">subcluster</span><span class="punctuation">.</span><span class="identifier">n_samples_</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">linear_sum_</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">subcluster</span><span class="punctuation">.</span><span class="identifier">linear_sum_</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">squared_sum_</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">subcluster</span><span class="punctuation">.</span><span class="identifier">squared_sum_</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">centroid_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">linear_sum_</span> <span class="arithmetic-operator">/</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_samples_</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sq_norm_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">centroid_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">centroid_</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">merge_subcluster</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">nominee_cluster</span><span class="punctuation">,</span> <span class="identifier">threshold</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Check if a cluster is worthy enough to be merged. If
        yes then merge.
        """</span>
        <span class="identifier">new_ss</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">squared_sum_</span> <span class="arithmetic-operator">+</span> <span class="identifier">nominee_cluster</span><span class="punctuation">.</span><span class="identifier">squared_sum_</span>
        <span class="identifier">new_ls</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">linear_sum_</span> <span class="arithmetic-operator">+</span> <span class="identifier">nominee_cluster</span><span class="punctuation">.</span><span class="identifier">linear_sum_</span>
        <span class="identifier">new_n</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_samples_</span> <span class="arithmetic-operator">+</span> <span class="identifier">nominee_cluster</span><span class="punctuation">.</span><span class="identifier">n_samples_</span>
        <span class="identifier">new_centroid</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="int-literal">1</span> <span class="arithmetic-operator">/</span> <span class="identifier">new_n</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">new_ls</span>
        <span class="identifier">new_sq_norm</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">new_centroid</span><span class="punctuation">,</span> <span class="identifier">new_centroid</span><span class="grouping">)</span>

        <span class="comment"># The squared radius of the cluster is defined:</span>
        <span class="comment">#   r^2  = sum_i ||x_i - c||^2 / n</span>
        <span class="comment"># with x_i the n points assigned to the cluster and c its centroid:</span>
        <span class="comment">#   c = sum_i x_i / n</span>
        <span class="comment"># This can be expanded to:</span>
        <span class="comment">#   r^2 = sum_i ||x_i||^2 / n - 2 &lt; sum_i x_i / n, c&gt; + n ||c||^2 / n</span>
        <span class="comment"># and therefore simplifies to:</span>
        <span class="comment">#   r^2 = sum_i ||x_i||^2 / n - ||c||^2</span>
        <span class="identifier">sq_radius</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_ss</span> <span class="arithmetic-operator">/</span> <span class="identifier">new_n</span> <span class="arithmetic-operator">-</span> <span class="identifier">new_sq_norm</span>

        <span class="keyword">if</span> <span class="identifier">sq_radius</span> <span class="relational-operator">&lt;=</span> <span class="identifier">threshold</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="punctuation">:</span>
            <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_samples_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">linear_sum_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">squared_sum_</span><span class="punctuation">,</span>
             <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">centroid_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sq_norm_</span><span class="grouping">)</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
                <span class="identifier">new_n</span><span class="punctuation">,</span> <span class="identifier">new_ls</span><span class="punctuation">,</span> <span class="identifier">new_ss</span><span class="punctuation">,</span> <span class="identifier">new_centroid</span><span class="punctuation">,</span> <span class="identifier">new_sq_norm</span>
            <span class="keyword">return</span> <span class="bool-literal">True</span>
        <span class="keyword">return</span> <span class="bool-literal">False</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">radius</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Return radius of the subcluster"""</span>
        <span class="comment"># Because of numerical issues, this could become negative</span>
        <span class="identifier">sq_radius</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">squared_sum_</span> <span class="arithmetic-operator">/</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_samples_</span> <span class="arithmetic-operator">-</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sq_norm_</span>
        <span class="keyword">return</span> <span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">max</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">sq_radius</span><span class="grouping">)</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">Birch</span><span class="grouping">(</span><span class="identifier">ClusterMixin</span><span class="punctuation">,</span> <span class="identifier">TransformerMixin</span><span class="punctuation">,</span> <span class="identifier">BaseEstimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Implements the BIRCH clustering algorithm.

    It is a memory-efficient, online-learning algorithm provided as an
    alternative to :class:`MiniBatchKMeans`. It constructs a tree
    data structure with the cluster centroids being read off the leaf.
    These can be either the final cluster centroids or can be provided as input
    to another clustering algorithm such as :class:`AgglomerativeClustering`.

    Read more in the :ref:`User Guide &lt;birch&gt;`.

    .. versionadded:: 0.16

    Parameters
    ----------
    threshold : float, default=0.5
        The radius of the subcluster obtained by merging a new sample and the
        closest subcluster should be lesser than the threshold. Otherwise a new
        subcluster is started. Setting this value to be very low promotes
        splitting and vice-versa.

    branching_factor : int, default=50
        Maximum number of CF subclusters in each node. If a new samples enters
        such that the number of subclusters exceed the branching_factor then
        that node is split into two nodes with the subclusters redistributed
        in each. The parent subcluster of that node is removed and two new
        subclusters are added as parents of the 2 split nodes.

    n_clusters : int, instance of sklearn.cluster model, default=3
        Number of clusters after the final clustering step, which treats the
        subclusters from the leaves as new samples.

        - `None` : the final clustering step is not performed and the
          subclusters are returned as they are.

        - :mod:`sklearn.cluster` Estimator : If a model is provided, the model
          is fit treating the subclusters as new samples and the initial data
          is mapped to the label of the closest subcluster.

        - `int` : the model fit is :class:`AgglomerativeClustering` with
          `n_clusters` set to be equal to the int.

    compute_labels : bool, default=True
        Whether or not to compute labels for each fit.

    copy : bool, default=True
        Whether or not to make a copy of the given data. If set to False,
        the initial data will be overwritten.

    Attributes
    ----------
    root_ : _CFNode
        Root of the CFTree.

    dummy_leaf_ : _CFNode
        Start pointer to all the leaves.

    subcluster_centers_ : ndarray
        Centroids of all subclusters read directly from the leaves.

    subcluster_labels_ : ndarray
        Labels assigned to the centroids of the subclusters after
        they are clustered globally.

    labels_ : ndarray of shape (n_samples,)
        Array of labels assigned to the input data.
        if partial_fit is used instead of fit, they are assigned to the
        last batch of data.

    See Also
    --------
    MiniBatchKMeans : Alternative implementation that does incremental updates
        of the centers' positions using mini-batches.

    Notes
    -----
    The tree data structure consists of nodes with each node consisting of
    a number of subclusters. The maximum number of subclusters in a node
    is determined by the branching factor. Each subcluster maintains a
    linear sum, squared sum and the number of samples in that subcluster.
    In addition, each subcluster can also have a node as its child, if the
    subcluster is not a member of a leaf node.

    For a new point entering the root, it is merged with the subcluster closest
    to it and the linear sum, squared sum and the number of samples of that
    subcluster are updated. This is done recursively till the properties of
    the leaf node are updated.

    References
    ----------
    * Tian Zhang, Raghu Ramakrishnan, Maron Livny
      BIRCH: An efficient data clustering method for large databases.
      https://www.cs.sfu.ca/CourseCentral/459/han/papers/zhang96.pdf

    * Roberto Perdisci
      JBirch - Java implementation of BIRCH clustering algorithm
      https://code.google.com/archive/p/jbirch

    Examples
    --------
    &gt;&gt;&gt; from sklearn.cluster import Birch
    &gt;&gt;&gt; X = [[0, 1], [0.3, 1], [-0.3, 1], [0, -1], [0.3, -1], [-0.3, -1]]
    &gt;&gt;&gt; brc = Birch(n_clusters=None)
    &gt;&gt;&gt; brc.fit(X)
    Birch(n_clusters=None)
    &gt;&gt;&gt; brc.predict(X)
    array([0, 0, 0, 1, 1, 1])
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">threshold</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.5</span><span class="punctuation">,</span> <span class="identifier">branching_factor</span><span class="arithmetic-assignment">=</span><span class="int-literal">50</span><span class="punctuation">,</span> <span class="identifier">n_clusters</span><span class="arithmetic-assignment">=</span><span class="int-literal">3</span><span class="punctuation">,</span>
                 <span class="identifier">compute_labels</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">threshold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">threshold</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">branching_factor</span> <span class="arithmetic-assignment">=</span> <span class="identifier">branching_factor</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_clusters</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">compute_labels</span> <span class="arithmetic-assignment">=</span> <span class="identifier">compute_labels</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy</span>

    <span class="comment"># TODO: Remove in 1.2</span>
    <span class="comment"># mypy error: Decorated property not supported</span>
    <span class="punctuation">@</span><span class="identifier">deprecated</span><span class="grouping">(</span>  <span class="comment"># type: ignore</span>
        <span class="string-literal">"fit_ is deprecated in 1.0 and will be removed in 1.2"</span>
    <span class="grouping">)</span>
    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">fit_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_deprecated_fit</span>

    <span class="comment"># TODO: Remove in 1.2</span>
    <span class="comment"># mypy error: Decorated property not supported</span>
    <span class="punctuation">@</span><span class="identifier">deprecated</span><span class="grouping">(</span>  <span class="comment"># type: ignore</span>
        <span class="string-literal">"partial_fit_ is deprecated in 1.0 and will be removed in 1.2"</span>
    <span class="grouping">)</span>
    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">partial_fit_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_deprecated_partial_fit</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Build a CF Tree for the input data.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            Input data.

        y : Ignored
            Not used, present here for API consistency by convention.

        Returns
        -------
        self
            Fitted estimator.
        """</span>
        <span class="comment"># TODO: Remove deprected flags in 1.2</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_deprecated_fit</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_deprecated_partial_fit</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span><span class="punctuation">,</span> <span class="bool-literal">False</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">partial</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">partial</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">has_root</span> <span class="arithmetic-assignment">=</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">'root_'</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">)</span>
        <span class="identifier">first_call</span> <span class="arithmetic-assignment">=</span> <span class="logical-operator">not</span> <span class="grouping">(</span><span class="identifier">partial</span> <span class="logical-operator">and</span> <span class="identifier">has_root</span><span class="grouping">)</span>

        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csr'</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="punctuation">,</span>
                                <span class="identifier">reset</span><span class="arithmetic-assignment">=</span><span class="identifier">first_call</span><span class="grouping">)</span>
        <span class="identifier">threshold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">threshold</span>
        <span class="identifier">branching_factor</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">branching_factor</span>

        <span class="keyword">if</span> <span class="identifier">branching_factor</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Branching_factor should be greater than one."</span><span class="grouping">)</span>
        <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>

        <span class="comment"># If partial_fit is called for the first time or fit is called, we</span>
        <span class="comment"># start a new tree.</span>
        <span class="keyword">if</span> <span class="identifier">first_call</span><span class="punctuation">:</span>
            <span class="comment"># The first root is the leaf. Manipulate this object throughout.</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_CFNode</span><span class="grouping">(</span><span class="identifier">threshold</span><span class="arithmetic-assignment">=</span><span class="identifier">threshold</span><span class="punctuation">,</span>
                                 <span class="identifier">branching_factor</span><span class="arithmetic-assignment">=</span><span class="identifier">branching_factor</span><span class="punctuation">,</span>
                                 <span class="identifier">is_leaf</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                                 <span class="identifier">n_features</span><span class="arithmetic-assignment">=</span><span class="identifier">n_features</span><span class="grouping">)</span>

            <span class="comment"># To enable getting back subclusters.</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dummy_leaf_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_CFNode</span><span class="grouping">(</span><span class="identifier">threshold</span><span class="arithmetic-assignment">=</span><span class="identifier">threshold</span><span class="punctuation">,</span>
                                       <span class="identifier">branching_factor</span><span class="arithmetic-assignment">=</span><span class="identifier">branching_factor</span><span class="punctuation">,</span>
                                       <span class="identifier">is_leaf</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="arithmetic-assignment">=</span><span class="identifier">n_features</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dummy_leaf_</span><span class="punctuation">.</span><span class="identifier">next_leaf_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root_</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root_</span><span class="punctuation">.</span><span class="identifier">prev_leaf_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dummy_leaf_</span>

        <span class="comment"># Cannot vectorize. Enough to convince to use cython.</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">iter_func</span> <span class="arithmetic-assignment">=</span> <span class="identifier">iter</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">iter_func</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_iterate_sparse_X</span>

        <span class="keyword">for</span> <span class="identifier">sample</span> <span class="relational-operator">in</span> <span class="identifier">iter_func</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">subcluster</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_CFSubcluster</span><span class="grouping">(</span><span class="identifier">linear_sum</span><span class="arithmetic-assignment">=</span><span class="identifier">sample</span><span class="grouping">)</span>
            <span class="identifier">split</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root_</span><span class="punctuation">.</span><span class="identifier">insert_cf_subcluster</span><span class="grouping">(</span><span class="identifier">subcluster</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="identifier">split</span><span class="punctuation">:</span>
                <span class="identifier">new_subcluster1</span><span class="punctuation">,</span> <span class="identifier">new_subcluster2</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_split_node</span><span class="grouping">(</span>
                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root_</span><span class="punctuation">,</span> <span class="identifier">threshold</span><span class="punctuation">,</span> <span class="identifier">branching_factor</span><span class="grouping">)</span>
                <span class="keyword">del</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root_</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_CFNode</span><span class="grouping">(</span><span class="identifier">threshold</span><span class="arithmetic-assignment">=</span><span class="identifier">threshold</span><span class="punctuation">,</span>
                                     <span class="identifier">branching_factor</span><span class="arithmetic-assignment">=</span><span class="identifier">branching_factor</span><span class="punctuation">,</span>
                                     <span class="identifier">is_leaf</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                                     <span class="identifier">n_features</span><span class="arithmetic-assignment">=</span><span class="identifier">n_features</span><span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root_</span><span class="punctuation">.</span><span class="identifier">append_subcluster</span><span class="grouping">(</span><span class="identifier">new_subcluster1</span><span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root_</span><span class="punctuation">.</span><span class="identifier">append_subcluster</span><span class="grouping">(</span><span class="identifier">new_subcluster2</span><span class="grouping">)</span>

        <span class="identifier">centroids</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">concatenate</span><span class="grouping">(</span><span class="grouping">[</span>
            <span class="identifier">leaf</span><span class="punctuation">.</span><span class="identifier">centroids_</span> <span class="keyword">for</span> <span class="identifier">leaf</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_get_leaves</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subcluster_centers_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">centroids</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_global_clustering</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">_get_leaves</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Retrieve the leaves of the CF Node.

        Returns
        -------
        leaves : list of shape (n_leaves,)
            List of the leaf nodes.
        """</span>
        <span class="identifier">leaf_ptr</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dummy_leaf_</span><span class="punctuation">.</span><span class="identifier">next_leaf_</span>
        <span class="identifier">leaves</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
        <span class="keyword">while</span> <span class="identifier">leaf_ptr</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">leaves</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">leaf_ptr</span><span class="grouping">)</span>
            <span class="identifier">leaf_ptr</span> <span class="arithmetic-assignment">=</span> <span class="identifier">leaf_ptr</span><span class="punctuation">.</span><span class="identifier">next_leaf_</span>
        <span class="keyword">return</span> <span class="identifier">leaves</span>

    <span class="keyword">def</span> <span class="identifier">partial_fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Online learning. Prevents rebuilding of CFTree from scratch.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features), \
            default=None
            Input data. If X is not provided, only the global clustering
            step is done.

        y : Ignored
            Not used, present here for API consistency by convention.

        Returns
        -------
        self
            Fitted estimator.
        """</span>
        <span class="comment"># TODO: Remove deprected flags in 1.2</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_deprecated_partial_fit</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_deprecated_fit</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span><span class="punctuation">,</span> <span class="bool-literal">False</span>
        <span class="keyword">if</span> <span class="identifier">X</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="comment"># Perform just the final global clustering step.</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_global_clustering</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="identifier">self</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">partial</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_check_fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">'subcluster_centers_'</span><span class="grouping">)</span> <span class="logical-operator">and</span>
                <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="relational-operator">!=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subcluster_centers_</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">"Training data and predicted data do "</span>
                <span class="string-literal">"not have same number of features."</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Predict data using the ``centroids_`` of subclusters.

        Avoid computation of the row norms of X.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            Input data.

        Returns
        -------
        labels : ndarray of shape(n_samples,)
            Labelled data.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csr'</span><span class="punctuation">,</span> <span class="identifier">reset</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">kwargs</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="string-literal">'Y_norm_squared'</span><span class="punctuation">:</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_subcluster_norms</span><span class="grouping">}</span>

        <span class="keyword">with</span> <span class="identifier">config_context</span><span class="grouping">(</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">argmin</span> <span class="arithmetic-assignment">=</span> <span class="identifier">pairwise_distances_argmin</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subcluster_centers_</span><span class="punctuation">,</span>
                                               <span class="identifier">metric_kwargs</span><span class="arithmetic-assignment">=</span><span class="identifier">kwargs</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subcluster_labels_</span><span class="grouping">[</span><span class="identifier">argmin</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Transform X into subcluster centroids dimension.

        Each dimension represents the distance from the sample point to each
        cluster centroid.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            Input data.

        Returns
        -------
        X_trans : {array-like, sparse matrix} of shape (n_samples, n_clusters)
            Transformed data.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csr'</span><span class="punctuation">,</span> <span class="identifier">reset</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="keyword">with</span> <span class="identifier">config_context</span><span class="grouping">(</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">euclidean_distances</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subcluster_centers_</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_global_clustering</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Global clustering for the subclusters obtained after fitting
        """</span>
        <span class="identifier">clusterer</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span>
        <span class="identifier">centroids</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subcluster_centers_</span>
        <span class="identifier">compute_labels</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">X</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">compute_labels</span>

        <span class="comment"># Preprocessing for the global clustering.</span>
        <span class="identifier">not_enough_centroids</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">clusterer</span><span class="punctuation">,</span> <span class="identifier">numbers</span><span class="punctuation">.</span><span class="identifier">Integral</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">clusterer</span> <span class="arithmetic-assignment">=</span> <span class="identifier">AgglomerativeClustering</span><span class="grouping">(</span>
                <span class="identifier">n_clusters</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span><span class="grouping">)</span>
            <span class="comment"># There is no need to perform the global clustering step.</span>
            <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">centroids</span><span class="grouping">)</span> <span class="relational-operator">&lt;</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span><span class="punctuation">:</span>
                <span class="identifier">not_enough_centroids</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>
        <span class="keyword">elif</span> <span class="grouping">(</span><span class="identifier">clusterer</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="logical-operator">not</span>
              <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">clusterer</span><span class="punctuation">,</span> <span class="string-literal">'fit_predict'</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"n_clusters should be an instance of "</span>
                             <span class="string-literal">"ClusterMixin or an int"</span><span class="grouping">)</span>

        <span class="comment"># To use in predict to avoid recalculation.</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_subcluster_norms</span> <span class="arithmetic-assignment">=</span> <span class="identifier">row_norms</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subcluster_centers_</span><span class="punctuation">,</span> <span class="identifier">squared</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">clusterer</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="logical-operator">or</span> <span class="identifier">not_enough_centroids</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subcluster_labels_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">centroids</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">not_enough_centroids</span><span class="punctuation">:</span>
                <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span>
                    <span class="string-literal">"Number of subclusters found (%d) by BIRCH is less "</span>
                    <span class="string-literal">"than (%d). Decrease the threshold."</span>
                    <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">centroids</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">ConvergenceWarning</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># The global clustering step that clusters the subclusters of</span>
            <span class="comment"># the leaves. It assumes the centroids of the subclusters as</span>
            <span class="comment"># samples and finds the final centroids.</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subcluster_labels_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">clusterer</span><span class="punctuation">.</span><span class="identifier">fit_predict</span><span class="grouping">(</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">subcluster_centers_</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">compute_labels</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">labels_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

    </pre>
  </body>
</html>