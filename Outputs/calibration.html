<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""Calibration of predicted probabilities."""</span>

<span class="comment"># Author: Alexandre Gramfort &lt;alexandre.gramfort@telecom-paristech.fr&gt;</span>
<span class="comment">#         Balazs Kegl &lt;balazs.kegl@gmail.com&gt;</span>
<span class="comment">#         Jan Hendrik Metzen &lt;jhm@informatik.uni-bremen.de&gt;</span>
<span class="comment">#         Mathieu Blondel &lt;mathieu@mblondel.org&gt;</span>
<span class="comment">#</span>
<span class="comment"># License: BSD 3 clause</span>

<span class="keyword">import</span> <span class="identifier">warnings</span>
<span class="keyword">from</span> <span class="identifier">inspect</span> <span class="keyword">import</span> <span class="identifier">signature</span>
<span class="keyword">from</span> <span class="identifier">functools</span> <span class="keyword">import</span> <span class="identifier">partial</span>

<span class="keyword">from</span> <span class="identifier">math</span> <span class="keyword">import</span> <span class="identifier">log</span>
<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">from</span> <span class="identifier">joblib</span> <span class="keyword">import</span> <span class="identifier">Parallel</span>

<span class="keyword">from</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">special</span> <span class="keyword">import</span> <span class="identifier">expit</span>
<span class="keyword">from</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">special</span> <span class="keyword">import</span> <span class="identifier">xlogy</span>
<span class="keyword">from</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">optimize</span> <span class="keyword">import</span> <span class="identifier">fmin_bfgs</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="grouping">(</span><span class="identifier">BaseEstimator</span><span class="punctuation">,</span> <span class="invalid">C</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">M</span><span class="invalid">i</span><span class="invalid">x</span><span class="invalid">i</span><span class="invalid">n</span><span class="punctuation">,</span> <span class="identifier">RegressorMixin</span><span class="punctuation">,</span> <span class="identifier">clone</span><span class="punctuation">,</span>
                   <span class="identifier">MetaEstimatorMixin</span><span class="grouping">)</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">preprocessing</span> <span class="keyword">import</span> <span class="identifier">label_binarize</span><span class="punctuation">,</span> <span class="identifier">LabelEncoder</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="grouping">(</span>
    <span class="identifier">column_or_1d</span><span class="punctuation">,</span>
    <span class="identifier">deprecated</span><span class="punctuation">,</span>
    <span class="identifier">indexable</span><span class="punctuation">,</span>
<span class="grouping">)</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">multiclass</span> <span class="keyword">import</span> <span class="identifier">check_classification_targets</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">fixes</span> <span class="keyword">import</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_is_fitted</span><span class="punctuation">,</span> <span class="identifier">check_consistent_length</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">_check_sample_weight</span><span class="punctuation">,</span> <span class="identifier">_num_samples</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">_safe_indexing</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">isotonic</span> <span class="keyword">import</span> <span class="identifier">IsotonicRegression</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">svm</span> <span class="keyword">import</span> <span class="identifier">LinearSVC</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">model_selection</span> <span class="keyword">import</span> <span class="identifier">check_cv</span><span class="punctuation">,</span> <span class="identifier">cross_val_predict</span>


<span class="keyword">class</span> <span class="identifier">CalibratedClassifierCV</span><span class="grouping">(</span><span class="invalid">C</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">M</span><span class="invalid">i</span><span class="invalid">x</span><span class="invalid">i</span><span class="invalid">n</span><span class="punctuation">,</span>
                             <span class="identifier">MetaEstimatorMixin</span><span class="punctuation">,</span>
                             <span class="identifier">BaseEstimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Probability calibration with isotonic regression or logistic regression.

    This class uses cross-validation to both estimate the parameters of a
    classifier and subsequently calibrate a classifier. With default
    `ensemble=True`, for each cv split it
    fits a copy of the base estimator to the training subset, and calibrates it
    using the testing subset. For prediction, predicted probabilities are
    averaged across these individual calibrated classifiers. When
    `ensemble=False`, cross-validation is used to obtain unbiased predictions,
    via :func:`~sklearn.model_selection.cross_val_predict`, which are then
    used for calibration. For prediction, the base estimator, trained using all
    the data, is used. This is the method implemented when `probabilities=True`
    for :mod:`sklearn.svm` estimators.

    Already fitted classifiers can be calibrated via the parameter
    `cv="prefit"`. In this case, no cross-validation is used and all provided
    data is used for calibration. The user has to take care manually that data
    for model fitting and calibration are disjoint.

    The calibration is based on the :term:`decision_function` method of the
    `base_estimator` if it exists, else on :term:`predict_proba`.

    Read more in the :ref:`User Guide &lt;calibration&gt;`.

    Parameters
    ----------
    base_estimator : estimator instance, default=None
        The classifier whose output need to be calibrated to provide more
        accurate `predict_proba` outputs. The default classifier is
        a :class:`~sklearn.svm.LinearSVC`.

    method : {'sigmoid', 'isotonic'}, default='sigmoid'
        The method to use for calibration. Can be 'sigmoid' which
        corresponds to Platt's method (i.e. a logistic regression model) or
        'isotonic' which is a non-parametric approach. It is not advised to
        use isotonic calibration with too few calibration samples
        ``(&lt;&lt;1000)`` since it tends to overfit.

    cv : int, cross-validation generator, iterable or "prefit", \
            default=None
        Determines the cross-validation splitting strategy.
        Possible inputs for cv are:

        - None, to use the default 5-fold cross-validation,
        - integer, to specify the number of folds.
        - :term:`CV splitter`,
        - An iterable yielding (train, test) splits as arrays of indices.

        For integer/None inputs, if ``y`` is binary or multiclass,
        :class:`~sklearn.model_selection.StratifiedKFold` is used. If ``y`` is
        neither binary nor multiclass, :class:`~sklearn.model_selection.KFold`
        is used.

        Refer to the :ref:`User Guide &lt;cross_validation&gt;` for the various
        cross-validation strategies that can be used here.

        If "prefit" is passed, it is assumed that `base_estimator` has been
        fitted already and all data is used for calibration.

        .. versionchanged:: 0.22
            ``cv`` default value if None changed from 3-fold to 5-fold.

    n_jobs : int, default=None
        Number of jobs to run in parallel.
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors.

        Base estimator clones are fitted in parallel across cross-validation
        iterations. Therefore parallelism happens only when `cv != "prefit"`.

        See :term:`Glossary &lt;n_jobs&gt;` for more details.

        .. versionadded:: 0.24

    ensemble : bool, default=True
        Determines how the calibrator is fitted when `cv` is not `'prefit'`.
        Ignored if `cv='prefit'`.

        If `True`, the `base_estimator` is fitted using training data and
        calibrated using testing data, for each `cv` fold. The final estimator
        is an ensemble of `n_cv` fitted classifer and calibrator pairs, where
        `n_cv` is the number of cross-validation folds. The output is the
        average predicted probabilities of all pairs.

        If `False`, `cv` is used to compute unbiased predictions, via
        :func:`~sklearn.model_selection.cross_val_predict`, which are then
        used for calibration. At prediction time, the classifier used is the
        `base_estimator` trained on all the data.
        Note that this method is also internally implemented  in
        :mod:`sklearn.svm` estimators with the `probabilities=True` parameter.

        .. versionadded:: 0.24

    Attributes
    ----------
    classes_ : ndarray of shape (n_classes,)
        The class labels.

    n_features_in_ : int
        Number of features seen during :term:`fit`. Only defined if the
        underlying base_estimator exposes such an attribute when fit.

        .. versionadded:: 0.24

    calibrated_classifiers_ : list (len() equal to cv or 1 if `cv="prefit"` \
            or `ensemble=False`)
        The list of classifier and calibrator pairs.

        - When `cv="prefit"`, the fitted `base_estimator` and fitted
          calibrator.
        - When `cv` is not "prefit" and `ensemble=True`, `n_cv` fitted
          `base_estimator` and calibrator pairs. `n_cv` is the number of
          cross-validation folds.
        - When `cv` is not "prefit" and `ensemble=False`, the `base_estimator`,
          fitted on all the data, and fitted calibrator.

        .. versionchanged:: 0.24
            Single calibrated classifier case when `ensemble=False`.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.datasets import make_classification
    &gt;&gt;&gt; from sklearn.naive_bayes import GaussianNB
    &gt;&gt;&gt; from sklearn.calibration import CalibratedClassifierCV
    &gt;&gt;&gt; X, y = make_classification(n_samples=100, n_features=2,
    ...                            n_redundant=0, random_state=42)
    &gt;&gt;&gt; base_clf = GaussianNB()
    &gt;&gt;&gt; calibrated_clf = CalibratedClassifierCV(base_estimator=base_clf, cv=3)
    &gt;&gt;&gt; calibrated_clf.fit(X, y)
    CalibratedClassifierCV(base_estimator=GaussianNB(), cv=3)
    &gt;&gt;&gt; len(calibrated_clf.calibrated_classifiers_)
    3
    &gt;&gt;&gt; calibrated_clf.predict_proba(X)[:5, :]
    array([[0.110..., 0.889...],
           [0.072..., 0.927...],
           [0.928..., 0.071...],
           [0.928..., 0.071...],
           [0.071..., 0.928...]])

    &gt;&gt;&gt; from sklearn.model_selection import train_test_split
    &gt;&gt;&gt; X, y = make_classification(n_samples=100, n_features=2,
    ...                            n_redundant=0, random_state=42)
    &gt;&gt;&gt; X_train, X_calib, y_train, y_calib = train_test_split(
    ...        X, y, random_state=42
    ... )
    &gt;&gt;&gt; base_clf = GaussianNB()
    &gt;&gt;&gt; base_clf.fit(X_train, y_train)
    GaussianNB()
    &gt;&gt;&gt; calibrated_clf = CalibratedClassifierCV(
    ...     base_estimator=base_clf,
    ...     cv="prefit"
    ... )
    &gt;&gt;&gt; calibrated_clf.fit(X_calib, y_calib)
    CalibratedClassifierCV(base_estimator=GaussianNB(), cv='prefit')
    &gt;&gt;&gt; len(calibrated_clf.calibrated_classifiers_)
    1
    &gt;&gt;&gt; calibrated_clf.predict_proba([[-0.5, 0.5]])
    array([[0.936..., 0.063...]])

    References
    ----------
    .. [1] Obtaining calibrated probability estimates from decision trees
           and naive Bayesian classifiers, B. Zadrozny & C. Elkan, ICML 2001

    .. [2] Transforming Classifier Scores into Accurate Multiclass
           Probability Estimates, B. Zadrozny & C. Elkan, (KDD 2002)

    .. [3] Probabilistic Outputs for Support Vector Machines and Comparisons to
           Regularized Likelihood Methods, J. Platt, (1999)

    .. [4] Predicting Good Probabilities with Supervised Learning,
           A. Niculescu-Mizil & R. Caruana, ICML 2005
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">base_estimator</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="string-literal">'sigmoid'</span><span class="punctuation">,</span>
                 <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">ensemble</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">base_estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">base_estimator</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">method</span> <span class="arithmetic-assignment">=</span> <span class="identifier">method</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cv</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_jobs</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">ensemble</span> <span class="arithmetic-assignment">=</span> <span class="identifier">ensemble</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the calibrated model.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data.

        y : array-like of shape (n_samples,)
            Target values.

        sample_weight : array-like of shape (n_samples,), default=None
            Sample weights. If None, then samples are equally weighted.

        Returns
        -------
        self : object
            Returns an instance of self.
        """</span>
        <span class="identifier">check_classification_targets</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">indexable</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">base_estimator</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="comment"># we want all classifiers that don't expose a random_state</span>
            <span class="comment"># to be deterministic (and we don't want to expose this one).</span>
            <span class="identifier">base_estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">LinearSVC</span><span class="grouping">(</span><span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">base_estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">base_estimator</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">calibrated_classifiers_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span> <span class="relational-operator">==</span> <span class="string-literal">"prefit"</span><span class="punctuation">:</span>
            <span class="comment"># `classes_` should be consistent with that of base_estimator</span>
            <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">base_estimator</span><span class="punctuation">,</span> <span class="identifier">attributes</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="string-literal">"classes_"</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">base_estimator</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span>

            <span class="identifier">pred_method</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_get_prediction_method</span><span class="grouping">(</span><span class="identifier">base_estimator</span><span class="grouping">)</span>
            <span class="identifier">n_classes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span>
            <span class="identifier">predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_compute_predictions</span><span class="grouping">(</span><span class="identifier">pred_method</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">n_classes</span><span class="grouping">)</span>

            <span class="identifier">calibrated_classifier</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_fit_calibrator</span><span class="grouping">(</span>
                <span class="identifier">base_estimator</span><span class="punctuation">,</span> <span class="identifier">predictions</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">method</span><span class="punctuation">,</span>
                <span class="identifier">sample_weight</span>
            <span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">calibrated_classifiers_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">calibrated_classifier</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># Set `classes_` using all `y`</span>
            <span class="identifier">label_encoder_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">LabelEncoder</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">label_encoder_</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span>
            <span class="identifier">n_classes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span>

            <span class="comment"># sample_weight checks</span>
            <span class="identifier">fit_parameters</span> <span class="arithmetic-assignment">=</span> <span class="identifier">signature</span><span class="grouping">(</span><span class="identifier">base_estimator</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">parameters</span>
            <span class="identifier">supports_sw</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"sample_weight"</span> <span class="relational-operator">in</span> <span class="identifier">fit_parameters</span>
            <span class="keyword">if</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_sample_weight</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span>
                <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">supports_sw</span><span class="punctuation">:</span>
                    <span class="identifier">estimator_name</span> <span class="arithmetic-assignment">=</span> <span class="identifier">type</span><span class="grouping">(</span><span class="identifier">base_estimator</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__name__</span>
                    <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Since {estimator_name} does not support "</span>
                                  <span class="string-literal">"sample_weights, sample weights will only be"</span>
                                  <span class="string-literal">" used for the calibration itself."</span><span class="grouping">)</span>

            <span class="comment"># Check that each cross-validation fold can have at least one</span>
            <span class="comment"># example per class</span>
            <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="identifier">int</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">n_folds</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span>
            <span class="keyword">elif</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="string-literal">"n_splits"</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">n_folds</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span><span class="punctuation">.</span><span class="identifier">n_splits</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">n_folds</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
            <span class="keyword">if</span> <span class="identifier">n_folds</span> <span class="logical-operator">and</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">any</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">y</span> <span class="relational-operator">==</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span> <span class="relational-operator">&lt;</span> <span class="identifier">n_folds</span>
                                   <span class="keyword">for</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Requesting {n_folds}-fold "</span>
                                 <span class="string-literal">"cross-validation but provided less than "</span>
                                 <span class="identifier">f</span><span class="string-literal">"{n_folds} examples for at least one class."</span><span class="grouping">)</span>
            <span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_cv</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">ensemble</span><span class="punctuation">:</span>
                <span class="identifier">parallel</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Parallel</span><span class="grouping">(</span><span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span><span class="grouping">)</span>

                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">calibrated_classifiers_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">parallel</span><span class="grouping">(</span>
                    <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">(</span><span class="identifier">_fit_classifier_calibrator_pair</span><span class="grouping">)</span><span class="grouping">(</span>
                        <span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">base_estimator</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">train</span><span class="arithmetic-assignment">=</span><span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span><span class="arithmetic-assignment">=</span><span class="identifier">test</span><span class="punctuation">,</span>
                        <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">method</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="punctuation">,</span>
                        <span class="identifier">supports_sw</span><span class="arithmetic-assignment">=</span><span class="identifier">supports_sw</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>
                    <span class="keyword">for</span> <span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span> <span class="relational-operator">in</span> <span class="identifier">cv</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>
                <span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">this_estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">base_estimator</span><span class="grouping">)</span>
                <span class="identifier">method_name</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_get_prediction_method</span><span class="grouping">(</span><span class="identifier">this_estimator</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__name__</span>
                <span class="identifier">pred_method</span> <span class="arithmetic-assignment">=</span> <span class="identifier">partial</span><span class="grouping">(</span>
                    <span class="identifier">cross_val_predict</span><span class="punctuation">,</span> <span class="identifier">estimator</span><span class="arithmetic-assignment">=</span><span class="identifier">this_estimator</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="identifier">y</span><span class="punctuation">,</span>
                    <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="identifier">method_name</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span>
                <span class="grouping">)</span>
                <span class="identifier">predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_compute_predictions</span><span class="grouping">(</span><span class="identifier">pred_method</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">n_classes</span><span class="grouping">)</span>

                <span class="keyword">if</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">supports_sw</span><span class="punctuation">:</span>
                    <span class="identifier">this_estimator</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="grouping">)</span>
                <span class="keyword">else</span><span class="punctuation">:</span>
                    <span class="identifier">this_estimator</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>
                <span class="identifier">calibrated_classifier</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_fit_calibrator</span><span class="grouping">(</span>
                    <span class="identifier">this_estimator</span><span class="punctuation">,</span> <span class="identifier">predictions</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">method</span><span class="punctuation">,</span>
                    <span class="identifier">sample_weight</span>
                <span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">calibrated_classifiers_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">calibrated_classifier</span><span class="grouping">)</span>

        <span class="identifier">first_clf</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">calibrated_classifiers_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">base_estimator</span>
        <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">first_clf</span><span class="punctuation">,</span> <span class="string-literal">"n_features_in_"</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_features_in_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">first_clf</span><span class="punctuation">.</span><span class="identifier">n_features_in_</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Calibrated probabilities of classification.

        This function returns calibrated probabilities of classification
        according to each class on an array of test vectors X.

        Parameters
        ----------
        X : The samples, as accepted by base_estimator.predict_proba

        Returns
        -------
        C : ndarray of shape (n_samples, n_classes)
            The predicted probas.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="comment"># Compute the arithmetic mean of the predictions of the calibrated</span>
        <span class="comment"># classifiers</span>
        <span class="identifier">mean_proba</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">calibrated_classifier</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">calibrated_classifiers_</span><span class="punctuation">:</span>
            <span class="identifier">proba</span> <span class="arithmetic-assignment">=</span> <span class="identifier">calibrated_classifier</span><span class="punctuation">.</span><span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
            <span class="identifier">mean_proba</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">proba</span>

        <span class="identifier">mean_proba</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">calibrated_classifiers_</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">mean_proba</span>

    <span class="keyword">def</span> <span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Predict the target of new samples. The predicted class is the
        class that has the highest probability, and can thus be different
        from the prediction of the uncalibrated classifier.

        Parameters
        ----------
        X : The samples, as accepted by base_estimator.predict

        Returns
        -------
        C : ndarray of shape (n_samples,)
            The predicted class.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argmax</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span>
            <span class="string-literal">'_xfail_checks'</span><span class="punctuation">:</span> <span class="grouping">{</span>
                <span class="string-literal">'check_sample_weights_invariance'</span><span class="punctuation">:</span>
                <span class="string-literal">'zero sample_weight is not equivalent to removing samples'</span><span class="punctuation">,</span>
            <span class="grouping">}</span>
        <span class="grouping">}</span>


<span class="keyword">def</span> <span class="identifier">_fit_classifier_calibrator_pair</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span><span class="punctuation">,</span> <span class="identifier">supports_sw</span><span class="punctuation">,</span>
                                    <span class="identifier">method</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Fit a classifier/calibration pair on a given train/test split.

    Fit the classifier on the train set, compute its predictions on the test
    set and use the predictions as input to fit the calibrator along with the
    test labels.

    Parameters
    ----------
    estimator : estimator instance
        Cloned base estimator.

    X : array-like, shape (n_samples, n_features)
        Sample data.

    y : array-like, shape (n_samples,)
        Targets.

    train : ndarray, shape (n_train_indicies,)
        Indices of the training subset.

    test : ndarray, shape (n_test_indicies,)
        Indices of the testing subset.

    supports_sw : bool
        Whether or not the `estimator` supports sample weights.

    method : {'sigmoid', 'isotonic'}
        Method to use for calibration.

    classes : ndarray, shape (n_classes,)
        The target classes.

    sample_weight : array-like, default=None
        Sample weights for `X`.

    Returns
    -------
    calibrated_classifier : _CalibratedClassifier instance
    """</span>
    <span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_safe_indexing</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">train</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">_safe_indexing</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">train</span><span class="grouping">)</span>
    <span class="identifier">X_test</span><span class="punctuation">,</span> <span class="identifier">y_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_safe_indexing</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">test</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">_safe_indexing</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">test</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">supports_sw</span> <span class="logical-operator">and</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">sw_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_safe_indexing</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">train</span><span class="grouping">)</span>
        <span class="identifier">sw_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_safe_indexing</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">test</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">sw_train</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
        <span class="identifier">sw_test</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>

    <span class="keyword">if</span> <span class="identifier">supports_sw</span><span class="punctuation">:</span>
        <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sw_train</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="grouping">)</span>

    <span class="identifier">n_classes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span>
    <span class="identifier">pred_method</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_get_prediction_method</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="grouping">)</span>
    <span class="identifier">predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_compute_predictions</span><span class="grouping">(</span><span class="identifier">pred_method</span><span class="punctuation">,</span> <span class="identifier">X_test</span><span class="punctuation">,</span> <span class="identifier">n_classes</span><span class="grouping">)</span>

    <span class="identifier">calibrated_classifier</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_fit_calibrator</span><span class="grouping">(</span>
        <span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">predictions</span><span class="punctuation">,</span> <span class="identifier">y_test</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="punctuation">,</span> <span class="identifier">method</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sw_test</span>
    <span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">calibrated_classifier</span>


<span class="keyword">def</span> <span class="identifier">_get_prediction_method</span><span class="grouping">(</span><span class="identifier">clf</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Return prediction method.

    `decision_function` method of `clf` returned, if it
    exists, otherwise `predict_proba` method returned.

    Parameters
    ----------
    clf : Estimator instance
        Fitted classifier to obtain the prediction method from.

    Returns
    -------
    prediction_method : callable
        The prediction method.
    """</span>
    <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">clf</span><span class="punctuation">,</span> <span class="string-literal">'decision_function'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">method</span> <span class="arithmetic-assignment">=</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">clf</span><span class="punctuation">,</span> <span class="string-literal">'decision_function'</span><span class="grouping">)</span>
    <span class="keyword">elif</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">clf</span><span class="punctuation">,</span> <span class="string-literal">'predict_proba'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">method</span> <span class="arithmetic-assignment">=</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">clf</span><span class="punctuation">,</span> <span class="string-literal">'predict_proba'</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">RuntimeError</span><span class="grouping">(</span><span class="string-literal">"'base_estimator' has no 'decision_function' or "</span>
                           <span class="string-literal">"'predict_proba' method."</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">method</span>


<span class="keyword">def</span> <span class="identifier">_compute_predictions</span><span class="grouping">(</span><span class="identifier">pred_method</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">n_classes</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Return predictions for `X` and reshape binary outputs to shape
    (n_samples, 1).

    Parameters
    ----------
    pred_method : callable
        Prediction method.

    X : array-like or None
        Data used to obtain predictions.

    n_classes : int
        Number of classes present.

    Returns
    -------
    predictions : array-like, shape (X.shape[0], len(clf.classes_))
        The predictions. Note if there are 2 classes, array is of shape
        (X.shape[0], 1).
    """</span>
    <span class="identifier">predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">pred_method</span><span class="grouping">(</span><span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">pred_method</span><span class="punctuation">,</span> <span class="string-literal">'__name__'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">method_name</span> <span class="arithmetic-assignment">=</span> <span class="identifier">pred_method</span><span class="punctuation">.</span><span class="identifier">__name__</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">method_name</span> <span class="arithmetic-assignment">=</span> <span class="identifier">signature</span><span class="grouping">(</span><span class="identifier">pred_method</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">parameters</span><span class="grouping">[</span><span class="string-literal">'method'</span><span class="grouping">]</span><span class="punctuation">.</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span>

    <span class="keyword">if</span> <span class="identifier">method_name</span> <span class="relational-operator">==</span> <span class="string-literal">'decision_function'</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">predictions</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">predictions</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
    <span class="keyword">elif</span> <span class="identifier">method_name</span> <span class="relational-operator">==</span> <span class="string-literal">'predict_proba'</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">n_classes</span> <span class="relational-operator">==</span> <span class="int-literal">2</span><span class="punctuation">:</span>
            <span class="identifier">predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">predictions</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="punctuation">:</span><span class="grouping">]</span>
    <span class="keyword">else</span><span class="punctuation">:</span>  <span class="comment"># pragma: no cover</span>
        <span class="comment"># this branch should be unreachable.</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Invalid prediction method: {method_name}"</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">predictions</span>


<span class="keyword">def</span> <span class="identifier">_fit_calibrator</span><span class="grouping">(</span><span class="identifier">clf</span><span class="punctuation">,</span> <span class="identifier">predictions</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="punctuation">,</span> <span class="identifier">method</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Fit calibrator(s) and return a `_CalibratedClassifier`
    instance.

    `n_classes` (i.e. `len(clf.classes_)`) calibrators are fitted.
    However, if `n_classes` equals 2, one calibrator is fitted.

    Parameters
    ----------
    clf : estimator instance
        Fitted classifier.

    predictions : array-like, shape (n_samples, n_classes) or (n_samples, 1) \
                    when binary.
        Raw predictions returned by the un-calibrated base classifier.

    y : array-like, shape (n_samples,)
        The targets.

    classes : ndarray, shape (n_classes,)
        All the prediction classes.

    method : {'sigmoid', 'isotonic'}
        The method to use for calibration.

    sample_weight : ndarray, shape (n_samples,), default=None
        Sample weights. If None, then samples are equally weighted.

    Returns
    -------
    pipeline : _CalibratedClassifier instance
    """</span>
    <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">label_binarize</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span>
    <span class="identifier">label_encoder</span> <span class="arithmetic-assignment">=</span> <span class="identifier">LabelEncoder</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span>
    <span class="identifier">pos_class_indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">label_encoder</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">clf</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span>
    <span class="identifier">calibrators</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
    <span class="keyword">for</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">d</span><span class="invalid">x</span><span class="punctuation">,</span> <span class="identifier">this_pred</span> <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">pos_class_indices</span><span class="punctuation">,</span> <span class="identifier">predictions</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">method</span> <span class="relational-operator">==</span> <span class="string-literal">'isotonic'</span><span class="punctuation">:</span>
            <span class="identifier">calibrator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">IsotonicRegression</span><span class="grouping">(</span><span class="identifier">out_of_bounds</span><span class="arithmetic-assignment">=</span><span class="string-literal">'clip'</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">method</span> <span class="relational-operator">==</span> <span class="string-literal">'sigmoid'</span><span class="punctuation">:</span>
            <span class="identifier">calibrator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_SigmoidCalibration</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"'method' should be one of: 'sigmoid' or "</span>
                             <span class="identifier">f</span><span class="string-literal">"'isotonic'. Got {method}."</span><span class="grouping">)</span>
        <span class="identifier">calibrator</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">this_pred</span><span class="punctuation">,</span> <span class="identifier">Y</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">d</span><span class="invalid">x</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="grouping">)</span>
        <span class="identifier">calibrators</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">calibrator</span><span class="grouping">)</span>

    <span class="identifier">pipeline</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_CalibratedClassifier</span><span class="grouping">(</span>
        <span class="identifier">clf</span><span class="punctuation">,</span> <span class="identifier">calibrators</span><span class="punctuation">,</span> <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="identifier">method</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span>
    <span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">pipeline</span>


<span class="keyword">class</span> <span class="identifier">_CalibratedClassifier</span><span class="punctuation">:</span>
    <span class="comment">"""Pipeline-like chaining a fitted classifier and its fitted calibrators.

    Parameters
    ----------
    base_estimator : estimator instance
        Fitted classifier.

    calibrators : list of fitted estimator instances
        List of fitted calibrators (either 'IsotonicRegression' or
        '_SigmoidCalibration'). The number of calibrators equals the number of
        classes. However, if there are 2 classes, the list contains only one
        fitted calibrator.

    classes : array-like of shape (n_classes,)
        All the prediction classes.

    method : {'sigmoid', 'isotonic'}, default='sigmoid'
        The method to use for calibration. Can be 'sigmoid' which
        corresponds to Platt's method or 'isotonic' which is a
        non-parametric approach based on isotonic regression.

    Attributes
    ----------
    calibrators_ : list of fitted estimator instances
        Same as `calibrators`. Exposed for backward-compatibility. Use
        `calibrators` instead.

        .. deprecated:: 0.24
           `calibrators_` is deprecated from 0.24 and will be removed in
           1.1 (renaming of 0.26). Use `calibrators` instead.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">base_estimator</span><span class="punctuation">,</span> <span class="identifier">calibrators</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="punctuation">,</span>
                 <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="string-literal">'sigmoid'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">base_estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">base_estimator</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">calibrators</span> <span class="arithmetic-assignment">=</span> <span class="identifier">calibrators</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span> <span class="arithmetic-assignment">=</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">method</span> <span class="arithmetic-assignment">=</span> <span class="identifier">method</span>

    <span class="comment"># TODO: Remove in 1.1</span>
    <span class="comment"># mypy error: Decorated property not supported</span>
    <span class="punctuation">@</span><span class="identifier">deprecated</span><span class="grouping">(</span>  <span class="comment"># type: ignore</span>
        <span class="string-literal">"calibrators_ is deprecated in 0.24 and will be removed in 1.1"</span>
        <span class="string-literal">"(renaming of 0.26). Use calibrators instead."</span>
    <span class="grouping">)</span>
    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">calibrators_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">calibrators</span>

    <span class="keyword">def</span> <span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Calculate calibrated probabilities.

        Calculates classification calibrated probabilities
        for each class, in a one-vs-all manner, for `X`.

        Parameters
        ----------
        X : ndarray of shape (n_samples, n_features)
            The sample data.

        Returns
        -------
        proba : array, shape (n_samples, n_classes)
            The predicted probabilities. Can be exact zeros.
        """</span>
        <span class="identifier">n_classes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span>
        <span class="identifier">pred_method</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_get_prediction_method</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">base_estimator</span><span class="grouping">)</span>
        <span class="identifier">predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_compute_predictions</span><span class="grouping">(</span><span class="identifier">pred_method</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">n_classes</span><span class="grouping">)</span>

        <span class="identifier">label_encoder</span> <span class="arithmetic-assignment">=</span> <span class="identifier">LabelEncoder</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span>
        <span class="identifier">pos_class_indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">label_encoder</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">base_estimator</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span>
        <span class="grouping">)</span>

        <span class="identifier">proba</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">n_classes</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">d</span><span class="invalid">x</span><span class="punctuation">,</span> <span class="identifier">this_pred</span><span class="punctuation">,</span> <span class="identifier">calibrator</span> <span class="relational-operator">in</span> <span class="invalid">\</span>
                <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">pos_class_indices</span><span class="punctuation">,</span> <span class="identifier">predictions</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">calibrators</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">n_classes</span> <span class="relational-operator">==</span> <span class="int-literal">2</span><span class="punctuation">:</span>
                <span class="comment"># When binary, `predictions` consists only of predictions for</span>
                <span class="comment"># clf.classes_[1] but `pos_class_indices` = 0</span>
                <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">d</span><span class="invalid">x</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">1</span>
            <span class="identifier">proba</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">d</span><span class="invalid">x</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">calibrator</span><span class="punctuation">.</span><span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">this_pred</span><span class="grouping">)</span>

        <span class="comment"># Normalize the probabilities</span>
        <span class="keyword">if</span> <span class="identifier">n_classes</span> <span class="relational-operator">==</span> <span class="int-literal">2</span><span class="punctuation">:</span>
            <span class="identifier">proba</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">-</span> <span class="identifier">proba</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">]</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">denominator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">proba</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
            <span class="comment"># In the edge case where for each class calibrator returns a null</span>
            <span class="comment"># probability for a given sample, use the uniform distribution</span>
            <span class="comment"># instead.</span>
            <span class="identifier">uniform_proba</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">full_like</span><span class="grouping">(</span><span class="identifier">proba</span><span class="punctuation">,</span> <span class="int-literal">1</span> <span class="arithmetic-operator">/</span> <span class="identifier">n_classes</span><span class="grouping">)</span>
            <span class="identifier">proba</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">divide</span><span class="grouping">(</span><span class="identifier">proba</span><span class="punctuation">,</span> <span class="identifier">denominator</span><span class="punctuation">,</span> <span class="identifier">out</span><span class="arithmetic-assignment">=</span><span class="identifier">uniform_proba</span><span class="punctuation">,</span>
                              <span class="identifier">where</span><span class="arithmetic-assignment">=</span><span class="identifier">denominator</span> <span class="relational-operator">!=</span> <span class="int-literal">0</span><span class="grouping">)</span>

        <span class="comment"># Deal with cases where the predicted probability minimally exceeds 1.0</span>
        <span class="identifier">proba</span><span class="grouping">[</span><span class="grouping">(</span><span class="float-literal">1.0</span> <span class="relational-operator">&lt;</span> <span class="identifier">proba</span><span class="grouping">)</span> <span class="bitwise-operator">&</span> <span class="grouping">(</span><span class="identifier">proba</span> <span class="relational-operator">&lt;=</span> <span class="float-literal">1.0</span> <span class="arithmetic-operator">+</span> <span class="float-literal">1e-5</span><span class="grouping">)</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="float-literal">1.0</span>

        <span class="keyword">return</span> <span class="identifier">proba</span>


<span class="keyword">def</span> <span class="identifier">_sigmoid_calibration</span><span class="grouping">(</span><span class="identifier">predictions</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Probability Calibration with sigmoid method (Platt 2000)

    Parameters
    ----------
    predictions : ndarray of shape (n_samples,)
        The decision function or predict proba for the samples.

    y : ndarray of shape (n_samples,)
        The targets.

    sample_weight : array-like of shape (n_samples,), default=None
        Sample weights. If None, then samples are equally weighted.

    Returns
    -------
    a : float
        The slope.

    b : float
        The intercept.

    References
    ----------
    Platt, "Probabilistic Outputs for Support Vector Machines"
    """</span>
    <span class="identifier">predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">predictions</span><span class="grouping">)</span>
    <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>

    <span class="identifier">F</span> <span class="arithmetic-assignment">=</span> <span class="identifier">predictions</span>  <span class="comment"># F follows Platt's notations</span>

    <span class="comment"># Bayesian priors (see Platt end of section 2.2)</span>
    <span class="identifier">prior0</span> <span class="arithmetic-assignment">=</span> <span class="identifier">float</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">y</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="identifier">prior1</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-operator">-</span> <span class="identifier">prior0</span>
    <span class="identifier">T</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span>
    <span class="identifier">T</span><span class="grouping">[</span><span class="identifier">y</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">prior1</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">.</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">prior1</span> <span class="arithmetic-operator">+</span> <span class="int-literal">2</span><span class="punctuation">.</span><span class="grouping">)</span>
    <span class="identifier">T</span><span class="grouping">[</span><span class="identifier">y</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">prior0</span> <span class="arithmetic-operator">+</span> <span class="int-literal">2</span><span class="punctuation">.</span><span class="grouping">)</span>
    <span class="identifier">T1</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">-</span> <span class="identifier">T</span>

    <span class="keyword">def</span> <span class="identifier">objective</span><span class="grouping">(</span><span class="identifier">AB</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># From Platt (beginning of Section 2.2)</span>
        <span class="identifier">P</span> <span class="arithmetic-assignment">=</span> <span class="identifier">expit</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="grouping">(</span><span class="identifier">AB</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">F</span> <span class="arithmetic-operator">+</span> <span class="identifier">AB</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">loss</span> <span class="arithmetic-assignment">=</span> <span class="arithmetic-operator">-</span><span class="grouping">(</span><span class="identifier">xlogy</span><span class="grouping">(</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">P</span><span class="grouping">)</span> <span class="arithmetic-operator">+</span> <span class="identifier">xlogy</span><span class="grouping">(</span><span class="identifier">T1</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">-</span> <span class="identifier">P</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="grouping">(</span><span class="identifier">sample_weight</span> <span class="arithmetic-operator">*</span> <span class="identifier">loss</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">loss</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">grad</span><span class="grouping">(</span><span class="identifier">AB</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># gradient of the objective function</span>
        <span class="identifier">P</span> <span class="arithmetic-assignment">=</span> <span class="identifier">expit</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="grouping">(</span><span class="identifier">AB</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">F</span> <span class="arithmetic-operator">+</span> <span class="identifier">AB</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">TEP_minus_T1P</span> <span class="arithmetic-assignment">=</span> <span class="identifier">T</span> <span class="arithmetic-operator">-</span> <span class="identifier">P</span>
        <span class="keyword">if</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">TEP_minus_T1P</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">sample_weight</span>
        <span class="identifier">dA</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">TEP_minus_T1P</span><span class="punctuation">,</span> <span class="identifier">F</span><span class="grouping">)</span>
        <span class="identifier">dB</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">TEP_minus_T1P</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">dA</span><span class="punctuation">,</span> <span class="identifier">dB</span><span class="grouping">]</span><span class="grouping">)</span>

    <span class="identifier">AB0</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span><span class="int-literal">0</span><span class="punctuation">.</span><span class="punctuation">,</span> <span class="identifier">log</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">prior0</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">.</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">prior1</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">.</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">]</span><span class="grouping">)</span>
    <span class="identifier">AB_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fmin_bfgs</span><span class="grouping">(</span><span class="identifier">objective</span><span class="punctuation">,</span> <span class="identifier">AB0</span><span class="punctuation">,</span> <span class="identifier">fprime</span><span class="arithmetic-assignment">=</span><span class="identifier">grad</span><span class="punctuation">,</span> <span class="identifier">disp</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">AB_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">AB_</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>


<span class="keyword">class</span> <span class="identifier">_SigmoidCalibration</span><span class="grouping">(</span><span class="identifier">RegressorMixin</span><span class="punctuation">,</span> <span class="identifier">BaseEstimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Sigmoid regression model.

    Attributes
    ----------
    a_ : float
        The slope.

    b_ : float
        The intercept.
    """</span>
    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the model using X, y as training data.

        Parameters
        ----------
        X : array-like of shape (n_samples,)
            Training data.

        y : array-like of shape (n_samples,)
            Training target.

        sample_weight : array-like of shape (n_samples,), default=None
            Sample weights. If None, then samples are equally weighted.

        Returns
        -------
        self : object
            Returns an instance of self.
        """</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">indexable</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">a_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">b_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_sigmoid_calibration</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">T</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Predict new data by linear interpolation.

        Parameters
        ----------
        T : array-like of shape (n_samples,)
            Data to predict from.

        Returns
        -------
        T_ : ndarray of shape (n_samples,)
            The predicted data.
        """</span>
        <span class="identifier">T</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">T</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">expit</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">a_</span> <span class="arithmetic-operator">*</span> <span class="identifier">T</span> <span class="arithmetic-operator">+</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">b_</span><span class="grouping">)</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">calibration_curve</span><span class="grouping">(</span><span class="identifier">y_true</span><span class="punctuation">,</span> <span class="identifier">y_prob</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">n_bins</span><span class="arithmetic-assignment">=</span><span class="int-literal">5</span><span class="punctuation">,</span>
                      <span class="identifier">strategy</span><span class="arithmetic-assignment">=</span><span class="string-literal">'uniform'</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Compute true and predicted probabilities for a calibration curve.

    The method assumes the inputs come from a binary classifier, and
    discretize the [0, 1] interval into bins.

    Calibration curves may also be referred to as reliability diagrams.

    Read more in the :ref:`User Guide &lt;calibration&gt;`.

    Parameters
    ----------
    y_true : array-like of shape (n_samples,)
        True targets.

    y_prob : array-like of shape (n_samples,)
        Probabilities of the positive class.

    normalize : bool, default=False
        Whether y_prob needs to be normalized into the [0, 1] interval, i.e.
        is not a proper probability. If True, the smallest value in y_prob
        is linearly mapped onto 0 and the largest one onto 1.

    n_bins : int, default=5
        Number of bins to discretize the [0, 1] interval. A bigger number
        requires more data. Bins with no samples (i.e. without
        corresponding values in `y_prob`) will not be returned, thus the
        returned arrays may have less than `n_bins` values.

    strategy : {'uniform', 'quantile'}, default='uniform'
        Strategy used to define the widths of the bins.

        uniform
            The bins have identical widths.
        quantile
            The bins have the same number of samples and depend on `y_prob`.

    Returns
    -------
    prob_true : ndarray of shape (n_bins,) or smaller
        The proportion of samples whose class is the positive class, in each
        bin (fraction of positives).

    prob_pred : ndarray of shape (n_bins,) or smaller
        The mean predicted probability in each bin.

    References
    ----------
    Alexandru Niculescu-Mizil and Rich Caruana (2005) Predicting Good
    Probabilities With Supervised Learning, in Proceedings of the 22nd
    International Conference on Machine Learning (ICML).
    See section 4 (Qualitative Analysis of Predictions).

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.calibration import calibration_curve
    &gt;&gt;&gt; y_true = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1])
    &gt;&gt;&gt; y_pred = np.array([0.1, 0.2, 0.3, 0.4, 0.65, 0.7, 0.8, 0.9,  1.])
    &gt;&gt;&gt; prob_true, prob_pred = calibration_curve(y_true, y_pred, n_bins=3)
    &gt;&gt;&gt; prob_true
    array([0. , 0.5, 1. ])
    &gt;&gt;&gt; prob_pred
    array([0.2  , 0.525, 0.85 ])
    """</span>
    <span class="identifier">y_true</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">y_true</span><span class="grouping">)</span>
    <span class="identifier">y_prob</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">y_prob</span><span class="grouping">)</span>
    <span class="identifier">check_consistent_length</span><span class="grouping">(</span><span class="identifier">y_true</span><span class="punctuation">,</span> <span class="identifier">y_prob</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">normalize</span><span class="punctuation">:</span>  <span class="comment"># Normalize predicted values into interval [0, 1]</span>
        <span class="identifier">y_prob</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">y_prob</span> <span class="arithmetic-operator">-</span> <span class="identifier">y_prob</span><span class="punctuation">.</span><span class="identifier">min</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">y_prob</span><span class="punctuation">.</span><span class="identifier">max</span><span class="grouping">(</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">y_prob</span><span class="punctuation">.</span><span class="identifier">min</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">elif</span> <span class="identifier">y_prob</span><span class="punctuation">.</span><span class="identifier">min</span><span class="grouping">(</span><span class="grouping">)</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span> <span class="logical-operator">or</span> <span class="identifier">y_prob</span><span class="punctuation">.</span><span class="identifier">max</span><span class="grouping">(</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"y_prob has values outside [0, 1] and normalize is "</span>
                         <span class="string-literal">"set to False."</span><span class="grouping">)</span>

    <span class="identifier">labels</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">y_true</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">labels</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="int-literal">2</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Only binary classification is supported. "</span>
                         <span class="string-literal">"Provided labels %s."</span> <span class="arithmetic-operator">%</span> <span class="identifier">labels</span><span class="grouping">)</span>
    <span class="identifier">y_true</span> <span class="arithmetic-assignment">=</span> <span class="identifier">label_binarize</span><span class="grouping">(</span><span class="identifier">y_true</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="identifier">labels</span><span class="grouping">)</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">]</span>

    <span class="keyword">if</span> <span class="identifier">strategy</span> <span class="relational-operator">==</span> <span class="string-literal">'quantile'</span><span class="punctuation">:</span>  <span class="comment"># Determine bin edges by distribution of data</span>
        <span class="identifier">quantiles</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">linspace</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">n_bins</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span>
        <span class="identifier">bins</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">percentile</span><span class="grouping">(</span><span class="identifier">y_prob</span><span class="punctuation">,</span> <span class="identifier">quantiles</span> <span class="arithmetic-operator">*</span> <span class="int-literal">100</span><span class="grouping">)</span>
        <span class="identifier">bins</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">bins</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-operator">+</span> <span class="float-literal">1e-8</span>
    <span class="keyword">elif</span> <span class="identifier">strategy</span> <span class="relational-operator">==</span> <span class="string-literal">'uniform'</span><span class="punctuation">:</span>
        <span class="identifier">bins</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">linspace</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">.</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">+</span> <span class="float-literal">1e-8</span><span class="punctuation">,</span> <span class="identifier">n_bins</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Invalid entry to 'strategy' input. Strategy "</span>
                         <span class="string-literal">"must be either 'quantile' or 'uniform'."</span><span class="grouping">)</span>

    <span class="identifier">binids</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">digitize</span><span class="grouping">(</span><span class="identifier">y_prob</span><span class="punctuation">,</span> <span class="identifier">bins</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span>

    <span class="identifier">bin_sums</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">bincount</span><span class="grouping">(</span><span class="identifier">binids</span><span class="punctuation">,</span> <span class="identifier">weights</span><span class="arithmetic-assignment">=</span><span class="identifier">y_prob</span><span class="punctuation">,</span> <span class="identifier">minlength</span><span class="arithmetic-assignment">=</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">bins</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="identifier">bin_true</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">bincount</span><span class="grouping">(</span><span class="identifier">binids</span><span class="punctuation">,</span> <span class="identifier">weights</span><span class="arithmetic-assignment">=</span><span class="identifier">y_true</span><span class="punctuation">,</span> <span class="identifier">minlength</span><span class="arithmetic-assignment">=</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">bins</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="identifier">bin_total</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">bincount</span><span class="grouping">(</span><span class="identifier">binids</span><span class="punctuation">,</span> <span class="identifier">minlength</span><span class="arithmetic-assignment">=</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">bins</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="identifier">nonzero</span> <span class="arithmetic-assignment">=</span> <span class="identifier">bin_total</span> <span class="relational-operator">!=</span> <span class="int-literal">0</span>
    <span class="identifier">prob_true</span> <span class="arithmetic-assignment">=</span> <span class="identifier">bin_true</span><span class="grouping">[</span><span class="identifier">nonzero</span><span class="grouping">]</span> <span class="arithmetic-operator">/</span> <span class="identifier">bin_total</span><span class="grouping">[</span><span class="identifier">nonzero</span><span class="grouping">]</span>
    <span class="identifier">prob_pred</span> <span class="arithmetic-assignment">=</span> <span class="identifier">bin_sums</span><span class="grouping">[</span><span class="identifier">nonzero</span><span class="grouping">]</span> <span class="arithmetic-operator">/</span> <span class="identifier">bin_total</span><span class="grouping">[</span><span class="identifier">nonzero</span><span class="grouping">]</span>

    <span class="keyword">return</span> <span class="identifier">prob_true</span><span class="punctuation">,</span> <span class="identifier">prob_pred</span>

    </pre>
  </body>
</html>