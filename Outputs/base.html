<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""Base classes for all estimators."""</span>

<span class="comment"># Author: Gael Varoquaux &lt;gael.varoquaux@normalesup.org&gt;</span>
<span class="comment"># License: BSD 3 clause</span>

<span class="keyword">import</span> <span class="identifier">copy</span>
<span class="keyword">import</span> <span class="identifier">warnings</span>
<span class="keyword">from</span> <span class="identifier">collections</span> <span class="keyword">import</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">d</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">t</span>
<span class="keyword">import</span> <span class="identifier">platform</span>
<span class="keyword">import</span> <span class="identifier">inspect</span>
<span class="keyword">import</span> <span class="identifier">re</span>

<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>

<span class="keyword">from</span> <span class="punctuation">.</span> <span class="keyword">import</span> <span class="identifier">__version__</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_config</span> <span class="keyword">import</span> <span class="identifier">get_config</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">_IS_32BIT</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">_tags</span> <span class="keyword">import</span> <span class="grouping">(</span>
    <span class="identifier">_DEFAULT_TAGS</span><span class="punctuation">,</span>
    <span class="identifier">_safe_tags</span><span class="punctuation">,</span>
<span class="grouping">)</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_X_y</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_array</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">_num_features</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">_estimator_html_repr</span> <span class="keyword">import</span> <span class="identifier">estimator_html_repr</span>


<span class="keyword">def</span> <span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">safe</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Constructs a new unfitted estimator with the same parameters.

    Clone does a deep copy of the model in an estimator
    without actually copying attached data. It yields a new estimator
    with the same parameters that has not been fitted on any data.

    If the estimator's `random_state` parameter is an integer (or if the
    estimator doesn't have a `random_state` parameter), an *exact clone* is
    returned: the clone and the original estimator will give the exact same
    results. Otherwise, *statistical clone* is returned: the clone might
    yield different results from the original estimator. More details can be
    found in :ref:`randomness`.

    Parameters
    ----------
    estimator : {list, tuple, set} of estimator instance or a single \
            estimator instance
        The estimator or group of estimators to be cloned.

    safe : bool, default=True
        If safe is False, clone will fall back to a deep copy on objects
        that are not estimators.

    """</span>
    <span class="identifier">estimator_type</span> <span class="arithmetic-assignment">=</span> <span class="identifier">type</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="grouping">)</span>
    <span class="comment"># XXX: not handling dictionaries</span>
    <span class="keyword">if</span> <span class="identifier">estimator_type</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="identifier">list</span><span class="punctuation">,</span> <span class="identifier">tuple</span><span class="punctuation">,</span> <span class="identifier">set</span><span class="punctuation">,</span> <span class="identifier">frozenset</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">estimator_type</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">e</span><span class="punctuation">,</span> <span class="identifier">safe</span><span class="arithmetic-assignment">=</span><span class="identifier">safe</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">e</span> <span class="relational-operator">in</span> <span class="identifier">estimator</span><span class="grouping">]</span><span class="grouping">)</span>
    <span class="keyword">elif</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="string-literal">'get_params'</span><span class="grouping">)</span> <span class="logical-operator">or</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">type</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">safe</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">copy</span><span class="punctuation">.</span><span class="identifier">deepcopy</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">type</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">"Cannot clone object. "</span> <span class="arithmetic-operator">+</span>
                                <span class="string-literal">"You should provide an instance of "</span> <span class="arithmetic-operator">+</span>
                                <span class="string-literal">"scikit-learn estimator instead of a class."</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">"Cannot clone object '%s' (type %s): "</span>
                                <span class="string-literal">"it does not seem to be a scikit-learn "</span>
                                <span class="string-literal">"estimator as it does not implement a "</span>
                                <span class="string-literal">"'get_params' method."</span>
                                <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">repr</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">type</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="identifier">klass</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">__class__</span>
    <span class="identifier">new_object_params</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">get_params</span><span class="grouping">(</span><span class="identifier">deep</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
    <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">param</span> <span class="relational-operator">in</span> <span class="identifier">new_object_params</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">new_object_params</span><span class="grouping">[</span><span class="identifier">name</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">param</span><span class="punctuation">,</span> <span class="identifier">safe</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
    <span class="identifier">new_object</span> <span class="arithmetic-assignment">=</span> <span class="identifier">klass</span><span class="grouping">(</span><span class="arithmetic-operator">**</span><span class="identifier">new_object_params</span><span class="grouping">)</span>
    <span class="identifier">params_set</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_object</span><span class="punctuation">.</span><span class="identifier">get_params</span><span class="grouping">(</span><span class="identifier">deep</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="comment"># quick sanity check of the parameters of the clone</span>
    <span class="keyword">for</span> <span class="identifier">name</span> <span class="relational-operator">in</span> <span class="identifier">new_object_params</span><span class="punctuation">:</span>
        <span class="identifier">param1</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_object_params</span><span class="grouping">[</span><span class="identifier">name</span><span class="grouping">]</span>
        <span class="identifier">param2</span> <span class="arithmetic-assignment">=</span> <span class="identifier">params_set</span><span class="grouping">[</span><span class="identifier">name</span><span class="grouping">]</span>
        <span class="keyword">if</span> <span class="identifier">param1</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="identifier">param2</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">RuntimeError</span><span class="grouping">(</span><span class="string-literal">'Cannot clone object %s, as the constructor '</span>
                               <span class="string-literal">'either does not set or modifies parameter %s'</span> <span class="arithmetic-operator">%</span>
                               <span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">name</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">new_object</span>


<span class="keyword">def</span> <span class="identifier">_pprint</span><span class="grouping">(</span><span class="identifier">params</span><span class="punctuation">,</span> <span class="identifier">offset</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">printer</span><span class="arithmetic-assignment">=</span><span class="identifier">repr</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Pretty print the dictionary 'params'

    Parameters
    ----------
    params : dict
        The dictionary to pretty print

    offset : int, default=0
        The offset in characters to add at the begin of each line.

    printer : callable, default=repr
        The function to convert entries to strings, typically
        the builtin str or repr

    """</span>
    <span class="comment"># Do a multi-line justified repr:</span>
    <span class="identifier">options</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">get_printoptions</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">set_printoptions</span><span class="grouping">(</span><span class="identifier">precision</span><span class="arithmetic-assignment">=</span><span class="int-literal">5</span><span class="punctuation">,</span> <span class="identifier">threshold</span><span class="arithmetic-assignment">=</span><span class="int-literal">64</span><span class="punctuation">,</span> <span class="identifier">edgeitems</span><span class="arithmetic-assignment">=</span><span class="int-literal">2</span><span class="grouping">)</span>
    <span class="identifier">params_list</span> <span class="arithmetic-assignment">=</span> <span class="identifier">list</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="identifier">this_line_length</span> <span class="arithmetic-assignment">=</span> <span class="identifier">offset</span>
    <span class="identifier">line_sep</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">',\n' + (1 + offset // 2) * ' '</span>
    <span class="keyword">for</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">k</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="grouping">)</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">sorted</span><span class="grouping">(</span><span class="identifier">params</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">type</span><span class="grouping">(</span><span class="identifier">v</span><span class="grouping">)</span> <span class="relational-operator">is</span> <span class="identifier">float</span><span class="punctuation">:</span>
            <span class="comment"># use str for representing floating point numbers</span>
            <span class="comment"># this way we get consistent representation across</span>
            <span class="comment"># architectures and versions.</span>
            <span class="identifier">this_repr</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'%s=%s'</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">k</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">(</span><span class="identifier">v</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># use repr of the rest</span>
            <span class="identifier">this_repr</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'%s=%s'</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">k</span><span class="punctuation">,</span> <span class="identifier">printer</span><span class="grouping">(</span><span class="identifier">v</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">this_repr</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="int-literal">500</span><span class="punctuation">:</span>
            <span class="identifier">this_repr</span> <span class="arithmetic-assignment">=</span> <span class="identifier">this_repr</span><span class="grouping">[</span><span class="punctuation">:</span><span class="int-literal">300</span><span class="grouping">]</span> <span class="arithmetic-operator">+</span> <span class="string-literal">'...'</span> <span class="arithmetic-operator">+</span> <span class="identifier">this_repr</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">100</span><span class="punctuation">:</span><span class="grouping">]</span>
        <span class="keyword">if</span> <span class="identifier">i</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">this_line_length</span> <span class="arithmetic-operator">+</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">this_repr</span><span class="grouping">)</span> <span class="relational-operator">&gt;=</span> <span class="int-literal">75</span> <span class="logical-operator">or</span> <span class="string-literal">'\n'</span> <span class="relational-operator">in</span> <span class="identifier">this_repr</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">params_list</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">line_sep</span><span class="grouping">)</span>
                <span class="identifier">this_line_length</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">line_sep</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">params_list</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="string-literal">', '</span><span class="grouping">)</span>
                <span class="identifier">this_line_length</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">2</span>
        <span class="identifier">params_list</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">this_repr</span><span class="grouping">)</span>
        <span class="identifier">this_line_length</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">this_repr</span><span class="grouping">)</span>

    <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">set_printoptions</span><span class="grouping">(</span><span class="arithmetic-operator">**</span><span class="identifier">options</span><span class="grouping">)</span>
    <span class="identifier">lines</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">''</span><span class="punctuation">.</span><span class="identifier">join</span><span class="grouping">(</span><span class="identifier">params_list</span><span class="grouping">)</span>
    <span class="comment"># Strip trailing space to avoid nightmare in doctests</span>
    <span class="identifier">lines</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'\n'.join(l.rstrip(' ') for l in lines.split('\n'</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">lines</span>


<span class="keyword">class</span> <span class="identifier">BaseEstimator</span><span class="punctuation">:</span>
    <span class="comment">"""Base class for all estimators in scikit-learn.

    Notes
    -----
    All estimators should specify all the parameters that can be set
    at the class level in their ``__init__`` as explicit keyword
    arguments (no ``*args`` or ``**kwargs``).
    """</span>

    <span class="punctuation">@</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span>
    <span class="keyword">def</span> <span class="identifier">_get_param_names</span><span class="grouping">(</span><span class="identifier">cls</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Get parameter names for the estimator"""</span>
        <span class="comment"># fetch the constructor or the original constructor before</span>
        <span class="comment"># deprecation wrapping if any</span>
        <span class="identifier">init</span> <span class="arithmetic-assignment">=</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">cls</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="punctuation">,</span> <span class="string-literal">'deprecated_original'</span><span class="punctuation">,</span> <span class="identifier">cls</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">init</span> <span class="relational-operator">is</span> <span class="identifier">object</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="punctuation">:</span>
            <span class="comment"># No explicit constructor to introspect</span>
            <span class="keyword">return</span> <span class="grouping">[</span><span class="grouping">]</span>

        <span class="comment"># introspect the constructor arguments to find the model parameters</span>
        <span class="comment"># to represent</span>
        <span class="identifier">init_signature</span> <span class="arithmetic-assignment">=</span> <span class="identifier">inspect</span><span class="punctuation">.</span><span class="identifier">signature</span><span class="grouping">(</span><span class="identifier">init</span><span class="grouping">)</span>
        <span class="comment"># Consider the constructor parameters excluding 'self'</span>
        <span class="identifier">parameters</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">p</span> <span class="keyword">for</span> <span class="identifier">p</span> <span class="relational-operator">in</span> <span class="identifier">init_signature</span><span class="punctuation">.</span><span class="identifier">parameters</span><span class="punctuation">.</span><span class="identifier">values</span><span class="grouping">(</span><span class="grouping">)</span>
                      <span class="keyword">if</span> <span class="identifier">p</span><span class="punctuation">.</span><span class="identifier">name</span> <span class="relational-operator">!=</span> <span class="string-literal">'self'</span> <span class="logical-operator">and</span> <span class="identifier">p</span><span class="punctuation">.</span><span class="identifier">kind</span> <span class="relational-operator">!=</span> <span class="identifier">p</span><span class="punctuation">.</span><span class="identifier">VAR_KEYWORD</span><span class="grouping">]</span>
        <span class="keyword">for</span> <span class="identifier">p</span> <span class="relational-operator">in</span> <span class="identifier">parameters</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">p</span><span class="punctuation">.</span><span class="identifier">kind</span> <span class="relational-operator">==</span> <span class="identifier">p</span><span class="punctuation">.</span><span class="identifier">VAR_POSITIONAL</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">RuntimeError</span><span class="grouping">(</span><span class="string-literal">"scikit-learn estimators should always "</span>
                                   <span class="string-literal">"specify their parameters in the signature"</span>
                                   <span class="string-literal">" of their __init__ (no varargs)."</span>
                                   <span class="string-literal">" %s with constructor %s doesn't "</span>
                                   <span class="string-literal">" follow this convention."</span>
                                   <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">cls</span><span class="punctuation">,</span> <span class="identifier">init_signature</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="comment"># Extract and sort argument names excluding 'self'</span>
        <span class="keyword">return</span> <span class="identifier">sorted</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">p</span><span class="punctuation">.</span><span class="identifier">name</span> <span class="keyword">for</span> <span class="identifier">p</span> <span class="relational-operator">in</span> <span class="identifier">parameters</span><span class="grouping">]</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">get_params</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">deep</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Get parameters for this estimator.

        Parameters
        ----------
        deep : bool, default=True
            If True, will return the parameters for this estimator and
            contained subobjects that are estimators.

        Returns
        -------
        params : dict
            Parameter names mapped to their values.
        """</span>
        <span class="identifier">out</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dict</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">key</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_get_param_names</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">value</span> <span class="arithmetic-assignment">=</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">key</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">deep</span> <span class="logical-operator">and</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">value</span><span class="punctuation">,</span> <span class="string-literal">'get_params'</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">deep_items</span> <span class="arithmetic-assignment">=</span> <span class="identifier">value</span><span class="punctuation">.</span><span class="identifier">get_params</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span>
                <span class="identifier">out</span><span class="punctuation">.</span><span class="identifier">update</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">key</span> <span class="arithmetic-operator">+</span> <span class="string-literal">'__'</span> <span class="arithmetic-operator">+</span> <span class="identifier">k</span><span class="punctuation">,</span> <span class="identifier">val</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">k</span><span class="punctuation">,</span> <span class="identifier">val</span> <span class="relational-operator">in</span> <span class="identifier">deep_items</span><span class="grouping">)</span>
            <span class="identifier">out</span><span class="grouping">[</span><span class="identifier">key</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">value</span>
        <span class="keyword">return</span> <span class="identifier">out</span>

    <span class="keyword">def</span> <span class="identifier">set_params</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">params</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Set the parameters of this estimator.

        The method works on simple estimators as well as on nested objects
        (such as :class:`~sklearn.pipeline.Pipeline`). The latter have
        parameters of the form ``&lt;component&gt;__&lt;parameter&gt;`` so that it's
        possible to update each component of a nested object.

        Parameters
        ----------
        **params : dict
            Estimator parameters.

        Returns
        -------
        self : estimator instance
            Estimator instance.
        """</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">params</span><span class="punctuation">:</span>
            <span class="comment"># Simple optimization to gain speed (inspect is slow)</span>
            <span class="keyword">return</span> <span class="identifier">self</span>
        <span class="identifier">valid_params</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">get_params</span><span class="grouping">(</span><span class="identifier">deep</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

        <span class="identifier">nested_params</span> <span class="arithmetic-assignment">=</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">d</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">dict</span><span class="grouping">)</span>  <span class="comment"># grouped by prefix</span>
        <span class="keyword">for</span> <span class="identifier">key</span><span class="punctuation">,</span> <span class="identifier">value</span> <span class="relational-operator">in</span> <span class="identifier">params</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">key</span><span class="punctuation">,</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">i</span><span class="invalid">m</span><span class="punctuation">,</span> <span class="identifier">sub_key</span> <span class="arithmetic-assignment">=</span> <span class="identifier">key</span><span class="punctuation">.</span><span class="identifier">partition</span><span class="grouping">(</span><span class="string-literal">'__'</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">key</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="identifier">valid_params</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'Invalid parameter %s for estimator %s. '</span>
                                 <span class="string-literal">'Check the list of available parameters '</span>
                                 <span class="string-literal">'with `estimator.get_params().keys()`.'</span> <span class="arithmetic-operator">%</span>
                                 <span class="grouping">(</span><span class="identifier">key</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="grouping">)</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">i</span><span class="invalid">m</span><span class="punctuation">:</span>
                <span class="identifier">nested_params</span><span class="grouping">[</span><span class="identifier">key</span><span class="grouping">]</span><span class="grouping">[</span><span class="identifier">sub_key</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">value</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">setattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">key</span><span class="punctuation">,</span> <span class="identifier">value</span><span class="grouping">)</span>
                <span class="identifier">valid_params</span><span class="grouping">[</span><span class="identifier">key</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">value</span>

        <span class="keyword">for</span> <span class="identifier">key</span><span class="punctuation">,</span> <span class="identifier">sub_params</span> <span class="relational-operator">in</span> <span class="identifier">nested_params</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">valid_params</span><span class="grouping">[</span><span class="identifier">key</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">set_params</span><span class="grouping">(</span><span class="arithmetic-operator">**</span><span class="identifier">sub_params</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">__repr__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">N_CHAR_MAX</span><span class="arithmetic-assignment">=</span><span class="int-literal">700</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># N_CHAR_MAX is the (approximate) maximum number of non-blank</span>
        <span class="comment"># characters to render. We pass it as an optional parameter to ease</span>
        <span class="comment"># the tests.</span>

        <span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">_pprint</span> <span class="keyword">import</span> <span class="identifier">_EstimatorPrettyPrinter</span>

        <span class="identifier">N_MAX_ELEMENTS_TO_SHOW</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">30</span>  <span class="comment"># number of elements to show in sequences</span>

        <span class="comment"># use ellipsis for sequences with a lot of elements</span>
        <span class="identifier">pp</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_EstimatorPrettyPrinter</span><span class="grouping">(</span>
            <span class="identifier">compact</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">indent</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">indent_at_name</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
            <span class="identifier">n_max_elements_to_show</span><span class="arithmetic-assignment">=</span><span class="identifier">N_MAX_ELEMENTS_TO_SHOW</span><span class="grouping">)</span>

        <span class="identifier">repr_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">pp</span><span class="punctuation">.</span><span class="identifier">pformat</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="comment"># Use bruteforce ellipsis when there are a lot of non-blank characters</span>
        <span class="identifier">n_nonblank</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="string-literal">''</span><span class="punctuation">.</span><span class="identifier">join</span><span class="grouping">(</span><span class="identifier">repr_</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">n_nonblank</span> <span class="relational-operator">&gt;</span> <span class="identifier">N_CHAR_MAX</span><span class="punctuation">:</span>
            <span class="identifier">lim</span> <span class="arithmetic-assignment">=</span> <span class="identifier">N_CHAR_MAX</span> <span class="arithmetic-operator">//</span> <span class="int-literal">2</span>  <span class="comment"># apprx number of chars to keep on both ends</span>
            <span class="identifier">regex</span> <span class="arithmetic-assignment">=</span> <span class="identifier">r</span><span class="string-literal">'^(\s*\S){%d}'</span> <span class="arithmetic-operator">%</span> <span class="identifier">lim</span>
            <span class="comment"># The regex '^(\s*\S){%d}' % n</span>
            <span class="comment"># matches from the start of the string until the nth non-blank</span>
            <span class="comment"># character:</span>
            <span class="comment"># - ^ matches the start of string</span>
            <span class="comment"># - (pattern){n} matches n repetitions of pattern</span>
            <span class="comment"># - \s*\S matches a non-blank char following zero or more blanks</span>
            <span class="identifier">left_lim</span> <span class="arithmetic-assignment">=</span> <span class="identifier">re</span><span class="punctuation">.</span><span class="identifier">match</span><span class="grouping">(</span><span class="identifier">regex</span><span class="punctuation">,</span> <span class="identifier">repr_</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">end</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="identifier">right_lim</span> <span class="arithmetic-assignment">=</span> <span class="identifier">re</span><span class="punctuation">.</span><span class="identifier">match</span><span class="grouping">(</span><span class="identifier">regex</span><span class="punctuation">,</span> <span class="identifier">repr_</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">end</span><span class="grouping">(</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="string-literal">'\n'</span> <span class="relational-operator">in</span> <span class="identifier">repr_</span><span class="grouping">[</span><span class="identifier">left_lim</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="identifier">right_lim</span><span class="grouping">]</span><span class="punctuation">:</span>
                <span class="comment"># The left side and right side aren't on the same line.</span>
                <span class="comment"># To avoid weird cuts, e.g.:</span>
                <span class="comment"># categoric...ore',</span>
                <span class="comment"># we need to start the right side with an appropriate newline</span>
                <span class="comment"># character so that it renders properly as:</span>
                <span class="comment"># categoric...</span>
                <span class="comment"># handle_unknown='ignore',</span>
                <span class="comment"># so we add [^\n]*\n which matches until the next \n</span>
                <span class="identifier">regex</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">r</span><span class="string-literal">'[^\n]*\n'</span>
                <span class="identifier">right_lim</span> <span class="arithmetic-assignment">=</span> <span class="identifier">re</span><span class="punctuation">.</span><span class="identifier">match</span><span class="grouping">(</span><span class="identifier">regex</span><span class="punctuation">,</span> <span class="identifier">repr_</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">end</span><span class="grouping">(</span><span class="grouping">)</span>

            <span class="identifier">ellipsis</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'...'</span>
            <span class="keyword">if</span> <span class="identifier">left_lim</span> <span class="arithmetic-operator">+</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">ellipsis</span><span class="grouping">)</span> <span class="relational-operator">&lt;</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">repr_</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">right_lim</span><span class="punctuation">:</span>
                <span class="comment"># Only add ellipsis if it results in a shorter repr</span>
                <span class="identifier">repr_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">repr_</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">left_lim</span><span class="grouping">]</span> <span class="arithmetic-operator">+</span> <span class="string-literal">'...'</span> <span class="arithmetic-operator">+</span> <span class="identifier">repr_</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="identifier">right_lim</span><span class="punctuation">:</span><span class="grouping">]</span>

        <span class="keyword">return</span> <span class="identifier">repr_</span>

    <span class="keyword">def</span> <span class="identifier">__getstate__</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">try</span><span class="punctuation">:</span>
            <span class="identifier">state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__getstate__</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">except</span> <span class="identifier">AttributeError</span><span class="punctuation">:</span>
            <span class="identifier">state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__dict__</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">type</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__module__</span><span class="punctuation">.</span><span class="identifier">startswith</span><span class="grouping">(</span><span class="string-literal">'sklearn.'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">dict</span><span class="grouping">(</span><span class="identifier">state</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">_sklearn_version</span><span class="arithmetic-assignment">=</span><span class="identifier">__version__</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">state</span>

    <span class="keyword">def</span> <span class="identifier">__setstate__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">state</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">type</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__module__</span><span class="punctuation">.</span><span class="identifier">startswith</span><span class="grouping">(</span><span class="string-literal">'sklearn.'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">pickle_version</span> <span class="arithmetic-assignment">=</span> <span class="identifier">state</span><span class="punctuation">.</span><span class="identifier">pop</span><span class="grouping">(</span><span class="string-literal">"_sklearn_version", "pre-0.18"</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">pickle_version</span> <span class="relational-operator">!=</span> <span class="identifier">__version__</span><span class="punctuation">:</span>
                <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span>
                    <span class="string-literal">"Trying to unpickle estimator {0} from version {1} when "</span>
                    <span class="string-literal">"using version {2}. This might lead to breaking code or "</span>
                    <span class="string-literal">"invalid results. Use at your own risk."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span>
                        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__class__</span><span class="punctuation">.</span><span class="identifier">__name__</span><span class="punctuation">,</span> <span class="identifier">pickle_version</span><span class="punctuation">,</span> <span class="identifier">__version__</span><span class="grouping">)</span><span class="punctuation">,</span>
                    <span class="identifier">UserWarning</span><span class="grouping">)</span>
        <span class="keyword">try</span><span class="punctuation">:</span>
            <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__setstate__</span><span class="grouping">(</span><span class="identifier">state</span><span class="grouping">)</span>
        <span class="keyword">except</span> <span class="identifier">AttributeError</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__dict__</span><span class="punctuation">.</span><span class="identifier">update</span><span class="grouping">(</span><span class="identifier">state</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">_DEFAULT_TAGS</span>

    <span class="keyword">def</span> <span class="identifier">_get_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">collected_tags</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="grouping">}</span>
        <span class="keyword">for</span> <span class="identifier">base_class</span> <span class="relational-operator">in</span> <span class="identifier">reversed</span><span class="grouping">(</span><span class="identifier">inspect</span><span class="punctuation">.</span><span class="identifier">getmro</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__class__</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">base_class</span><span class="punctuation">,</span> <span class="string-literal">'_more_tags'</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="comment"># need the if because mixins might not have _more_tags</span>
                <span class="comment"># but might do redundant work in estimators</span>
                <span class="comment"># (i.e. calling more tags on BaseEstimator multiple times)</span>
                <span class="identifier">more_tags</span> <span class="arithmetic-assignment">=</span> <span class="identifier">base_class</span><span class="punctuation">.</span><span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
                <span class="identifier">collected_tags</span><span class="punctuation">.</span><span class="identifier">update</span><span class="grouping">(</span><span class="identifier">more_tags</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">collected_tags</span>

    <span class="keyword">def</span> <span class="identifier">_check_n_features</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">reset</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Set the `n_features_in_` attribute, or check against it.

        Parameters
        ----------
        X : {ndarray, sparse matrix} of shape (n_samples, n_features)
            The input samples.
        reset : bool
            If True, the `n_features_in_` attribute is set to `X.shape[1]`.
            If False and the attribute exists, then check that it is equal to
            `X.shape[1]`. If False and the attribute does *not* exist, then
            the check is skipped.
            .. note::
               It is recommended to call reset=True in `fit` and in the first
               call to `partial_fit`. All other methods that validate `X`
               should set `reset=False`.
        """</span>
        <span class="keyword">try</span><span class="punctuation">:</span>
            <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_num_features</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">except</span> <span class="identifier">TypeError</span> <span class="keyword">as</span> <span class="identifier">e</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">reset</span> <span class="logical-operator">and</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">"n_features_in_"</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                    <span class="string-literal">"X does not contain any features, but "</span>
                    <span class="identifier">f</span><span class="string-literal">"{self.__class__.__name__} is expecting "</span>
                    <span class="identifier">f</span><span class="string-literal">"{self.n_features_in_} features"</span>
                <span class="grouping">)</span> <span class="keyword">from</span> <span class="identifier">e</span>
            <span class="comment"># If the number of features is not defined and reset=True,</span>
            <span class="comment"># then we skip this check</span>
            <span class="keyword">return</span>

        <span class="keyword">if</span> <span class="identifier">reset</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_features_in_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_features</span>
            <span class="keyword">return</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">"n_features_in_"</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># Skip this check if the expected number of expected input features</span>
            <span class="comment"># was not recorded by calling fit first. This is typically the case</span>
            <span class="comment"># for stateless transformers.</span>
            <span class="keyword">return</span>

        <span class="keyword">if</span> <span class="identifier">n_features</span> <span class="relational-operator">!=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_features_in_</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="identifier">f</span><span class="string-literal">"X has {n_features} features, but {self.__class__.__name__} "</span>
                <span class="identifier">f</span><span class="string-literal">"is expecting {self.n_features_in_} features as input."</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="string-literal">'no_validation'</span><span class="punctuation">,</span> <span class="identifier">reset</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                       <span class="identifier">validate_separately</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">check_params</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Validate input data and set or check the `n_features_in_` attribute.

        Parameters
        ----------
        X : {array-like, sparse matrix, dataframe} of shape \
                (n_samples, n_features)
            The input samples.
        y : array-like of shape (n_samples,), default='no_validation'
            The targets.

            - If `None`, `check_array` is called on `X`. If the estimator's
              requires_y tag is True, then an error will be raised.
            - If `'no_validation'`, `check_array` is called on `X` and the
              estimator's requires_y tag is ignored. This is a default
              placeholder and is never meant to be explicitly set.
            - Otherwise, both `X` and `y` are checked with either `check_array`
              or `check_X_y` depending on `validate_separately`.

        reset : bool, default=True
            Whether to reset the `n_features_in_` attribute.
            If False, the input will be checked for consistency with data
            provided when reset was last True.
            .. note::
               It is recommended to call reset=True in `fit` and in the first
               call to `partial_fit`. All other methods that validate `X`
               should set `reset=False`.
        validate_separately : False or tuple of dicts, default=False
            Only used if y is not None.
            If False, call validate_X_y(). Else, it must be a tuple of kwargs
            to be used for calling check_array() on X and y respectively.
        **check_params : kwargs
            Parameters passed to :func:`sklearn.utils.check_array` or
            :func:`sklearn.utils.check_X_y`. Ignored if validate_separately
            is not False.

        Returns
        -------
        out : {ndarray, sparse matrix} or tuple of these
            The validated input. A tuple is returned if `y` is not None.
        """</span>

        <span class="keyword">if</span> <span class="identifier">y</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_get_tags</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">[</span><span class="string-literal">'requires_y'</span><span class="grouping">]</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                    <span class="identifier">f</span><span class="string-literal">"This {self.__class__.__name__} estimator "</span>
                    <span class="identifier">f</span><span class="string-literal">"requires y to be passed, but the target y is None."</span>
                <span class="grouping">)</span>
            <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">check_params</span><span class="grouping">)</span>
            <span class="identifier">out</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
        <span class="keyword">elif</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">y</span> <span class="relational-operator">==</span> <span class="string-literal">'no_validation'</span><span class="punctuation">:</span>
            <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">check_params</span><span class="grouping">)</span>
            <span class="identifier">out</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">validate_separately</span><span class="punctuation">:</span>
                <span class="comment"># We need this because some estimators validate X and y</span>
                <span class="comment"># separately, and in general, separately calling check_array()</span>
                <span class="comment"># on X and y isn't equivalent to just calling check_X_y()</span>
                <span class="comment"># :(</span>
                <span class="identifier">check_X_params</span><span class="punctuation">,</span> <span class="identifier">check_y_params</span> <span class="arithmetic-assignment">=</span> <span class="identifier">validate_separately</span>
                <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">check_X_params</span><span class="grouping">)</span>
                <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">check_y_params</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_X_y</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">check_params</span><span class="grouping">)</span>
            <span class="identifier">out</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span>

        <span class="keyword">if</span> <span class="identifier">check_params</span><span class="punctuation">.</span><span class="identifier">get</span><span class="grouping">(</span><span class="string-literal">'ensure_2d'</span><span class="punctuation">,</span> <span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_n_features</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">reset</span><span class="arithmetic-assignment">=</span><span class="identifier">reset</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">out</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">_repr_html_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""HTML representation of estimator.

        This is redundant with the logic of `_repr_mimebundle_`. The latter
        should be favorted in the long term, `_repr_html_` is only
        implemented for consumers who do not interpret `_repr_mimbundle_`.
        """</span>
        <span class="keyword">if</span> <span class="identifier">get_config</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">[</span><span class="string-literal">"display"</span><span class="grouping">]</span> <span class="relational-operator">!=</span> <span class="string-literal">'diagram'</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">AttributeError</span><span class="grouping">(</span><span class="string-literal">"_repr_html_ is only defined when the "</span>
                                 <span class="string-literal">"'display' configuration option is set to "</span>
                                 <span class="string-literal">"'diagram'"</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_repr_html_inner</span>

    <span class="keyword">def</span> <span class="identifier">_repr_html_inner</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""This function is returned by the @property `_repr_html_` to make
        `hasattr(estimator, "_repr_html_") return `True` or `False` depending
        on `get_config()["display"]`.
        """</span>
        <span class="keyword">return</span> <span class="identifier">estimator_html_repr</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_repr_mimebundle_</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">kwargs</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Mime bundle used by jupyter kernels to display estimator"""</span>
        <span class="identifier">output</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="string-literal">"text/plain"</span><span class="punctuation">:</span> <span class="identifier">repr</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="grouping">}</span>
        <span class="keyword">if</span> <span class="identifier">get_config</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">[</span><span class="string-literal">"display"</span><span class="grouping">]</span> <span class="relational-operator">==</span> <span class="string-literal">'diagram'</span><span class="punctuation">:</span>
            <span class="identifier">output</span><span class="grouping">[</span><span class="string-literal">"text/html"</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimator_html_repr</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">output</span>


<span class="keyword">class</span> <span class="invalid">C</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">M</span><span class="invalid">i</span><span class="invalid">x</span><span class="invalid">i</span><span class="invalid">n</span><span class="punctuation">:</span>
    <span class="comment">"""Mixin class for all classifiers in scikit-learn."""</span>

    <span class="identifier">_estimator_type</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"classifier"</span>

    <span class="keyword">def</span> <span class="identifier">score</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Return the mean accuracy on the given test data and labels.

        In multi-label classification, this is the subset accuracy
        which is a harsh metric since you require for each sample that
        each label set be correctly predicted.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Test samples.

        y : array-like of shape (n_samples,) or (n_samples, n_outputs)
            True labels for `X`.

        sample_weight : array-like of shape (n_samples,), default=None
            Sample weights.

        Returns
        -------
        score : float
            Mean accuracy of ``self.predict(X)`` wrt. `y`.
        """</span>
        <span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">metrics</span> <span class="keyword">import</span> <span class="identifier">accuracy_score</span>
        <span class="keyword">return</span> <span class="identifier">accuracy_score</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'requires_y'</span><span class="punctuation">:</span> <span class="bool-literal">True</span><span class="grouping">}</span>


<span class="keyword">class</span> <span class="identifier">RegressorMixin</span><span class="punctuation">:</span>
    <span class="comment">"""Mixin class for all regression estimators in scikit-learn."""</span>
    <span class="identifier">_estimator_type</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"regressor"</span>

    <span class="keyword">def</span> <span class="identifier">score</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Return the coefficient of determination :math:`R^2` of the
        prediction.

        The coefficient :math:`R^2` is defined as :math:`(1 - \\frac{u}{v})`,
        where :math:`u` is the residual sum of squares ``((y_true - y_pred)
        ** 2).sum()`` and :math:`v` is the total sum of squares ``((y_true -
        y_true.mean()) ** 2).sum()``. The best possible score is 1.0 and it
        can be negative (because the model can be arbitrarily worse). A
        constant model that always predicts the expected value of `y`,
        disregarding the input features, would get a :math:`R^2` score of
        0.0.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Test samples. For some estimators this may be a precomputed
            kernel matrix or a list of generic objects instead with shape
            ``(n_samples, n_samples_fitted)``, where ``n_samples_fitted``
            is the number of samples used in the fitting for the estimator.

        y : array-like of shape (n_samples,) or (n_samples, n_outputs)
            True values for `X`.

        sample_weight : array-like of shape (n_samples,), default=None
            Sample weights.

        Returns
        -------
        score : float
            :math:`R^2` of ``self.predict(X)`` wrt. `y`.

        Notes
        -----
        The :math:`R^2` score used when calling ``score`` on a regressor uses
        ``multioutput='uniform_average'`` from version 0.23 to keep consistent
        with default value of :func:`~sklearn.metrics.r2_score`.
        This influences the ``score`` method of all the multioutput
        regressors (except for
        :class:`~sklearn.multioutput.MultiOutputRegressor`).
        """</span>

        <span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">metrics</span> <span class="keyword">import</span> <span class="identifier">r2_score</span>
        <span class="identifier">y_pred</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">r2_score</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">y_pred</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'requires_y'</span><span class="punctuation">:</span> <span class="bool-literal">True</span><span class="grouping">}</span>


<span class="keyword">class</span> <span class="identifier">ClusterMixin</span><span class="punctuation">:</span>
    <span class="comment">"""Mixin class for all cluster estimators in scikit-learn."""</span>
    <span class="identifier">_estimator_type</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"clusterer"</span>

    <span class="keyword">def</span> <span class="identifier">fit_predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Perform clustering on `X` and returns cluster labels.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Input data.

        y : Ignored
            Not used, present for API consistency by convention.

        Returns
        -------
        labels : ndarray of shape (n_samples,), dtype=np.int64
            Cluster labels.
        """</span>
        <span class="comment"># non-optimized default implementation; override when a better</span>
        <span class="comment"># method is possible for a given clustering algorithm</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">labels_</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">"preserves_dtype"</span><span class="punctuation">:</span> <span class="grouping">[</span><span class="grouping">]</span><span class="grouping">}</span>


<span class="keyword">class</span> <span class="identifier">BiclusterMixin</span><span class="punctuation">:</span>
    <span class="comment">"""Mixin class for all bicluster estimators in scikit-learn."""</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">biclusters_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Convenient way to get row and column indicators together.

        Returns the ``rows_`` and ``columns_`` members.
        """</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">rows_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">columns_</span>

    <span class="keyword">def</span> <span class="identifier">get_indices</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Row and column indices of the `i`'th bicluster.

        Only works if ``rows_`` and ``columns_`` attributes exist.

        Parameters
        ----------
        i : int
            The index of the cluster.

        Returns
        -------
        row_ind : ndarray, dtype=np.intp
            Indices of rows in the dataset that belong to the bicluster.
        col_ind : ndarray, dtype=np.intp
            Indices of columns in the dataset that belong to the bicluster.

        """</span>
        <span class="identifier">rows</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">rows_</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span>
        <span class="identifier">columns</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">columns_</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">nonzero</span><span class="grouping">(</span><span class="identifier">rows</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">nonzero</span><span class="grouping">(</span><span class="identifier">columns</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">get_shape</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Shape of the `i`'th bicluster.

        Parameters
        ----------
        i : int
            The index of the cluster.

        Returns
        -------
        n_rows : int
            Number of rows in the bicluster.

        n_cols : int
            Number of columns in the bicluster.
        """</span>
        <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">get_indices</span><span class="grouping">(</span><span class="identifier">i</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">tuple</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">i</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">indices</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">get_submatrix</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">data</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Return the submatrix corresponding to bicluster `i`.

        Parameters
        ----------
        i : int
            The index of the cluster.
        data : array-like of shape (n_samples, n_features)
            The data.

        Returns
        -------
        submatrix : ndarray of shape (n_rows, n_cols)
            The submatrix corresponding to bicluster `i`.

        Notes
        -----
        Works with sparse matrices. Only works if ``rows_`` and
        ``columns_`` attributes exist.
        """</span>
        <span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_array</span>
        <span class="identifier">data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">data</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csr'</span><span class="grouping">)</span>
        <span class="identifier">row_ind</span><span class="punctuation">,</span> <span class="identifier">col_ind</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">get_indices</span><span class="grouping">(</span><span class="identifier">i</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">data</span><span class="grouping">[</span><span class="identifier">row_ind</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">col_ind</span><span class="grouping">]</span>


<span class="keyword">class</span> <span class="identifier">TransformerMixin</span><span class="punctuation">:</span>
    <span class="comment">"""Mixin class for all transformers in scikit-learn."""</span>

    <span class="keyword">def</span> <span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Fit to data, then transform it.

        Fits transformer to `X` and `y` with optional parameters `fit_params`
        and returns a transformed version of `X`.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Input samples.

        y :  array-like of shape (n_samples,) or (n_samples, n_outputs), \
                default=None
            Target values (None for unsupervised transformations).

        **fit_params : dict
            Additional fit parameters.

        Returns
        -------
        X_new : ndarray array of shape (n_samples, n_features_new)
            Transformed array.
        """</span>
        <span class="comment"># non-optimized default implementation; override when a better</span>
        <span class="comment"># method is possible for a given clustering algorithm</span>
        <span class="keyword">if</span> <span class="identifier">y</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="comment"># fit method of arity 1 (unsupervised transformation)</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># fit method of arity 2 (supervised transformation)</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">DensityMixin</span><span class="punctuation">:</span>
    <span class="comment">"""Mixin class for all density estimators in scikit-learn."""</span>
    <span class="identifier">_estimator_type</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"DensityEstimator"</span>

    <span class="keyword">def</span> <span class="identifier">score</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Return the score of the model on the data `X`.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Test samples.

        y : Ignored
            Not used, present for API consistency by convention.

        Returns
        -------
        score : float
        """</span>
        <span class="keyword">pass</span>


<span class="keyword">class</span> <span class="identifier">OutlierMixin</span><span class="punctuation">:</span>
    <span class="comment">"""Mixin class for all outlier detection estimators in scikit-learn."""</span>
    <span class="identifier">_estimator_type</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"outlier_detector"</span>

    <span class="keyword">def</span> <span class="identifier">fit_predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Perform fit on X and returns labels for X.

        Returns -1 for outliers and 1 for inliers.

        Parameters
        ----------
        X : {array-like, sparse matrix, dataframe} of shape \
            (n_samples, n_features)

        y : Ignored
            Not used, present for API consistency by convention.

        Returns
        -------
        y : ndarray of shape (n_samples,)
            1 for inliers, -1 for outliers.
        """</span>
        <span class="comment"># override for transductive outlier detectors like LocalOulierFactor</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">MetaEstimatorMixin</span><span class="punctuation">:</span>
    <span class="identifier">_required_parameters</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="string-literal">"estimator"</span><span class="grouping">]</span>
    <span class="comment">"""Mixin class for all meta estimators in scikit-learn."""</span>


<span class="keyword">class</span> <span class="identifier">MultiOutputMixin</span><span class="punctuation">:</span>
    <span class="comment">"""Mixin to mark estimators that support multioutput."""</span>
    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'multioutput'</span><span class="punctuation">:</span> <span class="bool-literal">True</span><span class="grouping">}</span>


<span class="keyword">class</span> <span class="identifier">_UnstableArchMixin</span><span class="punctuation">:</span>
    <span class="comment">"""Mark estimators that are non-determinstic on 32bit or PowerPC"""</span>
    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'non_deterministic'</span><span class="punctuation">:</span> <span class="grouping">(</span>
            <span class="identifier">_IS_32BIT</span> <span class="logical-operator">or</span> <span class="identifier">platform</span><span class="punctuation">.</span><span class="identifier">machine</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">startswith</span><span class="grouping">(</span><span class="grouping">(</span><span class="string-literal">'ppc', 'powerpc'</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">}</span>


<span class="keyword">def</span> <span class="identifier">is_classifier</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Return True if the given estimator is (probably) a classifier.

    Parameters
    ----------
    estimator : object
        Estimator object to test.

    Returns
    -------
    out : bool
        True if estimator is a classifier and False otherwise.
    """</span>
    <span class="keyword">return</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="string-literal">"_estimator_type", None) == "classifier"</span>


<span class="keyword">def</span> <span class="identifier">is_regressor</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Return True if the given estimator is (probably) a regressor.

    Parameters
    ----------
    estimator : estimator instance
        Estimator object to test.

    Returns
    -------
    out : bool
        True if estimator is a regressor and False otherwise.
    """</span>
    <span class="keyword">return</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="string-literal">"_estimator_type", None) == "regressor"</span>


<span class="keyword">def</span> <span class="identifier">is_outlier_detector</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Return True if the given estimator is (probably) an outlier detector.

    Parameters
    ----------
    estimator : estimator instance
        Estimator object to test.

    Returns
    -------
    out : bool
        True if estimator is an outlier detector and False otherwise.
    """</span>
    <span class="keyword">return</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="string-literal">"_estimator_type", None) == "outlier_detector"</span>


<span class="keyword">def</span> <span class="identifier">_is_pairwise</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Returns True if estimator is pairwise.

    - If the `_pairwise` attribute and the tag are present and consistent,
      then use the value and not issue a warning.
    - If the `_pairwise` attribute and the tag are present and not
      consistent, use the `_pairwise` value and issue a deprecation
      warning.
    - If only the `_pairwise` attribute is present and it is not False,
      issue a deprecation warning and use the `_pairwise` value.

    Parameters
    ----------
    estimator : object
        Estimator object to test.

    Returns
    -------
    out : bool
        True if the estimator is pairwise and False otherwise.
    """</span>
    <span class="keyword">with</span> <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">catch_warnings</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">filterwarnings</span><span class="grouping">(</span><span class="string-literal">'ignore'</span><span class="punctuation">,</span> <span class="identifier">category</span><span class="arithmetic-assignment">=</span><span class="identifier">FutureWarning</span><span class="grouping">)</span>
        <span class="identifier">has_pairwise_attribute</span> <span class="arithmetic-assignment">=</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="string-literal">'_pairwise'</span><span class="grouping">)</span>
        <span class="identifier">pairwise_attribute</span> <span class="arithmetic-assignment">=</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="string-literal">'_pairwise'</span><span class="punctuation">,</span> <span class="bool-literal">False</span><span class="grouping">)</span>
    <span class="identifier">pairwise_tag</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_safe_tags</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">key</span><span class="arithmetic-assignment">=</span><span class="string-literal">"pairwise"</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">has_pairwise_attribute</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">pairwise_attribute</span> <span class="relational-operator">!=</span> <span class="identifier">pairwise_tag</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span>
                <span class="string-literal">"_pairwise was deprecated in 0.24 and will be removed in 1.1 "</span>
                <span class="string-literal">"(renaming of 0.26). Set the estimator tags of your estimator "</span>
                <span class="string-literal">"instead"</span><span class="punctuation">,</span>
                <span class="identifier">FutureWarning</span>
            <span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">pairwise_attribute</span>

    <span class="comment"># use pairwise tag when the attribute is not present</span>
    <span class="keyword">return</span> <span class="identifier">pairwise_tag</span>

    </pre>
  </body>
</html>