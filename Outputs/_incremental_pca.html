<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""Incremental Principal Components Analysis."""</span>

<span class="comment"># Author: Kyle Kastner &lt;kastnerkyle@gmail.com&gt;</span>
<span class="comment">#         Giorgio Patrini</span>
<span class="comment"># License: BSD 3 clause</span>

<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">from</span> <span class="identifier">scipy</span> <span class="keyword">import</span> <span class="identifier">linalg</span><span class="punctuation">,</span> <span class="identifier">sparse</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_base</span> <span class="keyword">import</span> <span class="identifier">_BasePCA</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">gen_batches</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">extmath</span> <span class="keyword">import</span> <span class="identifier">svd_flip</span><span class="punctuation">,</span> <span class="identifier">_incremental_mean_and_var</span>


<span class="keyword">class</span> <span class="identifier">IncrementalPCA</span><span class="grouping">(</span><span class="identifier">_BasePCA</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Incremental principal components analysis (IPCA).

    Linear dimensionality reduction using Singular Value Decomposition of
    the data, keeping only the most significant singular vectors to
    project the data to a lower dimensional space. The input data is centered
    but not scaled for each feature before applying the SVD.

    Depending on the size of the input data, this algorithm can be much more
    memory efficient than a PCA, and allows sparse input.

    This algorithm has constant memory complexity, on the order
    of ``batch_size * n_features``, enabling use of np.memmap files without
    loading the entire file into memory. For sparse matrices, the input
    is converted to dense in batches (in order to be able to subtract the
    mean) which avoids storing the entire dense matrix at any one time.

    The computational overhead of each SVD is
    ``O(batch_size * n_features ** 2)``, but only 2 * batch_size samples
    remain in memory at a time. There will be ``n_samples / batch_size`` SVD
    computations to get the principal components, versus 1 large SVD of
    complexity ``O(n_samples * n_features ** 2)`` for PCA.

    Read more in the :ref:`User Guide &lt;IncrementalPCA&gt;`.

    .. versionadded:: 0.16

    Parameters
    ----------
    n_components : int, default=None
        Number of components to keep. If ``n_components`` is ``None``,
        then ``n_components`` is set to ``min(n_samples, n_features)``.

    whiten : bool, default=False
        When True (False by default) the ``components_`` vectors are divided
        by ``n_samples`` times ``components_`` to ensure uncorrelated outputs
        with unit component-wise variances.

        Whitening will remove some information from the transformed signal
        (the relative variance scales of the components) but can sometimes
        improve the predictive accuracy of the downstream estimators by
        making data respect some hard-wired assumptions.

    copy : bool, default=True
        If False, X will be overwritten. ``copy=False`` can be used to
        save memory but is unsafe for general use.

    batch_size : int, default=None
        The number of samples to use for each batch. Only used when calling
        ``fit``. If ``batch_size`` is ``None``, then ``batch_size``
        is inferred from the data and set to ``5 * n_features``, to provide a
        balance between approximation accuracy and memory consumption.

    Attributes
    ----------
    components_ : ndarray of shape (n_components, n_features)
        Components with maximum variance.

    explained_variance_ : ndarray of shape (n_components,)
        Variance explained by each of the selected components.

    explained_variance_ratio_ : ndarray of shape (n_components,)
        Percentage of variance explained by each of the selected components.
        If all components are stored, the sum of explained variances is equal
        to 1.0.

    singular_values_ : ndarray of shape (n_components,)
        The singular values corresponding to each of the selected components.
        The singular values are equal to the 2-norms of the ``n_components``
        variables in the lower-dimensional space.

    mean_ : ndarray of shape (n_features,)
        Per-feature empirical mean, aggregate over calls to ``partial_fit``.

    var_ : ndarray of shape (n_features,)
        Per-feature empirical variance, aggregate over calls to
        ``partial_fit``.

    noise_variance_ : float
        The estimated noise covariance following the Probabilistic PCA model
        from Tipping and Bishop 1999. See "Pattern Recognition and
        Machine Learning" by C. Bishop, 12.2.1 p. 574 or
        http://www.miketipping.com/papers/met-mppca.pdf.

    n_components_ : int
        The estimated number of components. Relevant when
        ``n_components=None``.

    n_samples_seen_ : int
        The number of samples processed by the estimator. Will be reset on
        new calls to fit, but increments across ``partial_fit`` calls.

    batch_size_ : int
        Inferred batch size from ``batch_size``.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.datasets import load_digits
    &gt;&gt;&gt; from sklearn.decomposition import IncrementalPCA
    &gt;&gt;&gt; from scipy import sparse
    &gt;&gt;&gt; X, _ = load_digits(return_X_y=True)
    &gt;&gt;&gt; transformer = IncrementalPCA(n_components=7, batch_size=200)
    &gt;&gt;&gt; # either partially fit on smaller batches of data
    &gt;&gt;&gt; transformer.partial_fit(X[:100, :])
    IncrementalPCA(batch_size=200, n_components=7)
    &gt;&gt;&gt; # or let the fit function itself divide the data into batches
    &gt;&gt;&gt; X_sparse = sparse.csr_matrix(X)
    &gt;&gt;&gt; X_transformed = transformer.fit_transform(X_sparse)
    &gt;&gt;&gt; X_transformed.shape
    (1797, 7)

    Notes
    -----
    Implements the incremental PCA model from:
    *D. Ross, J. Lim, R. Lin, M. Yang, Incremental Learning for Robust Visual
    Tracking, International Journal of Computer Vision, Volume 77, Issue 1-3,
    pp. 125-141, May 2008.*
    See https://www.cs.toronto.edu/~dross/ivt/RossLimLinYang_ijcv.pdf

    This model is an extension of the Sequential Karhunen-Loeve Transform from:
    *A. Levy and M. Lindenbaum, Sequential Karhunen-Loeve Basis Extraction and
    its Application to Images, IEEE Transactions on Image Processing, Volume 9,
    Number 8, pp. 1371-1374, August 2000.*
    See https://www.cs.technion.ac.il/~mic/doc/skl-ip.pdf

    We have specifically abstained from an optimization used by authors of both
    papers, a QR decomposition used in specific situations to reduce the
    algorithmic complexity of the SVD. The source for this technique is
    *Matrix Computations, Third Edition, G. Holub and C. Van Loan, Chapter 5,
    section 5.4.4, pp 252-253.*. This technique has been omitted because it is
    advantageous only when decomposing a matrix with ``n_samples`` (rows)
    &gt;= 5/3 * ``n_features`` (columns), and hurts the readability of the
    implemented algorithm. This would be a good opportunity for future
    optimization, if it is deemed necessary.

    References
    ----------
    D. Ross, J. Lim, R. Lin, M. Yang. Incremental Learning for Robust Visual
    Tracking, International Journal of Computer Vision, Volume 77,
    Issue 1-3, pp. 125-141, May 2008.

    G. Golub and C. Van Loan. Matrix Computations, Third Edition, Chapter 5,
    Section 5.4.4, pp. 252-253.

    See Also
    --------
    PCA
    KernelPCA
    SparsePCA
    TruncatedSVD
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">n_components</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">whiten</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">batch_size</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_components</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">whiten</span> <span class="arithmetic-assignment">=</span> <span class="identifier">whiten</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">batch_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">batch_size</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the model with X, using minibatches of size batch_size.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples and
            n_features is the number of features.

        y : Ignored

        Returns
        -------
        self : object
            Returns the instance itself.
        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">components_</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_samples_seen_</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">mean_</span> <span class="arithmetic-assignment">=</span> <span class="float-literal">.0</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">var_</span> <span class="arithmetic-assignment">=</span> <span class="float-literal">.0</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">singular_values_</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">explained_variance_</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">explained_variance_ratio_</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">noise_variance_</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>

        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="string-literal">'csr', 'csc', 'lil'</span><span class="grouping">]</span><span class="punctuation">,</span>
                                <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">batch_size</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">batch_size_</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">5</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_features</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">batch_size_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">batch_size</span>

        <span class="keyword">for</span> <span class="identifier">batch</span> <span class="relational-operator">in</span> <span class="identifier">gen_batches</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">batch_size_</span><span class="punctuation">,</span>
                                 <span class="identifier">min_batch_size</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components</span> <span class="logical-operator">or</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">X_batch</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">batch</span><span class="grouping">]</span>
            <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X_batch</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">X_batch</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_batch</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">partial_fit</span><span class="grouping">(</span><span class="identifier">X_batch</span><span class="punctuation">,</span> <span class="identifier">check_input</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">partial_fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">check_input</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Incremental fit with X. All of X is processed as a single batch.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples and
            n_features is the number of features.

        check_input : bool, default=True
            Run check_array on X.

        y : Ignored

        Returns
        -------
        self : object
            Returns the instance itself.
        """</span>
        <span class="identifier">first_pass</span> <span class="arithmetic-assignment">=</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">"components_"</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">check_input</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span>
                    <span class="string-literal">"IncrementalPCA.partial_fit does not support "</span>
                    <span class="string-literal">"sparse input. Either convert data to dense "</span>
                    <span class="string-literal">"or use IncrementalPCA.fit to do so in batches."</span><span class="grouping">)</span>
            <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="punctuation">,</span>
                <span class="identifier">reset</span><span class="arithmetic-assignment">=</span><span class="identifier">first_pass</span><span class="grouping">)</span>
        <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>
        <span class="keyword">if</span> <span class="identifier">first_pass</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">components_</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">components_</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">min</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">components_</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="keyword">elif</span> <span class="logical-operator">not</span> <span class="int-literal">1</span> <span class="relational-operator">&lt;=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components</span> <span class="relational-operator">&lt;=</span> <span class="identifier">n_features</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"n_components=%r invalid for n_features=%d, need "</span>
                             <span class="string-literal">"more rows than columns for IncrementalPCA "</span>
                             <span class="string-literal">"processing"</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components</span> <span class="relational-operator">&lt;=</span> <span class="identifier">n_samples</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"n_components=%r must be less or equal to "</span>
                             <span class="string-literal">"the batch number of samples "</span>
                             <span class="string-literal">"%d."</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components</span>

        <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">components_</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">components_</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">!=</span>
                                               <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components_</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Number of input features has changed from %i "</span>
                             <span class="string-literal">"to %i between calls to partial_fit! Try "</span>
                             <span class="string-literal">"setting n_components to a fixed value."</span> <span class="arithmetic-operator">%</span>
                             <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">components_</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components_</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="comment"># This is the first partial_fit</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">'n_samples_seen_'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_samples_seen_</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">mean_</span> <span class="arithmetic-assignment">=</span> <span class="float-literal">.0</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">var_</span> <span class="arithmetic-assignment">=</span> <span class="float-literal">.0</span>

        <span class="comment"># Update stats - they are 0 if this is the first step</span>
        <span class="identifier">col_mean</span><span class="punctuation">,</span> <span class="identifier">col_var</span><span class="punctuation">,</span> <span class="identifier">n_total_samples</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
            <span class="identifier">_incremental_mean_and_var</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">last_mean</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">mean_</span><span class="punctuation">,</span> <span class="identifier">last_variance</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">var_</span><span class="punctuation">,</span>
                <span class="identifier">last_sample_count</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">repeat</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_samples_seen_</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">n_total_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_total_samples</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

        <span class="comment"># Whitening</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_samples_seen_</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="comment"># If it is the first step, simply whiten X</span>
            <span class="identifier">X</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">col_mean</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">col_batch_mean</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
            <span class="identifier">X</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">col_batch_mean</span>
            <span class="comment"># Build matrix of combined previous basis and new data</span>
            <span class="identifier">mean_correction</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
                <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_samples_seen_</span> <span class="arithmetic-operator">/</span> <span class="identifier">n_total_samples</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span>
                        <span class="identifier">n_samples</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">mean_</span> <span class="arithmetic-operator">-</span> <span class="identifier">col_batch_mean</span><span class="grouping">)</span>
            <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">vstack</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">singular_values_</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span>
                           <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">components_</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">mean_correction</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">U</span><span class="punctuation">,</span> <span class="identifier">S</span><span class="punctuation">,</span> <span class="identifier">Vt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">svd</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">full_matrices</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">check_finite</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">U</span><span class="punctuation">,</span> <span class="identifier">Vt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">svd_flip</span><span class="grouping">(</span><span class="identifier">U</span><span class="punctuation">,</span> <span class="identifier">Vt</span><span class="punctuation">,</span> <span class="identifier">u_based_decision</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">explained_variance</span> <span class="arithmetic-assignment">=</span> <span class="identifier">S</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">n_total_samples</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">)</span>
        <span class="identifier">explained_variance_ratio</span> <span class="arithmetic-assignment">=</span> <span class="identifier">S</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span> <span class="arithmetic-operator">/</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">col_var</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_total_samples</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_samples_seen_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_total_samples</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">components_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Vt</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components_</span><span class="grouping">]</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">singular_values_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">S</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components_</span><span class="grouping">]</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">mean_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">col_mean</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">var_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">col_var</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">explained_variance_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">explained_variance</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components_</span><span class="grouping">]</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">explained_variance_ratio_</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
            <span class="identifier">explained_variance_ratio</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components_</span><span class="grouping">]</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components_</span> <span class="relational-operator">&lt;</span> <span class="identifier">n_features</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">noise_variance_</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
                <span class="identifier">explained_variance</span><span class="grouping">[</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components_</span><span class="punctuation">:</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">noise_variance_</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Apply dimensionality reduction to X.

        X is projected on the first principal components previously extracted
        from a training set, using minibatches of size batch_size if X is
        sparse.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            New data, where n_samples is the number of samples
            and n_features is the number of features.

        Returns
        -------
        X_new : ndarray of shape (n_samples, n_components)

        Examples
        --------

        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from sklearn.decomposition import IncrementalPCA
        &gt;&gt;&gt; X = np.array([[-1, -1], [-2, -1], [-3, -2],
        ...               [1, 1], [2, 1], [3, 2]])
        &gt;&gt;&gt; ipca = IncrementalPCA(n_components=2, batch_size=3)
        &gt;&gt;&gt; ipca.fit(X)
        IncrementalPCA(batch_size=3, n_components=2)
        &gt;&gt;&gt; ipca.transform(X) # doctest: +SKIP
        """</span>
        <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
            <span class="identifier">output</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
            <span class="keyword">for</span> <span class="identifier">batch</span> <span class="relational-operator">in</span> <span class="identifier">gen_batches</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">batch_size_</span><span class="punctuation">,</span>
                                     <span class="identifier">min_batch_size</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components</span> <span class="logical-operator">or</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">output</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">[</span><span class="identifier">batch</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">vstack</span><span class="grouping">(</span><span class="identifier">output</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

    </pre>
  </body>
</html>