<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""
Extended math utilities.
"""</span>
<span class="comment"># Authors: Gael Varoquaux</span>
<span class="comment">#          Alexandre Gramfort</span>
<span class="comment">#          Alexandre T. Passos</span>
<span class="comment">#          Olivier Grisel</span>
<span class="comment">#          Lars Buitinck</span>
<span class="comment">#          Stefan van der Walt</span>
<span class="comment">#          Kyle Kastner</span>
<span class="comment">#          Giorgio Patrini</span>
<span class="comment"># License: BSD 3 clause</span>

<span class="keyword">import</span> <span class="identifier">warnings</span>

<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">from</span> <span class="identifier">scipy</span> <span class="keyword">import</span> <span class="identifier">linalg</span><span class="punctuation">,</span> <span class="identifier">sparse</span>

<span class="keyword">from</span> <span class="punctuation">.</span> <span class="keyword">import</span> <span class="identifier">check_random_state</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_logistic_sigmoid</span> <span class="keyword">import</span> <span class="identifier">_log_logistic_sigmoid</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">fixes</span> <span class="keyword">import</span> <span class="identifier">np_version</span><span class="punctuation">,</span> <span class="identifier">parse_version</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">sparsefuncs_fast</span> <span class="keyword">import</span> <span class="identifier">csr_row_norms</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_array</span>


<span class="keyword">def</span> <span class="identifier">squared_norm</span><span class="grouping">(</span><span class="identifier">x</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Squared Euclidean or Frobenius norm of x.

    Faster than norm(x) ** 2.

    Parameters
    ----------
    x : array-like

    Returns
    -------
    float
        The Euclidean norm when x is a vector, the Frobenius norm when x
        is a matrix (2-d array).
    """</span>
    <span class="identifier">x</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="identifier">x</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'K'</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">issubdtype</span><span class="grouping">(</span><span class="identifier">x</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">integer</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">'Array type is integer, np.dot may overflow. '</span>
                      <span class="string-literal">'Data should be float type to avoid this issue'</span><span class="punctuation">,</span>
                      <span class="identifier">UserWarning</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">x</span><span class="punctuation">,</span> <span class="identifier">x</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">row_norms</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">squared</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Row-wise (squared) Euclidean norm of X.

    Equivalent to np.sqrt((X * X).sum(axis=1)), but also supports sparse
    matrices and does not create an X.shape-sized temporary.

    Performs no input validation.

    Parameters
    ----------
    X : array-like
        The input array.
    squared : bool, default=False
        If True, return squared norms.

    Returns
    -------
    array-like
        The row-wise (squared) Euclidean norm of X.
    """</span>
    <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">csr_matrix</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">csr_matrix</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">norms</span> <span class="arithmetic-assignment">=</span> <span class="identifier">csr_row_norms</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">norms</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">einsum</span><span class="grouping">(</span><span class="string-literal">'ij,ij-&gt;i'</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">squared</span><span class="punctuation">:</span>
        <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">norms</span><span class="punctuation">,</span> <span class="identifier">norms</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">norms</span>


<span class="keyword">def</span> <span class="identifier">fast_logdet</span><span class="grouping">(</span><span class="identifier">A</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Compute log(det(A)) for A symmetric.

    Equivalent to : np.log(nl.det(A)) but more robust.
    It returns -Inf if det(A) is non positive or is not defined.

    Parameters
    ----------
    A : array-like
        The matrix.
    """</span>
    <span class="identifier">sign</span><span class="punctuation">,</span> <span class="identifier">ld</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">slogdet</span><span class="grouping">(</span><span class="identifier">A</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">sign</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="arithmetic-operator">-</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">inf</span>
    <span class="keyword">return</span> <span class="identifier">ld</span>


<span class="keyword">def</span> <span class="identifier">density</span><span class="grouping">(</span><span class="identifier">w</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">kwargs</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Compute density of a sparse vector.

    Parameters
    ----------
    w : array-like
        The sparse vector.

    Returns
    -------
    float
        The density of w, between 0 and 1.
    """</span>
    <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">w</span><span class="punctuation">,</span> <span class="string-literal">"toarray"</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">d</span> <span class="arithmetic-assignment">=</span> <span class="identifier">float</span><span class="grouping">(</span><span class="identifier">w</span><span class="punctuation">.</span><span class="identifier">nnz</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">w</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">w</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">d</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span> <span class="keyword">if</span> <span class="identifier">w</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="keyword">else</span> <span class="identifier">float</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">w</span> <span class="relational-operator">!=</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">w</span><span class="punctuation">.</span><span class="identifier">size</span>
    <span class="keyword">return</span> <span class="identifier">d</span>


<span class="keyword">def</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">a</span><span class="punctuation">,</span> <span class="identifier">b</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Dot product that handle the sparse matrix case correctly.

    Parameters
    ----------
    a : {ndarray, sparse matrix}
    b : {ndarray, sparse matrix}
    dense_output : bool, default=False
        When False, ``a`` and ``b`` both being sparse will yield sparse output.
        When True, output will always be a dense array.

    Returns
    -------
    dot_product : {ndarray, sparse matrix}
        Sparse if ``a`` and ``b`` are sparse and ``dense_output=False``.
    """</span>
    <span class="keyword">if</span> <span class="identifier">a</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">&gt;</span> <span class="int-literal">2</span> <span class="logical-operator">or</span> <span class="identifier">b</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">&gt;</span> <span class="int-literal">2</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">a</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># sparse is always 2D. Implies b is 3D+</span>
            <span class="comment"># [i, j] @ [k, ..., l, m, n] -&gt; [i, k, ..., l, n]</span>
            <span class="identifier">b_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">rollaxis</span><span class="grouping">(</span><span class="identifier">b</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">2</span><span class="grouping">)</span>
            <span class="identifier">b_2d</span> <span class="arithmetic-assignment">=</span> <span class="identifier">b_</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">b</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">2</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">ret</span> <span class="arithmetic-assignment">=</span> <span class="identifier">a</span> <span class="punctuation">@</span> <span class="identifier">b_2d</span>
            <span class="identifier">ret</span> <span class="arithmetic-assignment">=</span> <span class="identifier">ret</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="identifier">a</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="identifier">b_</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="punctuation">:</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">b</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># sparse is always 2D. Implies a is 3D+</span>
            <span class="comment"># [k, ..., l, m] @ [i, j] -&gt; [k, ..., l, j]</span>
            <span class="identifier">a_2d</span> <span class="arithmetic-assignment">=</span> <span class="identifier">a</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">a</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="identifier">ret</span> <span class="arithmetic-assignment">=</span> <span class="identifier">a_2d</span> <span class="punctuation">@</span> <span class="identifier">b</span>
            <span class="identifier">ret</span> <span class="arithmetic-assignment">=</span> <span class="identifier">ret</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">a</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">b</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">ret</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">a</span><span class="punctuation">,</span> <span class="identifier">b</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">ret</span> <span class="arithmetic-assignment">=</span> <span class="identifier">a</span> <span class="punctuation">@</span> <span class="identifier">b</span>

    <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">a</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">b</span><span class="grouping">)</span>
            <span class="logical-operator">and</span> <span class="identifier">dense_output</span> <span class="logical-operator">and</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">ret</span><span class="punctuation">,</span> <span class="string-literal">"toarray"</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">ret</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">ret</span>


<span class="keyword">def</span> <span class="identifier">randomized_range_finder</span><span class="grouping">(</span><span class="identifier">A</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">size</span><span class="punctuation">,</span> <span class="identifier">n_iter</span><span class="punctuation">,</span>
                            <span class="identifier">power_iteration_normalizer</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span>
                            <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Computes an orthonormal matrix whose range approximates the range of A.

    Parameters
    ----------
    A : 2D array
        The input data matrix.

    size : int
        Size of the return array.

    n_iter : int
        Number of power iterations used to stabilize the result.

    power_iteration_normalizer : {'auto', 'QR', 'LU', 'none'}, default='auto'
        Whether the power iterations are normalized with step-by-step
        QR factorization (the slowest but most accurate), 'none'
        (the fastest but numerically unstable when `n_iter` is large, e.g.
        typically 5 or larger), or 'LU' factorization (numerically stable
        but can lose slightly in accuracy). The 'auto' mode applies no
        normalization if `n_iter` &lt;= 2 and switches to LU otherwise.

        .. versionadded:: 0.18

    random_state : int, RandomState instance or None, default=None
        The seed of the pseudo random number generator to use when shuffling
        the data, i.e. getting the random vectors to initialize the algorithm.
        Pass an int for reproducible results across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    Returns
    -------
    Q : ndarray
        A (size x size) projection matrix, the range of which
        approximates well the range of the input matrix A.

    Notes
    -----

    Follows Algorithm 4.3 of
    Finding structure with randomness: Stochastic algorithms for constructing
    approximate matrix decompositions
    Halko, et al., 2009 (arXiv:909) https://arxiv.org/pdf/0909.4061.pdf

    An implementation of a randomized algorithm for principal component
    analysis
    A. Szlam et al. 2014
    """</span>
    <span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">random_state</span><span class="grouping">)</span>

    <span class="comment"># Generating normal random vectors with shape: (A.shape[1], size)</span>
    <span class="identifier">Q</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span><span class="punctuation">.</span><span class="identifier">normal</span><span class="grouping">(</span><span class="identifier">size</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="identifier">A</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">size</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">A</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">.</span><span class="identifier">kind</span> <span class="relational-operator">==</span> <span class="string-literal">'f'</span><span class="punctuation">:</span>
        <span class="comment"># Ensure f32 is preserved as f32</span>
        <span class="identifier">Q</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Q</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">A</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="comment"># Deal with "auto" mode</span>
    <span class="keyword">if</span> <span class="identifier">power_iteration_normalizer</span> <span class="relational-operator">==</span> <span class="string-literal">'auto'</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">n_iter</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">2</span><span class="punctuation">:</span>
            <span class="identifier">power_iteration_normalizer</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'none'</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">power_iteration_normalizer</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'LU'</span>

    <span class="comment"># Perform power iterations with Q to further 'imprint' the top</span>
    <span class="comment"># singular vectors of A in Q</span>
    <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_iter</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">power_iteration_normalizer</span> <span class="relational-operator">==</span> <span class="string-literal">'none'</span><span class="punctuation">:</span>
            <span class="identifier">Q</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">A</span><span class="punctuation">,</span> <span class="identifier">Q</span><span class="grouping">)</span>
            <span class="identifier">Q</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">A</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">Q</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">power_iteration_normalizer</span> <span class="relational-operator">==</span> <span class="string-literal">'LU'</span><span class="punctuation">:</span>
            <span class="identifier">Q</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">lu</span><span class="grouping">(</span><span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">A</span><span class="punctuation">,</span> <span class="identifier">Q</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">permute_l</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
            <span class="identifier">Q</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">lu</span><span class="grouping">(</span><span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">A</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">Q</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">permute_l</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">power_iteration_normalizer</span> <span class="relational-operator">==</span> <span class="string-literal">'QR'</span><span class="punctuation">:</span>
            <span class="identifier">Q</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">qr</span><span class="grouping">(</span><span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">A</span><span class="punctuation">,</span> <span class="identifier">Q</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">mode</span><span class="arithmetic-assignment">=</span><span class="string-literal">'economic'</span><span class="grouping">)</span>
            <span class="identifier">Q</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">qr</span><span class="grouping">(</span><span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">A</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">Q</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">mode</span><span class="arithmetic-assignment">=</span><span class="string-literal">'economic'</span><span class="grouping">)</span>

    <span class="comment"># Sample the range of A using by linear projection of Q</span>
    <span class="comment"># Extract an orthonormal basis</span>
    <span class="identifier">Q</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">qr</span><span class="grouping">(</span><span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">A</span><span class="punctuation">,</span> <span class="identifier">Q</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">mode</span><span class="arithmetic-assignment">=</span><span class="string-literal">'economic'</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">Q</span>


<span class="keyword">def</span> <span class="identifier">randomized_svd</span><span class="grouping">(</span><span class="identifier">M</span><span class="punctuation">,</span> <span class="identifier">n_components</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">n_oversamples</span><span class="arithmetic-assignment">=</span><span class="int-literal">10</span><span class="punctuation">,</span> <span class="identifier">n_iter</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span>
                   <span class="identifier">power_iteration_normalizer</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto', transpose='auto'</span><span class="punctuation">,</span>
                   <span class="identifier">flip_sign</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="string-literal">'warn'</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Computes a truncated randomized SVD.

    This method solves the fixed-rank approximation problem described in the
    Halko et al paper (problem (1.5), p5).

    Parameters
    ----------
    M : {ndarray, sparse matrix}
        Matrix to decompose.

    n_components : int
        Number of singular values and vectors to extract.

    n_oversamples : int, default=10
        Additional number of random vectors to sample the range of M so as
        to ensure proper conditioning. The total number of random vectors
        used to find the range of M is n_components + n_oversamples. Smaller
        number can improve speed but can negatively impact the quality of
        approximation of singular vectors and singular values. Users might wish
        to increase this parameter up to `2*k - n_components` where k is the
        effective rank, for large matrices, noisy problems, matrices with
        slowly decaying spectrums, or to increase precision accuracy. See Halko
        et al (pages 5, 23 and 26).

    n_iter : int or 'auto', default='auto'
        Number of power iterations. It can be used to deal with very noisy
        problems. When 'auto', it is set to 4, unless `n_components` is small
        (&lt; .1 * min(X.shape)) in which case `n_iter` is set to 7.
        This improves precision with few components. Note that in general
        users should rather increase `n_oversamples` before increasing `n_iter`
        as the principle of the randomized method is to avoid usage of these
        more costly power iterations steps. When `n_components` is equal
        or greater to the effective matrix rank and the spectrum does not
        present a slow decay, `n_iter=0` or `1` should even work fine in theory
        (see Halko et al paper, page 9).

        .. versionchanged:: 0.18

    power_iteration_normalizer : {'auto', 'QR', 'LU', 'none'}, default='auto'
        Whether the power iterations are normalized with step-by-step
        QR factorization (the slowest but most accurate), 'none'
        (the fastest but numerically unstable when `n_iter` is large, e.g.
        typically 5 or larger), or 'LU' factorization (numerically stable
        but can lose slightly in accuracy). The 'auto' mode applies no
        normalization if `n_iter` &lt;= 2 and switches to LU otherwise.

        .. versionadded:: 0.18

    transpose : bool or 'auto', default='auto'
        Whether the algorithm should be applied to M.T instead of M. The
        result should approximately be the same. The 'auto' mode will
        trigger the transposition if M.shape[1] &gt; M.shape[0] since this
        implementation of randomized SVD tend to be a little faster in that
        case.

        .. versionchanged:: 0.18

    flip_sign : bool, default=True
        The output of a singular value decomposition is only unique up to a
        permutation of the signs of the singular vectors. If `flip_sign` is
        set to `True`, the sign ambiguity is resolved by making the largest
        loadings for each component in the left singular vectors positive.

    random_state : int, RandomState instance or None, default='warn'
        The seed of the pseudo random number generator to use when
        shuffling the data, i.e. getting the random vectors to initialize
        the algorithm. Pass an int for reproducible results across multiple
        function calls. See :term:`Glossary &lt;random_state&gt;`.

        .. versionchanged:: 1.2
            The previous behavior (`random_state=0`) is deprecated, and
            from v1.2 the default value will be `random_state=None`. Set
            the value of `random_state` explicitly to suppress the deprecation
            warning.

    Notes
    -----
    This algorithm finds a (usually very good) approximate truncated
    singular value decomposition using randomization to speed up the
    computations. It is particularly fast on large matrices on which
    you wish to extract only a small number of components. In order to
    obtain further speed up, `n_iter` can be set &lt;=2 (at the cost of
    loss of precision). To increase the precision it is recommended to
    increase `n_oversamples`, up to `2*k-n_components` where k is the
    effective rank. Usually, `n_components` is chosen to be greater than k
    so increasing `n_oversamples` up to `n_components` should be enough.

    References
    ----------
    * Finding structure with randomness: Stochastic algorithms for constructing
      approximate matrix decompositions (Algorithm 4.3)
      Halko, et al., 2009 https://arxiv.org/abs/0909.4061

    * A randomized algorithm for the decomposition of matrices
      Per-Gunnar Martinsson, Vladimir Rokhlin and Mark Tygert

    * An implementation of a randomized algorithm for principal component
      analysis
      A. Szlam et al. 2014
    """</span>
    <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">M</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">lil_matrix</span><span class="punctuation">,</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">dok_matrix</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">"Calculating SVD of a {} is expensive. "</span>
                      <span class="string-literal">"csr_matrix is more efficient."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">type</span><span class="grouping">(</span><span class="identifier">M</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__name__</span><span class="grouping">)</span><span class="punctuation">,</span>
                      <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">SparseEfficiencyWarning</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">random_state</span> <span class="relational-operator">==</span> <span class="string-literal">'warn'</span><span class="punctuation">:</span>
        <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span>
            <span class="string-literal">"If 'random_state' is not supplied, the current default "</span>
            <span class="string-literal">"is to use 0 as a fixed seed. This will change to  "</span>
            <span class="string-literal">"None in version 1.2 leading to non-deterministic results "</span>
            <span class="string-literal">"that better reflect nature of the randomized_svd solver. "</span>
            <span class="string-literal">"If you want to silence this warning, set 'random_state' "</span>
            <span class="string-literal">"to an integer seed or to None explicitly depending "</span>
            <span class="string-literal">"if you want your code to be deterministic or not."</span><span class="punctuation">,</span>
            <span class="identifier">FutureWarning</span>
        <span class="grouping">)</span>
        <span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>

    <span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">random_state</span><span class="grouping">)</span>
    <span class="identifier">n_random</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_components</span> <span class="arithmetic-operator">+</span> <span class="identifier">n_oversamples</span>
    <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">M</span><span class="punctuation">.</span><span class="identifier">shape</span>

    <span class="keyword">if</span> <span class="identifier">n_iter</span> <span class="relational-operator">==</span> <span class="string-literal">'auto'</span><span class="punctuation">:</span>
        <span class="comment"># Checks if the number of iterations is explicitly specified</span>
        <span class="comment"># Adjust n_iter. 7 was found a good compromise for PCA. See #5299</span>
        <span class="identifier">n_iter</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">7</span> <span class="keyword">if</span> <span class="identifier">n_components</span> <span class="relational-operator">&lt;</span> <span class="float-literal">.1</span> <span class="arithmetic-operator">*</span> <span class="identifier">min</span><span class="grouping">(</span><span class="identifier">M</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span> <span class="keyword">else</span> <span class="int-literal">4</span>

    <span class="keyword">if</span> <span class="identifier">transpose</span> <span class="relational-operator">==</span> <span class="string-literal">'auto'</span><span class="punctuation">:</span>
        <span class="identifier">transpose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_samples</span> <span class="relational-operator">&lt;</span> <span class="identifier">n_features</span>
    <span class="keyword">if</span> <span class="identifier">transpose</span><span class="punctuation">:</span>
        <span class="comment"># this implementation is a bit faster with smaller shape[1]</span>
        <span class="identifier">M</span> <span class="arithmetic-assignment">=</span> <span class="identifier">M</span><span class="punctuation">.</span><span class="identifier">T</span>

    <span class="identifier">Q</span> <span class="arithmetic-assignment">=</span> <span class="identifier">randomized_range_finder</span><span class="grouping">(</span>
        <span class="identifier">M</span><span class="punctuation">,</span> <span class="identifier">size</span><span class="arithmetic-assignment">=</span><span class="identifier">n_random</span><span class="punctuation">,</span> <span class="identifier">n_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">n_iter</span><span class="punctuation">,</span>
        <span class="identifier">power_iteration_normalizer</span><span class="arithmetic-assignment">=</span><span class="identifier">power_iteration_normalizer</span><span class="punctuation">,</span>
        <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>

    <span class="comment"># project M to the (k + p) dimensional space using the basis vectors</span>
    <span class="identifier">B</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">Q</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">M</span><span class="grouping">)</span>

    <span class="comment"># compute the SVD on the thin matrix: (k + p) wide</span>
    <span class="identifier">Uhat</span><span class="punctuation">,</span> <span class="identifier">s</span><span class="punctuation">,</span> <span class="identifier">Vt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">svd</span><span class="grouping">(</span><span class="identifier">B</span><span class="punctuation">,</span> <span class="identifier">full_matrices</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="keyword">del</span> <span class="identifier">B</span>
    <span class="identifier">U</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">Q</span><span class="punctuation">,</span> <span class="identifier">Uhat</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">flip_sign</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">transpose</span><span class="punctuation">:</span>
            <span class="identifier">U</span><span class="punctuation">,</span> <span class="identifier">Vt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">svd_flip</span><span class="grouping">(</span><span class="identifier">U</span><span class="punctuation">,</span> <span class="identifier">Vt</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># In case of transpose u_based_decision=false</span>
            <span class="comment"># to actually flip based on u and not v.</span>
            <span class="identifier">U</span><span class="punctuation">,</span> <span class="identifier">Vt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">svd_flip</span><span class="grouping">(</span><span class="identifier">U</span><span class="punctuation">,</span> <span class="identifier">Vt</span><span class="punctuation">,</span> <span class="identifier">u_based_decision</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">transpose</span><span class="punctuation">:</span>
        <span class="comment"># transpose back the results according to the input convention</span>
        <span class="keyword">return</span> <span class="identifier">Vt</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_components</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">s</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_components</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">U</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="identifier">n_components</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">T</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">U</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="identifier">n_components</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">s</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_components</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Vt</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_components</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span>


<span class="keyword">def</span> <span class="identifier">_randomized_eigsh</span><span class="grouping">(</span><span class="identifier">M</span><span class="punctuation">,</span> <span class="identifier">n_components</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">n_oversamples</span><span class="arithmetic-assignment">=</span><span class="int-literal">10</span><span class="punctuation">,</span> <span class="identifier">n_iter</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span>
                      <span class="identifier">power_iteration_normalizer</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span>
                      <span class="identifier">selection</span><span class="arithmetic-assignment">=</span><span class="string-literal">'module'</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Computes a truncated eigendecomposition using randomized methods

    This method solves the fixed-rank approximation problem described in the
    Halko et al paper.

    The choice of which components to select can be tuned with the `selection`
    parameter.

    .. versionadded:: 0.24

    Parameters
    ----------
    M : ndarray or sparse matrix
        Matrix to decompose, it should be real symmetric square or complex
        hermitian

    n_components : int
        Number of eigenvalues and vectors to extract.

    n_oversamples : int, default=10
        Additional number of random vectors to sample the range of M so as
        to ensure proper conditioning. The total number of random vectors
        used to find the range of M is n_components + n_oversamples. Smaller
        number can improve speed but can negatively impact the quality of
        approximation of eigenvectors and eigenvalues. Users might wish
        to increase this parameter up to `2*k - n_components` where k is the
        effective rank, for large matrices, noisy problems, matrices with
        slowly decaying spectrums, or to increase precision accuracy. See Halko
        et al (pages 5, 23 and 26).

    n_iter : int or 'auto', default='auto'
        Number of power iterations. It can be used to deal with very noisy
        problems. When 'auto', it is set to 4, unless `n_components` is small
        (&lt; .1 * min(X.shape)) in which case `n_iter` is set to 7.
        This improves precision with few components. Note that in general
        users should rather increase `n_oversamples` before increasing `n_iter`
        as the principle of the randomized method is to avoid usage of these
        more costly power iterations steps. When `n_components` is equal
        or greater to the effective matrix rank and the spectrum does not
        present a slow decay, `n_iter=0` or `1` should even work fine in theory
        (see Halko et al paper, page 9).

    power_iteration_normalizer : {'auto', 'QR', 'LU', 'none'}, default='auto'
        Whether the power iterations are normalized with step-by-step
        QR factorization (the slowest but most accurate), 'none'
        (the fastest but numerically unstable when `n_iter` is large, e.g.
        typically 5 or larger), or 'LU' factorization (numerically stable
        but can lose slightly in accuracy). The 'auto' mode applies no
        normalization if `n_iter` &lt;= 2 and switches to LU otherwise.

    selection : {'value', 'module'}, default='module'
        Strategy used to select the n components. When `selection` is `'value'`
        (not yet implemented, will become the default when implemented), the
        components corresponding to the n largest eigenvalues are returned.
        When `selection` is `'module'`, the components corresponding to the n
        eigenvalues with largest modules are returned.

    random_state : int, RandomState instance, default=None
        The seed of the pseudo random number generator to use when shuffling
        the data, i.e. getting the random vectors to initialize the algorithm.
        Pass an int for reproducible results across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    Notes
    -----
    This algorithm finds a (usually very good) approximate truncated
    eigendecomposition using randomized methods to speed up the computations.

    This method is particularly fast on large matrices on which
    you wish to extract only a small number of components. In order to
    obtain further speed up, `n_iter` can be set &lt;=2 (at the cost of
    loss of precision). To increase the precision it is recommended to
    increase `n_oversamples`, up to `2*k-n_components` where k is the
    effective rank. Usually, `n_components` is chosen to be greater than k
    so increasing `n_oversamples` up to `n_components` should be enough.

    Strategy 'value': not implemented yet.
    Algorithms 5.3, 5.4 and 5.5 in the Halko et al paper should provide good
    condidates for a future implementation.

    Strategy 'module':
    The principle is that for diagonalizable matrices, the singular values and
    eigenvalues are related: if t is an eigenvalue of A, then :math:`|t|` is a
    singular value of A. This method relies on a randomized SVD to find the n
    singular components corresponding to the n singular values with largest
    modules, and then uses the signs of the singular vectors to find the true
    sign of t: if the sign of left and right singular vectors are different
    then the corresponding eigenvalue is negative.

    Returns
    -------
    eigvals : 1D array of shape (n_components,) containing the `n_components`
        eigenvalues selected (see ``selection`` parameter).
    eigvecs : 2D array of shape (M.shape[0], n_components) containing the
        `n_components` eigenvectors corresponding to the `eigvals`, in the
        corresponding order. Note that this follows the `scipy.linalg.eigh`
        convention.

    See Also
    --------
    :func:`randomized_svd`

    References
    ----------
    * Finding structure with randomness: Stochastic algorithms for constructing
      approximate matrix decompositions (Algorithm 4.3 for strategy 'module')
      Halko, et al., 2009 https://arxiv.org/abs/0909.4061

    """</span>
    <span class="keyword">if</span> <span class="identifier">selection</span> <span class="relational-operator">==</span> <span class="string-literal">'value'</span><span class="punctuation">:</span>  <span class="comment"># pragma: no cover</span>
        <span class="comment"># to do : an algorithm can be found in the Halko et al reference</span>
        <span class="keyword">raise</span> <span class="identifier">NotImplementedError</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">elif</span> <span class="identifier">selection</span> <span class="relational-operator">==</span> <span class="string-literal">'module'</span><span class="punctuation">:</span>
        <span class="comment"># Note: no need for deterministic U and Vt (flip_sign=True),</span>
        <span class="comment"># as we only use the dot product UVt afterwards</span>
        <span class="identifier">U</span><span class="punctuation">,</span> <span class="identifier">S</span><span class="punctuation">,</span> <span class="identifier">Vt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">randomized_svd</span><span class="grouping">(</span>
            <span class="identifier">M</span><span class="punctuation">,</span> <span class="identifier">n_components</span><span class="arithmetic-assignment">=</span><span class="identifier">n_components</span><span class="punctuation">,</span> <span class="identifier">n_oversamples</span><span class="arithmetic-assignment">=</span><span class="identifier">n_oversamples</span><span class="punctuation">,</span>
            <span class="identifier">n_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">n_iter</span><span class="punctuation">,</span>
            <span class="identifier">power_iteration_normalizer</span><span class="arithmetic-assignment">=</span><span class="identifier">power_iteration_normalizer</span><span class="punctuation">,</span>
            <span class="identifier">flip_sign</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>

        <span class="identifier">eigvecs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">U</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="identifier">n_components</span><span class="grouping">]</span>
        <span class="identifier">eigvals</span> <span class="arithmetic-assignment">=</span> <span class="identifier">S</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_components</span><span class="grouping">]</span>

        <span class="comment"># Conversion of Singular values into Eigenvalues:</span>
        <span class="comment"># For any eigenvalue t, the corresponding singular value is |t|.</span>
        <span class="comment"># So if there is a negative eigenvalue t, the corresponding singular</span>
        <span class="comment"># value will be -t, and the left (U) and right (V) singular vectors</span>
        <span class="comment"># will have opposite signs.</span>
        <span class="comment"># Fastest way: see &lt;https://stackoverflow.com/a/61974002/7262247&gt;</span>
        <span class="identifier">diag_VtU</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">einsum</span><span class="grouping">(</span><span class="string-literal">'ji,ij-&gt;j'</span><span class="punctuation">,</span>
                             <span class="identifier">Vt</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_components</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">U</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="identifier">n_components</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="identifier">signs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sign</span><span class="grouping">(</span><span class="identifier">diag_VtU</span><span class="grouping">)</span>
        <span class="identifier">eigvals</span> <span class="arithmetic-assignment">=</span> <span class="identifier">eigvals</span> <span class="arithmetic-operator">*</span> <span class="identifier">signs</span>

    <span class="keyword">else</span><span class="punctuation">:</span>  <span class="comment"># pragma: no cover</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Invalid `selection`: %r"</span> <span class="arithmetic-operator">%</span> <span class="identifier">selection</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">eigvals</span><span class="punctuation">,</span> <span class="identifier">eigvecs</span>


<span class="keyword">def</span> <span class="identifier">weighted_mode</span><span class="grouping">(</span><span class="identifier">a</span><span class="punctuation">,</span> <span class="identifier">w</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Returns an array of the weighted modal (most common) value in a.

    If there is more than one such value, only the first is returned.
    The bin-count for the modal bins is also returned.

    This is an extension of the algorithm in scipy.stats.mode.

    Parameters
    ----------
    a : array-like
        n-dimensional array of which to find mode(s).
    w : array-like
        n-dimensional array of weights for each value.
    axis : int, default=0
        Axis along which to operate. Default is 0, i.e. the first axis.

    Returns
    -------
    vals : ndarray
        Array of modal values.
    score : ndarray
        Array of weighted counts for each mode.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.utils.extmath import weighted_mode
    &gt;&gt;&gt; x = [4, 1, 4, 2, 4, 2]
    &gt;&gt;&gt; weights = [1, 1, 1, 1, 1, 1]
    &gt;&gt;&gt; weighted_mode(x, weights)
    (array([4.]), array([3.]))

    The value 4 appears three times: with uniform weights, the result is
    simply the mode of the distribution.

    &gt;&gt;&gt; weights = [1, 3, 0.5, 1.5, 1, 2]  # deweight the 4's
    &gt;&gt;&gt; weighted_mode(x, weights)
    (array([2.]), array([3.5]))

    The value 2 has the highest score: it appears twice with weights of
    1.5 and 2: the sum of these is 3.5.

    See Also
    --------
    scipy.stats.mode
    """</span>
    <span class="keyword">if</span> <span class="identifier">axis</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">a</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="identifier">a</span><span class="grouping">)</span>
        <span class="identifier">w</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="identifier">w</span><span class="grouping">)</span>
        <span class="identifier">axis</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">a</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">a</span><span class="grouping">)</span>
        <span class="identifier">w</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">w</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">a</span><span class="punctuation">.</span><span class="identifier">shape</span> <span class="relational-operator">!=</span> <span class="identifier">w</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="punctuation">:</span>
        <span class="identifier">w</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">full</span><span class="grouping">(</span><span class="identifier">a</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="punctuation">,</span> <span class="identifier">w</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">w</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

    <span class="identifier">scores</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="identifier">a</span><span class="grouping">)</span><span class="grouping">)</span>       <span class="comment"># get ALL unique values</span>
    <span class="identifier">testshape</span> <span class="arithmetic-assignment">=</span> <span class="identifier">list</span><span class="grouping">(</span><span class="identifier">a</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span>
    <span class="identifier">testshape</span><span class="grouping">[</span><span class="identifier">axis</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>
    <span class="identifier">oldmostfreq</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">testshape</span><span class="grouping">)</span>
    <span class="identifier">oldcounts</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">testshape</span><span class="grouping">)</span>
    <span class="keyword">for</span> <span class="identifier">score</span> <span class="relational-operator">in</span> <span class="identifier">scores</span><span class="punctuation">:</span>
        <span class="identifier">template</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">a</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span>
        <span class="identifier">ind</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">a</span> <span class="relational-operator">==</span> <span class="identifier">score</span><span class="grouping">)</span>
        <span class="identifier">template</span><span class="grouping">[</span><span class="identifier">ind</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">w</span><span class="grouping">[</span><span class="identifier">ind</span><span class="grouping">]</span>
        <span class="identifier">counts</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">expand_dims</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">template</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="grouping">)</span>
        <span class="identifier">mostfrequent</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">where</span><span class="grouping">(</span><span class="identifier">counts</span> <span class="relational-operator">&gt;</span> <span class="identifier">oldcounts</span><span class="punctuation">,</span> <span class="identifier">score</span><span class="punctuation">,</span> <span class="identifier">oldmostfreq</span><span class="grouping">)</span>
        <span class="identifier">oldcounts</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">maximum</span><span class="grouping">(</span><span class="identifier">counts</span><span class="punctuation">,</span> <span class="identifier">oldcounts</span><span class="grouping">)</span>
        <span class="identifier">oldmostfreq</span> <span class="arithmetic-assignment">=</span> <span class="identifier">mostfrequent</span>
    <span class="keyword">return</span> <span class="identifier">mostfrequent</span><span class="punctuation">,</span> <span class="identifier">oldcounts</span>


<span class="keyword">def</span> <span class="identifier">cartesian</span><span class="grouping">(</span><span class="identifier">arrays</span><span class="punctuation">,</span> <span class="identifier">out</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Generate a cartesian product of input arrays.

    Parameters
    ----------
    arrays : list of array-like
        1-D arrays to form the cartesian product of.
    out : ndarray, default=None
        Array to place the cartesian product in.

    Returns
    -------
    out : ndarray
        2-D array of shape (M, len(arrays)) containing cartesian products
        formed of input arrays.

    Examples
    --------
    &gt;&gt;&gt; cartesian(([1, 2, 3], [4, 5], [6, 7]))
    array([[1, 4, 6],
           [1, 4, 7],
           [1, 5, 6],
           [1, 5, 7],
           [2, 4, 6],
           [2, 4, 7],
           [2, 5, 6],
           [2, 5, 7],
           [3, 4, 6],
           [3, 4, 7],
           [3, 5, 6],
           [3, 5, 7]])

    Notes
    -----
    This function may not be used on more than 32 arrays
    because the underlying numpy functions do not support it.
    """</span>
    <span class="identifier">arrays</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">x</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">x</span> <span class="relational-operator">in</span> <span class="identifier">arrays</span><span class="grouping">]</span>
    <span class="identifier">shape</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">x</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">x</span> <span class="relational-operator">in</span> <span class="identifier">arrays</span><span class="grouping">)</span>
    <span class="identifier">dtype</span> <span class="arithmetic-assignment">=</span> <span class="identifier">arrays</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">dtype</span>

    <span class="identifier">ix</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">indices</span><span class="grouping">(</span><span class="identifier">shape</span><span class="grouping">)</span>
    <span class="identifier">ix</span> <span class="arithmetic-assignment">=</span> <span class="identifier">ix</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">arrays</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">T</span>

    <span class="keyword">if</span> <span class="identifier">out</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">out</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty_like</span><span class="grouping">(</span><span class="identifier">ix</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">dtype</span><span class="grouping">)</span>

    <span class="keyword">for</span> <span class="identifier">n</span><span class="punctuation">,</span> <span class="identifier">arr</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">arrays</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">out</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">n</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">arrays</span><span class="grouping">[</span><span class="identifier">n</span><span class="grouping">]</span><span class="grouping">[</span><span class="identifier">ix</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">n</span><span class="grouping">]</span><span class="grouping">]</span>

    <span class="keyword">return</span> <span class="identifier">out</span>


<span class="keyword">def</span> <span class="identifier">svd_flip</span><span class="grouping">(</span><span class="identifier">u</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">u_based_decision</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Sign correction to ensure deterministic output from SVD.

    Adjusts the columns of u and the rows of v such that the loadings in the
    columns in u that are largest in absolute value are always positive.

    Parameters
    ----------
    u : ndarray
        u and v are the output of `linalg.svd` or
        :func:`~sklearn.utils.extmath.randomized_svd`, with matching inner
        dimensions so one can compute `np.dot(u * s, v)`.

    v : ndarray
        u and v are the output of `linalg.svd` or
        :func:`~sklearn.utils.extmath.randomized_svd`, with matching inner
        dimensions so one can compute `np.dot(u * s, v)`.
        The input v should really be called vt to be consistent with scipy's
        ouput.

    u_based_decision : bool, default=True
        If True, use the columns of u as the basis for sign flipping.
        Otherwise, use the rows of v. The choice of which variable to base the
        decision on is generally algorithm dependent.


    Returns
    -------
    u_adjusted, v_adjusted : arrays with the same dimensions as the input.

    """</span>
    <span class="keyword">if</span> <span class="identifier">u_based_decision</span><span class="punctuation">:</span>
        <span class="comment"># columns of u, rows of v</span>
        <span class="identifier">max_abs_cols</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argmax</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">u</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
        <span class="identifier">signs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sign</span><span class="grouping">(</span><span class="identifier">u</span><span class="grouping">[</span><span class="identifier">max_abs_cols</span><span class="punctuation">,</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">u</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="identifier">u</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">signs</span>
        <span class="identifier">v</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">signs</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="comment"># rows of v, columns of u</span>
        <span class="identifier">max_abs_rows</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argmax</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">v</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span>
        <span class="identifier">signs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sign</span><span class="grouping">(</span><span class="identifier">v</span><span class="grouping">[</span><span class="identifier">range</span><span class="grouping">(</span><span class="identifier">v</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">max_abs_rows</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="identifier">u</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">signs</span>
        <span class="identifier">v</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">signs</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
    <span class="keyword">return</span> <span class="identifier">u</span><span class="punctuation">,</span> <span class="identifier">v</span>


<span class="keyword">def</span> <span class="identifier">log_logistic</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">out</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Compute the log of the logistic function, ``log(1 / (1 + e ** -x))``.

    This implementation is numerically stable because it splits positive and
    negative values::

        -log(1 + exp(-x_i))     if x_i &gt; 0
        x_i - log(1 + exp(x_i)) if x_i &lt;= 0

    For the ordinary logistic function, use ``scipy.special.expit``.

    Parameters
    ----------
    X : array-like of shape (M, N) or (M,)
        Argument to the logistic function.

    out : array-like of shape (M, N) or (M,), default=None
        Preallocated output array.

    Returns
    -------
    out : ndarray of shape (M, N) or (M,)
        Log of the logistic function evaluated at every point in x.

    Notes
    -----
    See the blog post describing this implementation:
    http://fa.bianp.net/blog/2013/numerical-optimizers-for-logistic-regression/
    """</span>
    <span class="identifier">is_1d</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">1</span>
    <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">atleast_2d</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="grouping">)</span>

    <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>

    <span class="keyword">if</span> <span class="identifier">out</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">out</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty_like</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

    <span class="identifier">_log_logistic_sigmoid</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">out</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">is_1d</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">squeeze</span><span class="grouping">(</span><span class="identifier">out</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">out</span>


<span class="keyword">def</span> <span class="identifier">softmax</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""
    Calculate the softmax function.

    The softmax function is calculated by
    np.exp(X) / np.sum(np.exp(X), axis=1)

    This will cause overflow when large values are exponentiated.
    Hence the largest value in each row is subtracted from each data
    point to prevent this.

    Parameters
    ----------
    X : array-like of float of shape (M, N)
        Argument to the logistic function.

    copy : bool, default=True
        Copy X or not.

    Returns
    -------
    out : ndarray of shape (M, N)
        Softmax function evaluated at every point in x.
    """</span>
    <span class="keyword">if</span> <span class="identifier">copy</span><span class="punctuation">:</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="identifier">max_prob</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">max</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="identifier">X</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">max_prob</span>
    <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">exp</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span>
    <span class="identifier">sum_prob</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="identifier">X</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">sum_prob</span>
    <span class="keyword">return</span> <span class="identifier">X</span>


<span class="keyword">def</span> <span class="identifier">make_nonnegative</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">min_value</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Ensure `X.min()` &gt;= `min_value`.

    Parameters
    ----------
    X : array-like
        The matrix to make non-negative.
    min_value : float, default=0
        The threshold value.

    Returns
    -------
    array-like
        The thresholded array.

    Raises
    ------
    ValueError
        When X is sparse.
    """</span>
    <span class="identifier">min_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">min</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">min_</span> <span class="relational-operator">&lt;</span> <span class="identifier">min_value</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Cannot make the data matrix"</span>
                             <span class="string-literal">" nonnegative because it is sparse."</span>
                             <span class="string-literal">" Adding a value to every entry would"</span>
                             <span class="string-literal">" make it no longer sparse."</span><span class="grouping">)</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span> <span class="arithmetic-operator">+</span> <span class="grouping">(</span><span class="identifier">min_value</span> <span class="arithmetic-operator">-</span> <span class="identifier">min_</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">X</span>


<span class="comment"># Use at least float64 for the accumulating functions to avoid precision issue</span>
<span class="comment"># see https://github.com/numpy/numpy/issues/9393. The float64 is also retained</span>
<span class="comment"># as it is in case the float overflows</span>
<span class="keyword">def</span> <span class="identifier">_safe_accumulator_op</span><span class="grouping">(</span><span class="identifier">op</span><span class="punctuation">,</span> <span class="identifier">x</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="identifier">args</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">kwargs</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""
    This function provides numpy accumulator functions with a float64 dtype
    when used on a floating point input. This prevents accumulator overflow on
    smaller floating point dtypes.

    Parameters
    ----------
    op : function
        A numpy accumulator function such as np.mean or np.sum.
    x : ndarray
        A numpy array to apply the accumulator function.
    *args : positional arguments
        Positional arguments passed to the accumulator function after the
        input x.
    **kwargs : keyword arguments
        Keyword arguments passed to the accumulator function.

    Returns
    -------
    result
        The output of the accumulator function passed to this function.
    """</span>
    <span class="keyword">if</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">issubdtype</span><span class="grouping">(</span><span class="identifier">x</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">floating</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">x</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">.</span><span class="identifier">itemsize</span> <span class="relational-operator">&lt;</span> <span class="int-literal">8</span><span class="punctuation">:</span>
        <span class="identifier">result</span> <span class="arithmetic-assignment">=</span> <span class="identifier">op</span><span class="grouping">(</span><span class="identifier">x</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="identifier">args</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">kwargs</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">result</span> <span class="arithmetic-assignment">=</span> <span class="identifier">op</span><span class="grouping">(</span><span class="identifier">x</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="identifier">args</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">kwargs</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">result</span>


<span class="keyword">def</span> <span class="identifier">_incremental_mean_and_var</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">last_mean</span><span class="punctuation">,</span> <span class="identifier">last_variance</span><span class="punctuation">,</span> <span class="identifier">last_sample_count</span><span class="punctuation">,</span>
                              <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Calculate mean update and a Youngs and Cramer variance update.

    If sample_weight is given, the weighted mean and variance is computed.

    Update a given mean and (possibly) variance according to new data given
    in X. last_mean is always required to compute the new mean.
    If last_variance is None, no variance is computed and None return for
    updated_variance.

    From the paper "Algorithms for computing the sample variance: analysis and
    recommendations", by Chan, Golub, and LeVeque.

    Parameters
    ----------
    X : array-like of shape (n_samples, n_features)
        Data to use for variance update.

    last_mean : array-like of shape (n_features,)

    last_variance : array-like of shape (n_features,)

    last_sample_count : array-like of shape (n_features,)
        The number of samples encountered until now if sample_weight is None.
        If sample_weight is not None, this is the sum of sample_weight
        encountered.

    sample_weight : array-like of shape (n_samples,) or None
        Sample weights. If None, compute the unweighted mean/variance.

    Returns
    -------
    updated_mean : ndarray of shape (n_features,)

    updated_variance : ndarray of shape (n_features,)
        None if last_variance was None.

    updated_sample_count : ndarray of shape (n_features,)

    Notes
    -----
    NaNs are ignored during the algorithm.

    References
    ----------
    T. Chan, G. Golub, R. LeVeque. Algorithms for computing the sample
        variance: recommendations, The American Statistician, Vol. 37, No. 3,
        pp. 242-247

    Also, see the sparse implementation of this in
    `utils.sparsefuncs.incr_mean_variance_axis` and
    `utils.sparsefuncs_fast.incr_mean_variance_axis0`
    """</span>
    <span class="comment"># old = stats until now</span>
    <span class="comment"># new = the current increment</span>
    <span class="comment"># updated = the aggregated stats</span>
    <span class="identifier">last_sum</span> <span class="arithmetic-assignment">=</span> <span class="identifier">last_mean</span> <span class="arithmetic-operator">*</span> <span class="identifier">last_sample_count</span>
    <span class="keyword">if</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">np_version</span> <span class="relational-operator">&gt;=</span> <span class="identifier">parse_version</span><span class="grouping">(</span><span class="string-literal">"1.16.6"</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># equivalent to np.nansum(X * sample_weight, axis=0)</span>
            <span class="comment"># safer because np.float64(X*W) != np.float64(X)*np.float64(W)</span>
            <span class="comment"># dtype arg of np.matmul only exists since version 1.16</span>
            <span class="identifier">new_sum</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_safe_accumulator_op</span><span class="grouping">(</span>
                <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">matmul</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">where</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">isnan</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">new_sum</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_safe_accumulator_op</span><span class="grouping">(</span>
                <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">nansum</span><span class="punctuation">,</span> <span class="identifier">X</span> <span class="arithmetic-operator">*</span> <span class="identifier">sample_weight</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
        <span class="identifier">new_sample_count</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_safe_accumulator_op</span><span class="grouping">(</span>
            <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="bitwise-operator">~</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">isnan</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">new_sum</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_safe_accumulator_op</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">nansum</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
        <span class="identifier">new_sample_count</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="bitwise-operator">~</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">isnan</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>

    <span class="identifier">updated_sample_count</span> <span class="arithmetic-assignment">=</span> <span class="identifier">last_sample_count</span> <span class="arithmetic-operator">+</span> <span class="identifier">new_sample_count</span>

    <span class="identifier">updated_mean</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">last_sum</span> <span class="arithmetic-operator">+</span> <span class="identifier">new_sum</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">updated_sample_count</span>

    <span class="keyword">if</span> <span class="identifier">last_variance</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">updated_variance</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">T</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_sum</span> <span class="arithmetic-operator">/</span> <span class="identifier">new_sample_count</span>
        <span class="keyword">if</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">np_version</span> <span class="relational-operator">&gt;=</span> <span class="identifier">parse_version</span><span class="grouping">(</span><span class="string-literal">"1.16.6"</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="comment"># equivalent to np.nansum((X-T)**2 * sample_weight, axis=0)</span>
                <span class="comment"># safer because np.float64(X*W) != np.float64(X)*np.float64(W)</span>
                <span class="comment"># dtype arg of np.matmul only exists since version 1.16</span>
                <span class="identifier">new_unnormalized_variance</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_safe_accumulator_op</span><span class="grouping">(</span>
                    <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">matmul</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span>
                    <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">where</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">isnan</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">X</span> <span class="arithmetic-operator">-</span> <span class="identifier">T</span><span class="grouping">)</span><span class="arithmetic-operator">**</span><span class="int-literal">2</span><span class="grouping">)</span><span class="grouping">)</span>
                <span class="identifier">correction</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_safe_accumulator_op</span><span class="grouping">(</span>
                    <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">matmul</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">where</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">isnan</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">X</span> <span class="arithmetic-operator">-</span> <span class="identifier">T</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">new_unnormalized_variance</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_safe_accumulator_op</span><span class="grouping">(</span>
                    <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">nansum</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">X</span> <span class="arithmetic-operator">-</span> <span class="identifier">T</span><span class="grouping">)</span><span class="arithmetic-operator">**</span><span class="int-literal">2</span> <span class="arithmetic-operator">*</span> <span class="identifier">sample_weight</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
                <span class="identifier">correction</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_safe_accumulator_op</span><span class="grouping">(</span>
                    <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">nansum</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">X</span> <span class="arithmetic-operator">-</span> <span class="identifier">T</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">sample_weight</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">new_unnormalized_variance</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_safe_accumulator_op</span><span class="grouping">(</span>
                <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">nansum</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">X</span> <span class="arithmetic-operator">-</span> <span class="identifier">T</span><span class="grouping">)</span><span class="arithmetic-operator">**</span><span class="int-literal">2</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
            <span class="identifier">correction</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_safe_accumulator_op</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">nansum</span><span class="punctuation">,</span> <span class="identifier">X</span> <span class="arithmetic-operator">-</span> <span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>

        <span class="comment"># correction term of the corrected 2 pass algorithm.</span>
        <span class="comment"># See "Algorithms for computing the sample variance: analysis</span>
        <span class="comment"># and recommendations", by Chan, Golub, and LeVeque.</span>
        <span class="identifier">new_unnormalized_variance</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">correction</span><span class="arithmetic-operator">**</span><span class="int-literal">2</span> <span class="arithmetic-operator">/</span> <span class="identifier">new_sample_count</span>

        <span class="identifier">last_unnormalized_variance</span> <span class="arithmetic-assignment">=</span> <span class="identifier">last_variance</span> <span class="arithmetic-operator">*</span> <span class="identifier">last_sample_count</span>

        <span class="keyword">with</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">errstate</span><span class="grouping">(</span><span class="identifier">divide</span><span class="arithmetic-assignment">=</span><span class="string-literal">'ignore', invalid='ignore'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">last_over_new_count</span> <span class="arithmetic-assignment">=</span> <span class="identifier">last_sample_count</span> <span class="arithmetic-operator">/</span> <span class="identifier">new_sample_count</span>
            <span class="identifier">updated_unnormalized_variance</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span>
                <span class="identifier">last_unnormalized_variance</span> <span class="arithmetic-operator">+</span> <span class="identifier">new_unnormalized_variance</span> <span class="arithmetic-operator">+</span>
                <span class="identifier">last_over_new_count</span> <span class="arithmetic-operator">/</span> <span class="identifier">updated_sample_count</span> <span class="arithmetic-operator">*</span>
                <span class="grouping">(</span><span class="identifier">last_sum</span> <span class="arithmetic-operator">/</span> <span class="identifier">last_over_new_count</span> <span class="arithmetic-operator">-</span> <span class="identifier">new_sum</span><span class="grouping">)</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="grouping">)</span>

        <span class="identifier">zeros</span> <span class="arithmetic-assignment">=</span> <span class="identifier">last_sample_count</span> <span class="relational-operator">==</span> <span class="int-literal">0</span>
        <span class="identifier">updated_unnormalized_variance</span><span class="grouping">[</span><span class="identifier">zeros</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_unnormalized_variance</span><span class="grouping">[</span><span class="identifier">zeros</span><span class="grouping">]</span>
        <span class="identifier">updated_variance</span> <span class="arithmetic-assignment">=</span> <span class="identifier">updated_unnormalized_variance</span> <span class="arithmetic-operator">/</span> <span class="identifier">updated_sample_count</span>

    <span class="keyword">return</span> <span class="identifier">updated_mean</span><span class="punctuation">,</span> <span class="identifier">updated_variance</span><span class="punctuation">,</span> <span class="identifier">updated_sample_count</span>


<span class="keyword">def</span> <span class="identifier">_deterministic_vector_sign_flip</span><span class="grouping">(</span><span class="identifier">u</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Modify the sign of vectors for reproducibility.

    Flips the sign of elements of all the vectors (rows of u) such that
    the absolute maximum element of each vector is positive.

    Parameters
    ----------
    u : ndarray
        Array with vectors as its rows.

    Returns
    -------
    u_flipped : ndarray with same shape as u
        Array with the sign flipped vectors as its rows.
    """</span>
    <span class="identifier">max_abs_rows</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argmax</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">u</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span>
    <span class="identifier">signs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sign</span><span class="grouping">(</span><span class="identifier">u</span><span class="grouping">[</span><span class="identifier">range</span><span class="grouping">(</span><span class="identifier">u</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">max_abs_rows</span><span class="grouping">]</span><span class="grouping">)</span>
    <span class="identifier">u</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">signs</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
    <span class="keyword">return</span> <span class="identifier">u</span>


<span class="keyword">def</span> <span class="identifier">stable_cumsum</span><span class="grouping">(</span><span class="identifier">arr</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">rtol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-05</span><span class="punctuation">,</span> <span class="identifier">atol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-08</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Use high precision for cumsum and check that final value matches sum.

    Parameters
    ----------
    arr : array-like
        To be cumulatively summed as flat.
    axis : int, default=None
        Axis along which the cumulative sum is computed.
        The default (None) is to compute the cumsum over the flattened array.
    rtol : float, default=1e-05
        Relative tolerance, see ``np.allclose``.
    atol : float, default=1e-08
        Absolute tolerance, see ``np.allclose``.
    """</span>
    <span class="identifier">out</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">cumsum</span><span class="grouping">(</span><span class="identifier">arr</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="identifier">axis</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="grouping">)</span>
    <span class="identifier">expected</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">arr</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="identifier">axis</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">all</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">isclose</span><span class="grouping">(</span><span class="identifier">out</span><span class="punctuation">.</span><span class="identifier">take</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="identifier">axis</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">expected</span><span class="punctuation">,</span> <span class="identifier">rtol</span><span class="arithmetic-assignment">=</span><span class="identifier">rtol</span><span class="punctuation">,</span>
                             <span class="identifier">atol</span><span class="arithmetic-assignment">=</span><span class="identifier">atol</span><span class="punctuation">,</span> <span class="identifier">equal_nan</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">'cumsum was found to be unstable: '</span>
                      <span class="string-literal">'its last element does not correspond to sum'</span><span class="punctuation">,</span>
                      <span class="identifier">RuntimeWarning</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">out</span>

    </pre>
  </body>
</html>