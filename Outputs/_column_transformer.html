<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""
The :mod:`sklearn.compose._column_transformer` module implements utilities
to work with heterogeneous data and to apply different transformers to
different columns.
"""</span>
<span class="comment"># Author: Andreas Mueller</span>
<span class="comment">#         Joris Van den Bossche</span>
<span class="comment"># License: BSD</span>
<span class="keyword">from</span> <span class="identifier">itertools</span> <span class="keyword">import</span> <span class="identifier">chain</span>

<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">from</span> <span class="identifier">scipy</span> <span class="keyword">import</span> <span class="identifier">sparse</span>
<span class="keyword">from</span> <span class="identifier">joblib</span> <span class="keyword">import</span> <span class="identifier">Parallel</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">clone</span><span class="punctuation">,</span> <span class="identifier">TransformerMixin</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">_estimator_html_repr</span> <span class="keyword">import</span> <span class="identifier">_VisualBlock</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">pipeline</span> <span class="keyword">import</span> <span class="identifier">_fit_transform_one</span><span class="punctuation">,</span> <span class="identifier">_transform_one</span><span class="punctuation">,</span> <span class="identifier">_name_estimators</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">preprocessing</span> <span class="keyword">import</span> <span class="identifier">FunctionTransformer</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">Bunch</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">_safe_indexing</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">_get_column_indices</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">metaestimators</span> <span class="keyword">import</span> <span class="identifier">_BaseComposition</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_array</span><span class="punctuation">,</span> <span class="identifier">check_is_fitted</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">fixes</span> <span class="keyword">import</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span>


<span class="identifier">__all__</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span>
    <span class="string-literal">'ColumnTransformer', 'make_column_transformer', 'make_column_selector'</span>
<span class="grouping">]</span>


<span class="identifier">_ERR_MSG_1DCOLUMN</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="string-literal">"1D data passed to a transformer that expects 2D data. "</span>
                     <span class="string-literal">"Try to specify the column selection as a list of one "</span>
                     <span class="string-literal">"item instead of a scalar."</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">ColumnTransformer</span><span class="grouping">(</span><span class="identifier">TransformerMixin</span><span class="punctuation">,</span> <span class="identifier">_BaseComposition</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Applies transformers to columns of an array or pandas DataFrame.

    This estimator allows different columns or column subsets of the input
    to be transformed separately and the features generated by each transformer
    will be concatenated to form a single feature space.
    This is useful for heterogeneous or columnar data, to combine several
    feature extraction mechanisms or transformations into a single transformer.

    Read more in the :ref:`User Guide &lt;column_transformer&gt;`.

    .. versionadded:: 0.20

    Parameters
    ----------
    transformers : list of tuples
        List of (name, transformer, columns) tuples specifying the
        transformer objects to be applied to subsets of the data.

        name : str
            Like in Pipeline and FeatureUnion, this allows the transformer and
            its parameters to be set using ``set_params`` and searched in grid
            search.
        transformer : {'drop', 'passthrough'} or estimator
            Estimator must support :term:`fit` and :term:`transform`.
            Special-cased strings 'drop' and 'passthrough' are accepted as
            well, to indicate to drop the columns or to pass them through
            untransformed, respectively.
        columns :  str, array-like of str, int, array-like of int, \
                array-like of bool, slice or callable
            Indexes the data on its second axis. Integers are interpreted as
            positional columns, while strings can reference DataFrame columns
            by name.  A scalar string or int should be used where
            ``transformer`` expects X to be a 1d array-like (vector),
            otherwise a 2d array will be passed to the transformer.
            A callable is passed the input data `X` and can return any of the
            above. To select multiple columns by name or dtype, you can use
            :obj:`make_column_selector`.

    remainder : {'drop', 'passthrough'} or estimator, default='drop'
        By default, only the specified columns in `transformers` are
        transformed and combined in the output, and the non-specified
        columns are dropped. (default of ``'drop'``).
        By specifying ``remainder='passthrough'``, all remaining columns that
        were not specified in `transformers` will be automatically passed
        through. This subset of columns is concatenated with the output of
        the transformers.
        By setting ``remainder`` to be an estimator, the remaining
        non-specified columns will use the ``remainder`` estimator. The
        estimator must support :term:`fit` and :term:`transform`.
        Note that using this feature requires that the DataFrame columns
        input at :term:`fit` and :term:`transform` have identical order.

    sparse_threshold : float, default=0.3
        If the output of the different transformers contains sparse matrices,
        these will be stacked as a sparse matrix if the overall density is
        lower than this value. Use ``sparse_threshold=0`` to always return
        dense.  When the transformed output consists of all dense data, the
        stacked result will be dense, and this keyword will be ignored.

    n_jobs : int, default=None
        Number of jobs to run in parallel.
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

    transformer_weights : dict, default=None
        Multiplicative weights for features per transformer. The output of the
        transformer is multiplied by these weights. Keys are transformer names,
        values the weights.

    verbose : bool, default=False
        If True, the time elapsed while fitting each transformer will be
        printed as it is completed.

    Attributes
    ----------
    transformers_ : list
        The collection of fitted transformers as tuples of
        (name, fitted_transformer, column). `fitted_transformer` can be an
        estimator, 'drop', or 'passthrough'. In case there were no columns
        selected, this will be the unfitted transformer.
        If there are remaining columns, the final element is a tuple of the
        form:
        ('remainder', transformer, remaining_columns) corresponding to the
        ``remainder`` parameter. If there are remaining columns, then
        ``len(transformers_)==len(transformers)+1``, otherwise
        ``len(transformers_)==len(transformers)``.

    named_transformers_ : :class:`~sklearn.utils.Bunch`
        Read-only attribute to access any transformer by given name.
        Keys are transformer names and values are the fitted transformer
        objects.

    sparse_output_ : bool
        Boolean flag indicating whether the output of ``transform`` is a
        sparse matrix or a dense numpy array, which depends on the output
        of the individual transformers and the `sparse_threshold` keyword.

    output_indices_ : dict
        A dictionary from each transformer name to a slice, where the slice
        corresponds to indices in the transformed output. This is useful to
        inspect which transformer is responsible for which transformed
        feature(s).

        .. versionadded:: 1.0

    Notes
    -----
    The order of the columns in the transformed feature matrix follows the
    order of how the columns are specified in the `transformers` list.
    Columns of the original feature matrix that are not specified are
    dropped from the resulting transformed feature matrix, unless specified
    in the `passthrough` keyword. Those columns specified with `passthrough`
    are added at the right to the output of the transformers.

    See Also
    --------
    make_column_transformer : Convenience function for
        combining the outputs of multiple transformer objects applied to
        column subsets of the original feature space.
    make_column_selector : Convenience function for selecting
        columns based on datatype or the columns name with a regex pattern.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.compose import ColumnTransformer
    &gt;&gt;&gt; from sklearn.preprocessing import Normalizer
    &gt;&gt;&gt; ct = ColumnTransformer(
    ...     [("norm1", Normalizer(norm='l1'), [0, 1]),
    ...      ("norm2", Normalizer(norm='l1'), slice(2, 4))])
    &gt;&gt;&gt; X = np.array([[0., 1., 2., 2.],
    ...               [1., 1., 0., 1.]])
    &gt;&gt;&gt; # Normalizer scales each row of X to unit norm. A separate scaling
    &gt;&gt;&gt; # is applied for the two first and two last elements of each
    &gt;&gt;&gt; # row independently.
    &gt;&gt;&gt; ct.fit_transform(X)
    array([[0. , 1. , 0.5, 0.5],
           [0.5, 0.5, 0. , 1. ]])

    """</span>
    <span class="identifier">_required_parameters</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="string-literal">'transformers'</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span>
                 <span class="identifier">transformers</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span>
                 <span class="identifier">remainder</span><span class="arithmetic-assignment">=</span><span class="string-literal">'drop'</span><span class="punctuation">,</span>
                 <span class="identifier">sparse_threshold</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.3</span><span class="punctuation">,</span>
                 <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">transformer_weights</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transformers</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">remainder</span> <span class="arithmetic-assignment">=</span> <span class="identifier">remainder</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sparse_threshold</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sparse_threshold</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_jobs</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_weights</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transformer_weights</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">verbose</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">_transformers</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Internal list of transformer only containing the name and
        transformers, dropping the columns. This is for the implementation
        of get_params via BaseComposition._get_params which expects lists
        of tuples of len 2.
        """</span>
        <span class="keyword">return</span> <span class="grouping">[</span><span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformers</span><span class="grouping">]</span>

    <span class="punctuation">@</span><span class="identifier">_transformers</span><span class="punctuation">.</span><span class="identifier">setter</span>
    <span class="keyword">def</span> <span class="identifier">_transformers</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">value</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span>
            <span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="punctuation">,</span> <span class="identifier">col</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="grouping">(</span><span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">col</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">value</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformers</span><span class="grouping">)</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">get_params</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">deep</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Get parameters for this estimator.

        Returns the parameters given in the constructor as well as the
        estimators contained within the `transformers` of the
        `ColumnTransformer`.

        Parameters
        ----------
        deep : bool, default=True
            If True, will return the parameters for this estimator and
            contained subobjects that are estimators.

        Returns
        -------
        params : dict
            Parameter names mapped to their values.
        """</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_get_params</span><span class="grouping">(</span><span class="string-literal">'_transformers'</span><span class="punctuation">,</span> <span class="identifier">deep</span><span class="arithmetic-assignment">=</span><span class="identifier">deep</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">set_params</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">kwargs</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Set the parameters of this estimator.

        Valid parameter keys can be listed with ``get_params()``. Note that you
        can directly set the parameters of the estimators contained in
        `transformers` of `ColumnTransformer`.

        Returns
        -------
        self
        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_set_params</span><span class="grouping">(</span><span class="string-literal">'_transformers'</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">kwargs</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">_iter</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">fitted</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">replace_strings</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
              <span class="identifier">column_as_strings</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Generate (name, trans, column, weight) tuples.

        If fitted=True, use the fitted transformers, else use the
        user specified transformers updated with converted column names
        and potentially appended with transformer for remainder.

        """</span>
        <span class="keyword">if</span> <span class="identifier">fitted</span><span class="punctuation">:</span>
            <span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformers_</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># interleave the validated column specifiers</span>
            <span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span>
                <span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="punctuation">,</span> <span class="identifier">column</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">column</span>
                <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformers</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_columns</span><span class="grouping">)</span>
            <span class="grouping">]</span>
            <span class="comment"># add transformer tuple for remainder</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_remainder</span><span class="grouping">[</span><span class="int-literal">2</span><span class="grouping">]</span><span class="punctuation">:</span>
                <span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">chain</span><span class="grouping">(</span><span class="identifier">transformers</span><span class="punctuation">,</span> <span class="grouping">[</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_remainder</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="identifier">get_weight</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_weights</span> <span class="logical-operator">or</span> <span class="grouping">{</span><span class="grouping">}</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">get</span>

        <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="punctuation">,</span> <span class="identifier">columns</span> <span class="relational-operator">in</span> <span class="identifier">transformers</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">replace_strings</span><span class="punctuation">:</span>
                <span class="comment"># replace 'passthrough' with identity transformer and</span>
                <span class="comment"># skip in case of 'drop'</span>
                <span class="keyword">if</span> <span class="identifier">trans</span> <span class="relational-operator">==</span> <span class="string-literal">'passthrough'</span><span class="punctuation">:</span>
                    <span class="identifier">trans</span> <span class="arithmetic-assignment">=</span> <span class="identifier">FunctionTransformer</span><span class="grouping">(</span>
                        <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">check_inverse</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span>
                    <span class="grouping">)</span>
                <span class="keyword">elif</span> <span class="identifier">trans</span> <span class="relational-operator">==</span> <span class="string-literal">'drop'</span><span class="punctuation">:</span>
                    <span class="keyword">continue</span>
                <span class="keyword">elif</span> <span class="identifier">_is_empty_column_selection</span><span class="grouping">(</span><span class="identifier">columns</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="keyword">continue</span>

            <span class="keyword">if</span> <span class="identifier">column_as_strings</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_only_str_columns</span><span class="punctuation">:</span>
                <span class="comment"># Convert all columns to using their string labels</span>
                <span class="identifier">columns_is_scalar</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">isscalar</span><span class="grouping">(</span><span class="identifier">columns</span><span class="grouping">)</span>

                <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_transformer_to_input_indices</span><span class="grouping">[</span><span class="identifier">name</span><span class="grouping">]</span>
                <span class="identifier">columns</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_feature_names_in</span><span class="grouping">[</span><span class="identifier">indices</span><span class="grouping">]</span>

                <span class="keyword">if</span> <span class="identifier">columns_is_scalar</span><span class="punctuation">:</span>
                    <span class="comment"># selection is done with one dimension</span>
                    <span class="identifier">columns</span> <span class="arithmetic-assignment">=</span> <span class="identifier">columns</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

            <span class="keyword">yield</span> <span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="punctuation">,</span> <span class="identifier">columns</span><span class="punctuation">,</span> <span class="identifier">get_weight</span><span class="grouping">(</span><span class="identifier">name</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_validate_transformers</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformers</span><span class="punctuation">:</span>
            <span class="keyword">return</span>

        <span class="identifier">names</span><span class="punctuation">,</span> <span class="identifier">transformers</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformers</span><span class="grouping">)</span>

        <span class="comment"># validate names</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_names</span><span class="grouping">(</span><span class="identifier">names</span><span class="grouping">)</span>

        <span class="comment"># validate estimators</span>
        <span class="keyword">for</span> <span class="identifier">t</span> <span class="relational-operator">in</span> <span class="identifier">transformers</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">t</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="string-literal">'drop', 'passthrough'</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">continue</span>
            <span class="keyword">if</span> <span class="grouping">(</span><span class="logical-operator">not</span> <span class="grouping">(</span><span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">t</span><span class="punctuation">,</span> <span class="string-literal">"fit") or hasattr(t, "fit_transform"</span><span class="grouping">)</span><span class="grouping">)</span> <span class="logical-operator">or</span> <span class="logical-operator">not</span>
                    <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">t</span><span class="punctuation">,</span> <span class="string-literal">"transform"</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">"All estimators should implement fit and "</span>
                                <span class="string-literal">"transform, or can be 'drop' or 'passthrough' "</span>
                                <span class="string-literal">"specifiers. '%s' (type %s) doesn't."</span> <span class="arithmetic-operator">%</span>
                                <span class="grouping">(</span><span class="identifier">t</span><span class="punctuation">,</span> <span class="identifier">type</span><span class="grouping">(</span><span class="identifier">t</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_validate_column_callables</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Converts callable column specifications.
        """</span>
        <span class="identifier">all_columns</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
        <span class="identifier">transformer_to_input_indices</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="grouping">}</span>
        <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">columns</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformers</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">callable</span><span class="grouping">(</span><span class="identifier">columns</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">columns</span> <span class="arithmetic-assignment">=</span> <span class="identifier">columns</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
            <span class="identifier">all_columns</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">columns</span><span class="grouping">)</span>
            <span class="identifier">transformer_to_input_indices</span><span class="grouping">[</span><span class="identifier">name</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_get_column_indices</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span>
                                                                     <span class="identifier">columns</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_columns</span> <span class="arithmetic-assignment">=</span> <span class="identifier">all_columns</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_transformer_to_input_indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transformer_to_input_indices</span>

    <span class="keyword">def</span> <span class="identifier">_validate_remainder</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Validates ``remainder`` and defines ``_remainder`` targeting
        the remaining columns.
        """</span>
        <span class="identifier">is_transformer</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="grouping">(</span><span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">remainder</span><span class="punctuation">,</span> <span class="string-literal">"fit"</span><span class="grouping">)</span>
                           <span class="logical-operator">or</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">remainder</span><span class="punctuation">,</span> <span class="string-literal">"fit_transform"</span><span class="grouping">)</span><span class="grouping">)</span>
                          <span class="logical-operator">and</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">remainder</span><span class="punctuation">,</span> <span class="string-literal">"transform"</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">remainder</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="string-literal">'drop', 'passthrough'</span><span class="grouping">)</span>
                <span class="logical-operator">and</span> <span class="logical-operator">not</span> <span class="identifier">is_transformer</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">"The remainder keyword needs to be one of 'drop', "</span>
                <span class="string-literal">"'passthrough', or estimator. '%s' was passed instead"</span> <span class="arithmetic-operator">%</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">remainder</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>
        <span class="identifier">cols</span> <span class="arithmetic-assignment">=</span> <span class="identifier">set</span><span class="grouping">(</span><span class="identifier">chain</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_transformer_to_input_indices</span><span class="punctuation">.</span><span class="identifier">values</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">remaining</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sorted</span><span class="grouping">(</span><span class="identifier">set</span><span class="grouping">(</span><span class="identifier">range</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_features</span><span class="grouping">)</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">cols</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_remainder</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="string-literal">'remainder'</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">remainder</span><span class="punctuation">,</span> <span class="identifier">remaining</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_transformer_to_input_indices</span><span class="grouping">[</span><span class="string-literal">'remainder'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">remaining</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">named_transformers_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Access the fitted transformer by name.

        Read-only attribute to access any transformer by given name.
        Keys are transformer names and values are the fitted transformer
        objects.

        """</span>
        <span class="comment"># Use Bunch object to improve autocomplete</span>
        <span class="keyword">return</span> <span class="identifier">Bunch</span><span class="grouping">(</span><span class="arithmetic-operator">**</span><span class="grouping">{</span><span class="identifier">name</span><span class="punctuation">:</span> <span class="identifier">trans</span> <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="punctuation">,</span> <span class="identifier">_</span>
                        <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformers_</span><span class="grouping">}</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">get_feature_names</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Get feature names from all transformers.

        Returns
        -------
        feature_names : list of strings
            Names of the features produced by transform.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="identifier">feature_names</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
        <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="punctuation">,</span> <span class="identifier">column</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="identifier">fitted</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">trans</span> <span class="relational-operator">==</span> <span class="string-literal">'drop'</span> <span class="logical-operator">or</span> <span class="identifier">_is_empty_column_selection</span><span class="grouping">(</span><span class="identifier">column</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">continue</span>
            <span class="keyword">if</span> <span class="identifier">trans</span> <span class="relational-operator">==</span> <span class="string-literal">'passthrough'</span><span class="punctuation">:</span>
                <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_feature_names_in</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                    <span class="keyword">if</span> <span class="grouping">(</span><span class="grouping">(</span><span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">column</span><span class="punctuation">,</span> <span class="identifier">slice</span><span class="grouping">)</span><span class="grouping">)</span>
                            <span class="logical-operator">and</span> <span class="identifier">all</span><span class="grouping">(</span><span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">col</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">col</span> <span class="relational-operator">in</span> <span class="identifier">column</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
                        <span class="identifier">feature_names</span><span class="punctuation">.</span><span class="identifier">extend</span><span class="grouping">(</span><span class="identifier">column</span><span class="grouping">)</span>
                    <span class="keyword">else</span><span class="punctuation">:</span>
                        <span class="identifier">feature_names</span><span class="punctuation">.</span><span class="identifier">extend</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_feature_names_in</span><span class="grouping">[</span><span class="identifier">column</span><span class="grouping">]</span><span class="grouping">)</span>
                <span class="keyword">else</span><span class="punctuation">:</span>
                    <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_features</span><span class="grouping">)</span>
                    <span class="identifier">feature_names</span><span class="punctuation">.</span><span class="identifier">extend</span><span class="grouping">(</span><span class="grouping">[</span><span class="string-literal">'x%d'</span> <span class="arithmetic-operator">%</span> <span class="identifier">i</span> <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">column</span><span class="grouping">]</span><span class="grouping">]</span><span class="grouping">)</span>
                <span class="keyword">continue</span>
            <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">trans</span><span class="punctuation">,</span> <span class="string-literal">'get_feature_names'</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">AttributeError</span><span class="grouping">(</span><span class="string-literal">"Transformer %s (type %s) does not "</span>
                                     <span class="string-literal">"provide get_feature_names."</span>
                                     <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">str</span><span class="grouping">(</span><span class="identifier">name</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">type</span><span class="grouping">(</span><span class="identifier">trans</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__name__</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">feature_names</span><span class="punctuation">.</span><span class="identifier">extend</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">f</span><span class="string-literal">"{name}__{f}"</span> <span class="keyword">for</span> <span class="identifier">f</span> <span class="relational-operator">in</span>
                                  <span class="identifier">trans</span><span class="punctuation">.</span><span class="identifier">get_feature_names</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">feature_names</span>

    <span class="keyword">def</span> <span class="identifier">_update_fitted_transformers</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">transformers</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># transformers are fitted; excludes 'drop' cases</span>
        <span class="identifier">fitted_transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">iter</span><span class="grouping">(</span><span class="identifier">transformers</span><span class="grouping">)</span>
        <span class="identifier">transformers_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>

        <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">old</span><span class="punctuation">,</span> <span class="identifier">column</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">old</span> <span class="relational-operator">==</span> <span class="string-literal">'drop'</span><span class="punctuation">:</span>
                <span class="identifier">trans</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'drop'</span>
            <span class="keyword">elif</span> <span class="identifier">old</span> <span class="relational-operator">==</span> <span class="string-literal">'passthrough'</span><span class="punctuation">:</span>
                <span class="comment"># FunctionTransformer is present in list of transformers,</span>
                <span class="comment"># so get next transformer, but save original string</span>
                <span class="identifier">next</span><span class="grouping">(</span><span class="identifier">fitted_transformers</span><span class="grouping">)</span>
                <span class="identifier">trans</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'passthrough'</span>
            <span class="keyword">elif</span> <span class="identifier">_is_empty_column_selection</span><span class="grouping">(</span><span class="identifier">column</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">trans</span> <span class="arithmetic-assignment">=</span> <span class="identifier">old</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">trans</span> <span class="arithmetic-assignment">=</span> <span class="identifier">next</span><span class="grouping">(</span><span class="identifier">fitted_transformers</span><span class="grouping">)</span>
            <span class="identifier">transformers_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="punctuation">,</span> <span class="identifier">column</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="comment"># sanity check that transformers is exhausted</span>
        <span class="keyword">assert</span> <span class="logical-operator">not</span> <span class="identifier">list</span><span class="grouping">(</span><span class="identifier">fitted_transformers</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformers_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transformers_</span>

    <span class="keyword">def</span> <span class="identifier">_validate_output</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">result</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Ensure that the output of each transformer is 2D. Otherwise
        hstack can raise an error or produce incorrect results.
        """</span>
        <span class="identifier">names</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">name</span> <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="identifier">fitted</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                                                      <span class="identifier">replace_strings</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="grouping">]</span>
        <span class="keyword">for</span> <span class="identifier">Xs</span><span class="punctuation">,</span> <span class="identifier">name</span> <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">result</span><span class="punctuation">,</span> <span class="identifier">names</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">Xs</span><span class="punctuation">,</span> <span class="string-literal">'ndim'</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">2</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                    <span class="string-literal">"The output of the '{0}' transformer should be 2D (scipy "</span>
                    <span class="string-literal">"matrix, array, or pandas DataFrame)."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">name</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_record_output_indices</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">Xs</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Record which transformer produced which column.
        """</span>
        <span class="identifier">idx</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">output_indices_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="grouping">}</span>

        <span class="keyword">for</span> <span class="identifier">transformer_idx</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="grouping">)</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="identifier">fitted</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">replace_strings</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">n_columns</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Xs</span><span class="grouping">[</span><span class="identifier">transformer_idx</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">output_indices_</span><span class="grouping">[</span><span class="identifier">name</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">slice</span><span class="grouping">(</span><span class="identifier">idx</span><span class="punctuation">,</span> <span class="identifier">idx</span> <span class="arithmetic-operator">+</span> <span class="identifier">n_columns</span><span class="grouping">)</span>
            <span class="identifier">idx</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">n_columns</span>

        <span class="comment"># `_iter` only generates transformers that have a non empty</span>
        <span class="comment"># selection. Here we set empty slices for transformers that</span>
        <span class="comment"># generate no output, which are safe for indexing</span>
        <span class="identifier">all_names</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">t</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="keyword">for</span> <span class="identifier">t</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformers</span><span class="grouping">]</span> <span class="arithmetic-operator">+</span> <span class="grouping">[</span><span class="string-literal">'remainder'</span><span class="grouping">]</span>
        <span class="keyword">for</span> <span class="identifier">name</span> <span class="relational-operator">in</span> <span class="identifier">all_names</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">name</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">output_indices_</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">output_indices_</span><span class="grouping">[</span><span class="identifier">name</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">slice</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_log_message</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">idx</span><span class="punctuation">,</span> <span class="identifier">total</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="none-literal">None</span>
        <span class="keyword">return</span> <span class="string-literal">'(%d of %d) Processing %s'</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">idx</span><span class="punctuation">,</span> <span class="identifier">total</span><span class="punctuation">,</span> <span class="identifier">name</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_fit_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">func</span><span class="punctuation">,</span> <span class="identifier">fitted</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                       <span class="identifier">column_as_strings</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Private function to fit and/or transform on demand.

        Return value (transformers and/or transformed X data) depends
        on the passed function.
        ``fitted=True`` ensures the fitted transformers are used.
        """</span>
        <span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">list</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span>
                <span class="identifier">fitted</span><span class="arithmetic-assignment">=</span><span class="identifier">fitted</span><span class="punctuation">,</span> <span class="identifier">replace_strings</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                <span class="identifier">column_as_strings</span><span class="arithmetic-assignment">=</span><span class="identifier">column_as_strings</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">try</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">Parallel</span><span class="grouping">(</span><span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span><span class="grouping">)</span><span class="grouping">(</span>
                <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">(</span><span class="identifier">func</span><span class="grouping">)</span><span class="grouping">(</span>
                    <span class="identifier">transformer</span><span class="arithmetic-assignment">=</span><span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">trans</span><span class="grouping">)</span> <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">fitted</span> <span class="keyword">else</span> <span class="identifier">trans</span><span class="punctuation">,</span>
                    <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="identifier">_safe_indexing</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">column</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">,</span>
                    <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="identifier">y</span><span class="punctuation">,</span>
                    <span class="identifier">weight</span><span class="arithmetic-assignment">=</span><span class="identifier">weight</span><span class="punctuation">,</span>
                    <span class="identifier">message_clsname</span><span class="arithmetic-assignment">=</span><span class="string-literal">'ColumnTransformer'</span><span class="punctuation">,</span>
                    <span class="identifier">message</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_log_message</span><span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">idx</span><span class="punctuation">,</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">transformers</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
                <span class="keyword">for</span> <span class="identifier">idx</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="punctuation">,</span> <span class="identifier">column</span><span class="punctuation">,</span> <span class="identifier">weight</span><span class="grouping">)</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span>
                    <span class="identifier">transformers</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">except</span> <span class="identifier">ValueError</span> <span class="keyword">as</span> <span class="identifier">e</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="string-literal">"Expected 2D array, got 1D array instead"</span> <span class="relational-operator">in</span> <span class="identifier">str</span><span class="grouping">(</span><span class="identifier">e</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="identifier">_ERR_MSG_1DCOLUMN</span><span class="grouping">)</span> <span class="keyword">from</span> <span class="identifier">e</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="keyword">raise</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit all transformers using X.

        Parameters
        ----------
        X : {array-like, dataframe} of shape (n_samples, n_features)
            Input data, of which specified subsets are used to fit the
            transformers.

        y : array-like of shape (n_samples,...), default=None
            Targets for supervised learning.

        Returns
        -------
        self : ColumnTransformer
            This estimator

        """</span>
        <span class="comment"># we use fit_transform to make sure to set sparse_output_ (for which we</span>
        <span class="comment"># need the transformed data) to have consistent output type in predict</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit all transformers, transform the data and concatenate results.

        Parameters
        ----------
        X : {array-like, dataframe} of shape (n_samples, n_features)
            Input data, of which specified subsets are used to fit the
            transformers.

        y : array-like of shape (n_samples,), default=None
            Targets for supervised learning.

        Returns
        -------
        X_t : {array-like, sparse matrix} of \
                shape (n_samples, sum_n_components)
            hstack of results of transformers. sum_n_components is the
            sum of n_components (output dimension) over transformers. If
            any result is a sparse matrix, everything will be converted to
            sparse matrices.

        """</span>
        <span class="comment"># TODO: this should be `feature_names_in_` when we start having it</span>
        <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="string-literal">"columns"</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_feature_names_in</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">columns</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_only_str_columns</span> <span class="arithmetic-assignment">=</span> <span class="identifier">all</span><span class="grouping">(</span><span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">col</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span>
                                         <span class="keyword">for</span> <span class="identifier">col</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_feature_names_in</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_feature_names_in</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_X</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="comment"># set n_features_in_ attribute</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_n_features</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">reset</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_transformers</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_column_callables</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_remainder</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

        <span class="identifier">result</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_fit_transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">_fit_transform_one</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">result</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_update_fitted_transformers</span><span class="grouping">(</span><span class="grouping">[</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="comment"># All transformers are None</span>
            <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">Xs</span><span class="punctuation">,</span> <span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">result</span><span class="grouping">)</span>

        <span class="comment"># determine if concatenated output will be sparse or not</span>
        <span class="keyword">if</span> <span class="identifier">any</span><span class="grouping">(</span><span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">X</span> <span class="relational-operator">in</span> <span class="identifier">Xs</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">nnz</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">nnz</span> <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span> <span class="keyword">else</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">size</span> <span class="keyword">for</span> <span class="identifier">X</span> <span class="relational-operator">in</span> <span class="identifier">Xs</span><span class="grouping">)</span>
            <span class="identifier">total</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
                        <span class="keyword">else</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">size</span> <span class="keyword">for</span> <span class="identifier">X</span> <span class="relational-operator">in</span> <span class="identifier">Xs</span><span class="grouping">)</span>
            <span class="identifier">density</span> <span class="arithmetic-assignment">=</span> <span class="identifier">nnz</span> <span class="arithmetic-operator">/</span> <span class="identifier">total</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sparse_output_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">density</span> <span class="relational-operator">&lt;</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sparse_threshold</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sparse_output_</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_update_fitted_transformers</span><span class="grouping">(</span><span class="identifier">transformers</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_output</span><span class="grouping">(</span><span class="identifier">Xs</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_record_output_indices</span><span class="grouping">(</span><span class="identifier">Xs</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_hstack</span><span class="grouping">(</span><span class="identifier">list</span><span class="grouping">(</span><span class="identifier">Xs</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Transform X separately by each transformer, concatenate results.

        Parameters
        ----------
        X : {array-like, dataframe} of shape (n_samples, n_features)
            The data to be transformed by subset.

        Returns
        -------
        X_t : {array-like, sparse matrix} of \
                shape (n_samples, sum_n_components)
            hstack of results of transformers. sum_n_components is the
            sum of n_components (output dimension) over transformers. If
            any result is a sparse matrix, everything will be converted to
            sparse matrices.

        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_X</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

        <span class="identifier">fit_dataframe_and_transform_dataframe</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_feature_names_in</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="string-literal">"columns"</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">fit_dataframe_and_transform_dataframe</span><span class="punctuation">:</span>
            <span class="identifier">named_transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">named_transformers_</span>
            <span class="comment"># check that all names seen in fit are in transform, unless</span>
            <span class="comment"># they were dropped</span>
            <span class="identifier">non_dropped_indices</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span>
                <span class="identifier">ind</span> <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">ind</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_transformer_to_input_indices</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span>
                <span class="keyword">if</span> <span class="identifier">name</span> <span class="relational-operator">in</span> <span class="identifier">named_transformers</span> <span class="logical-operator">and</span>
                <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">named_transformers</span><span class="grouping">[</span><span class="identifier">name</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span> <span class="logical-operator">and</span>
                <span class="identifier">named_transformers</span><span class="grouping">[</span><span class="identifier">name</span><span class="grouping">]</span> <span class="relational-operator">!=</span> <span class="string-literal">'drop'</span><span class="grouping">]</span>

            <span class="identifier">all_indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">set</span><span class="grouping">(</span><span class="identifier">chain</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">non_dropped_indices</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">all_names</span> <span class="arithmetic-assignment">=</span> <span class="identifier">set</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_feature_names_in</span><span class="grouping">[</span><span class="identifier">ind</span><span class="grouping">]</span> <span class="keyword">for</span> <span class="identifier">ind</span> <span class="relational-operator">in</span> <span class="identifier">all_indices</span><span class="grouping">)</span>

            <span class="identifier">diff</span> <span class="arithmetic-assignment">=</span> <span class="identifier">all_names</span> <span class="arithmetic-operator">-</span> <span class="identifier">set</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">columns</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">diff</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"columns are missing: {diff}"</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># ndarray was used for fitting or transforming, thus we only</span>
            <span class="comment"># check that n_features_in_ is consistent</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_n_features</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">reset</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

        <span class="identifier">Xs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_fit_transform</span><span class="grouping">(</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">_transform_one</span><span class="punctuation">,</span> <span class="identifier">fitted</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
            <span class="identifier">column_as_strings</span><span class="arithmetic-assignment">=</span><span class="identifier">fit_dataframe_and_transform_dataframe</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_output</span><span class="grouping">(</span><span class="identifier">Xs</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">Xs</span><span class="punctuation">:</span>
            <span class="comment"># All transformers are None</span>
            <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_hstack</span><span class="grouping">(</span><span class="identifier">list</span><span class="grouping">(</span><span class="identifier">Xs</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_hstack</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">Xs</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Stacks Xs horizontally.

        This allows subclasses to control the stacking behavior, while reusing
        everything else from ColumnTransformer.

        Parameters
        ----------
        Xs : list of {array-like, sparse matrix, dataframe}
        """</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sparse_output_</span><span class="punctuation">:</span>
            <span class="keyword">try</span><span class="punctuation">:</span>
                <span class="comment"># since all columns should be numeric before stacking them</span>
                <span class="comment"># in a sparse matrix, `check_array` is used for the</span>
                <span class="comment"># dtype conversion if necessary.</span>
                <span class="identifier">converted_Xs</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span>
                                            <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                                            <span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">a</span><span class="invalid">l</span><span class="invalid">l</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
                                <span class="keyword">for</span> <span class="identifier">X</span> <span class="relational-operator">in</span> <span class="identifier">Xs</span><span class="grouping">]</span>
            <span class="keyword">except</span> <span class="identifier">ValueError</span> <span class="keyword">as</span> <span class="identifier">e</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                    <span class="string-literal">"For a sparse output, all columns should "</span>
                    <span class="string-literal">"be a numeric or convertible to a numeric."</span>
                <span class="grouping">)</span> <span class="keyword">from</span> <span class="identifier">e</span>

            <span class="keyword">return</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">hstack</span><span class="grouping">(</span><span class="identifier">converted_Xs</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">tocsr</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">Xs</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">f</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span> <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">f</span><span class="grouping">)</span> <span class="keyword">else</span> <span class="identifier">f</span> <span class="keyword">for</span> <span class="identifier">f</span> <span class="relational-operator">in</span> <span class="identifier">Xs</span><span class="grouping">]</span>
            <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">hstack</span><span class="grouping">(</span><span class="identifier">Xs</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_sk_visual_block_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">remainder</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">remainder</span> <span class="relational-operator">==</span> <span class="string-literal">'drop'</span><span class="punctuation">:</span>
            <span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformers</span>
        <span class="keyword">elif</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">"_remainder"</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">remainder_columns</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_remainder</span><span class="grouping">[</span><span class="int-literal">2</span><span class="grouping">]</span>
            <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_feature_names_in</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span>
                    <span class="identifier">remainder_columns</span> <span class="logical-operator">and</span>
                    <span class="logical-operator">not</span> <span class="identifier">all</span><span class="grouping">(</span><span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">col</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span>
                            <span class="keyword">for</span> <span class="identifier">col</span> <span class="relational-operator">in</span> <span class="identifier">remainder_columns</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">remainder_columns</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span>
                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_feature_names_in</span><span class="grouping">[</span><span class="identifier">remainder_columns</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">tolist</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">chain</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformers</span><span class="punctuation">,</span>
                                 <span class="grouping">[</span><span class="grouping">(</span><span class="string-literal">'remainder'</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">remainder</span><span class="punctuation">,</span>
                                   <span class="identifier">remainder_columns</span><span class="grouping">)</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">chain</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformers</span><span class="punctuation">,</span>
                                 <span class="grouping">[</span><span class="grouping">(</span><span class="string-literal">'remainder', self.remainder, ''</span><span class="grouping">)</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="identifier">names</span><span class="punctuation">,</span> <span class="identifier">transformers</span><span class="punctuation">,</span> <span class="identifier">name_details</span> <span class="arithmetic-assignment">=</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">transformers</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">_VisualBlock</span><span class="grouping">(</span><span class="string-literal">'parallel'</span><span class="punctuation">,</span> <span class="identifier">transformers</span><span class="punctuation">,</span>
                            <span class="identifier">names</span><span class="arithmetic-assignment">=</span><span class="identifier">names</span><span class="punctuation">,</span> <span class="identifier">name_details</span><span class="arithmetic-assignment">=</span><span class="identifier">name_details</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_check_X</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Use check_array only on lists and other non-array-likes / sparse"""</span>
    <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="string-literal">'__array__'</span><span class="grouping">)</span> <span class="logical-operator">or</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">X</span>
    <span class="keyword">return</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">a</span><span class="invalid">l</span><span class="invalid">l</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="string-literal">'allow-nan'</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">object</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_is_empty_column_selection</span><span class="grouping">(</span><span class="identifier">column</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""
    Return True if the column selection is empty (empty list or all-False
    boolean array).

    """</span>
    <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">column</span><span class="punctuation">,</span> <span class="string-literal">'dtype'</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">issubdtype</span><span class="grouping">(</span><span class="identifier">column</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">bool_</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="logical-operator">not</span> <span class="identifier">column</span><span class="punctuation">.</span><span class="identifier">any</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="keyword">elif</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">column</span><span class="punctuation">,</span> <span class="string-literal">'__len__'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">column</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">0</span> <span class="logical-operator">or</span>
                <span class="identifier">all</span><span class="grouping">(</span><span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">col</span><span class="punctuation">,</span> <span class="identifier">bool</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">col</span> <span class="relational-operator">in</span> <span class="identifier">column</span><span class="grouping">)</span>
                <span class="logical-operator">and</span> <span class="logical-operator">not</span> <span class="identifier">any</span><span class="grouping">(</span><span class="identifier">column</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="bool-literal">False</span>


<span class="keyword">def</span> <span class="identifier">_get_transformer_list</span><span class="grouping">(</span><span class="identifier">estimators</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""
    Construct (name, trans, column) tuples from list

    """</span>
    <span class="identifier">transformers</span><span class="punctuation">,</span> <span class="identifier">columns</span> <span class="arithmetic-assignment">=</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">estimators</span><span class="grouping">)</span>
    <span class="identifier">names</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">_name_estimators</span><span class="grouping">(</span><span class="identifier">transformers</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="identifier">transformer_list</span> <span class="arithmetic-assignment">=</span> <span class="identifier">list</span><span class="grouping">(</span><span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">names</span><span class="punctuation">,</span> <span class="identifier">transformers</span><span class="punctuation">,</span> <span class="identifier">columns</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">transformer_list</span>


<span class="keyword">def</span> <span class="identifier">make_column_transformer</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">transformers</span><span class="punctuation">,</span>
                            <span class="identifier">remainder</span><span class="arithmetic-assignment">=</span><span class="string-literal">'drop'</span><span class="punctuation">,</span>
                            <span class="identifier">sparse_threshold</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.3</span><span class="punctuation">,</span>
                            <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                            <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Construct a ColumnTransformer from the given transformers.

    This is a shorthand for the ColumnTransformer constructor; it does not
    require, and does not permit, naming the transformers. Instead, they will
    be given names automatically based on their types. It also does not allow
    weighting with ``transformer_weights``.

    Read more in the :ref:`User Guide &lt;make_column_transformer&gt;`.

    Parameters
    ----------
    *transformers : tuples
        Tuples of the form (transformer, columns) specifying the
        transformer objects to be applied to subsets of the data.

        transformer : {'drop', 'passthrough'} or estimator
            Estimator must support :term:`fit` and :term:`transform`.
            Special-cased strings 'drop' and 'passthrough' are accepted as
            well, to indicate to drop the columns or to pass them through
            untransformed, respectively.
        columns : str,  array-like of str, int, array-like of int, slice, \
                array-like of bool or callable
            Indexes the data on its second axis. Integers are interpreted as
            positional columns, while strings can reference DataFrame columns
            by name. A scalar string or int should be used where
            ``transformer`` expects X to be a 1d array-like (vector),
            otherwise a 2d array will be passed to the transformer.
            A callable is passed the input data `X` and can return any of the
            above. To select multiple columns by name or dtype, you can use
            :obj:`make_column_selector`.

    remainder : {'drop', 'passthrough'} or estimator, default='drop'
        By default, only the specified columns in `transformers` are
        transformed and combined in the output, and the non-specified
        columns are dropped. (default of ``'drop'``).
        By specifying ``remainder='passthrough'``, all remaining columns that
        were not specified in `transformers` will be automatically passed
        through. This subset of columns is concatenated with the output of
        the transformers.
        By setting ``remainder`` to be an estimator, the remaining
        non-specified columns will use the ``remainder`` estimator. The
        estimator must support :term:`fit` and :term:`transform`.

    sparse_threshold : float, default=0.3
        If the transformed output consists of a mix of sparse and dense data,
        it will be stacked as a sparse matrix if the density is lower than this
        value. Use ``sparse_threshold=0`` to always return dense.
        When the transformed output consists of all sparse or all dense data,
        the stacked result will be sparse or dense, respectively, and this
        keyword will be ignored.

    n_jobs : int, default=None
        Number of jobs to run in parallel.
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

    verbose : bool, default=False
        If True, the time elapsed while fitting each transformer will be
        printed as it is completed.

    Returns
    -------
    ct : ColumnTransformer

    See Also
    --------
    ColumnTransformer : Class that allows combining the
        outputs of multiple transformer objects used on column subsets
        of the data into a single feature space.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler, OneHotEncoder
    &gt;&gt;&gt; from sklearn.compose import make_column_transformer
    &gt;&gt;&gt; make_column_transformer(
    ...     (StandardScaler(), ['numerical_column']),
    ...     (OneHotEncoder(), ['categorical_column']))
    ColumnTransformer(transformers=[('standardscaler', StandardScaler(...),
                                     ['numerical_column']),
                                    ('onehotencoder', OneHotEncoder(...),
                                     ['categorical_column'])])

    """</span>
    <span class="comment"># transformer_weights keyword is not passed through because the user</span>
    <span class="comment"># would need to know the automatically generated names of the transformers</span>
    <span class="identifier">transformer_list</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_get_transformer_list</span><span class="grouping">(</span><span class="identifier">transformers</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">ColumnTransformer</span><span class="grouping">(</span><span class="identifier">transformer_list</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">n_jobs</span><span class="punctuation">,</span>
                             <span class="identifier">remainder</span><span class="arithmetic-assignment">=</span><span class="identifier">remainder</span><span class="punctuation">,</span>
                             <span class="identifier">sparse_threshold</span><span class="arithmetic-assignment">=</span><span class="identifier">sparse_threshold</span><span class="punctuation">,</span>
                             <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">make_column_selector</span><span class="punctuation">:</span>
    <span class="comment">"""Create a callable to select columns to be used with
    :class:`ColumnTransformer`.

    :func:`make_column_selector` can select columns based on datatype or the
    columns name with a regex. When using multiple selection criteria, **all**
    criteria must match for a column to be selected.

    Parameters
    ----------
    pattern : str, default=None
        Name of columns containing this regex pattern will be included. If
        None, column selection will not be selected based on pattern.

    dtype_include : column dtype or list of column dtypes, default=None
        A selection of dtypes to include. For more details, see
        :meth:`pandas.DataFrame.select_dtypes`.

    dtype_exclude : column dtype or list of column dtypes, default=None
        A selection of dtypes to exclude. For more details, see
        :meth:`pandas.DataFrame.select_dtypes`.

    Returns
    -------
    selector : callable
        Callable for column selection to be used by a
        :class:`ColumnTransformer`.

    See Also
    --------
    ColumnTransformer : Class that allows combining the
        outputs of multiple transformer objects used on column subsets
        of the data into a single feature space.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler, OneHotEncoder
    &gt;&gt;&gt; from sklearn.compose import make_column_transformer
    &gt;&gt;&gt; from sklearn.compose import make_column_selector
    &gt;&gt;&gt; import pandas as pd  # doctest: +SKIP
    &gt;&gt;&gt; X = pd.DataFrame({'city': ['London', 'London', 'Paris', 'Sallisaw'],
    ...                   'rating': [5, 3, 4, 5]})  # doctest: +SKIP
    &gt;&gt;&gt; ct = make_column_transformer(
    ...       (StandardScaler(),
    ...        make_column_selector(dtype_include=np.number)),  # rating
    ...       (OneHotEncoder(),
    ...        make_column_selector(dtype_include=object)))  # city
    &gt;&gt;&gt; ct.fit_transform(X)  # doctest: +SKIP
    array([[ 0.90453403,  1.        ,  0.        ,  0.        ],
           [-1.50755672,  1.        ,  0.        ,  0.        ],
           [-0.30151134,  0.        ,  1.        ,  0.        ],
           [ 0.90453403,  0.        ,  0.        ,  1.        ]])
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">pattern</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">dtype_include</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">dtype_exclude</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">pattern</span> <span class="arithmetic-assignment">=</span> <span class="identifier">pattern</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dtype_include</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dtype_include</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dtype_exclude</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dtype_exclude</span>

    <span class="keyword">def</span> <span class="identifier">__call__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">df</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Callable for column selection to be used by a
        :class:`ColumnTransformer`.

        Parameters
        ----------
        df : dataframe of shape (n_features, n_samples)
            DataFrame to select columns from.
        """</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">df</span><span class="punctuation">,</span> <span class="string-literal">'iloc'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"make_column_selector can only be applied to "</span>
                             <span class="string-literal">"pandas dataframes"</span><span class="grouping">)</span>
        <span class="identifier">df_row</span> <span class="arithmetic-assignment">=</span> <span class="identifier">df</span><span class="punctuation">.</span><span class="identifier">iloc</span><span class="grouping">[</span><span class="punctuation">:</span><span class="int-literal">1</span><span class="grouping">]</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dtype_include</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">or</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dtype_exclude</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">df_row</span> <span class="arithmetic-assignment">=</span> <span class="identifier">df_row</span><span class="punctuation">.</span><span class="identifier">select_dtypes</span><span class="grouping">(</span><span class="identifier">include</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dtype_include</span><span class="punctuation">,</span>
                                          <span class="identifier">exclude</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dtype_exclude</span><span class="grouping">)</span>
        <span class="identifier">cols</span> <span class="arithmetic-assignment">=</span> <span class="identifier">df_row</span><span class="punctuation">.</span><span class="identifier">columns</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">pattern</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">cols</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cols</span><span class="grouping">[</span><span class="identifier">cols</span><span class="punctuation">.</span><span class="identifier">str</span><span class="punctuation">.</span><span class="identifier">contains</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">pattern</span><span class="punctuation">,</span> <span class="identifier">regex</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="identifier">cols</span><span class="punctuation">.</span><span class="identifier">tolist</span><span class="grouping">(</span><span class="grouping">)</span>

    </pre>
  </body>
</html>