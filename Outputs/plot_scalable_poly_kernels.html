<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""
=======================================================
Scalable learning with polynomial kernel aproximation
=======================================================

This example illustrates the use of :class:`PolynomialCountSketch` to
efficiently generate polynomial kernel feature-space approximations.
This is used to train linear classifiers that approximate the accuracy
of kernelized ones.

.. currentmodule:: sklearn.kernel_approximation

We use the Covtype dataset [2], trying to reproduce the experiments on the
original paper of Tensor Sketch [1], i.e. the algorithm implemented by
:class:`PolynomialCountSketch`.

First, we compute the accuracy of a linear classifier on the original
features. Then, we train linear classifiers on different numbers of
features (`n_components`) generated by :class:`PolynomialCountSketch`,
approximating the accuracy of a kernelized classifier in a scalable manner.
"""</span>
<span class="identifier">print</span><span class="grouping">(</span><span class="identifier">__doc__</span><span class="grouping">)</span>

<span class="comment"># Author: Daniel Lopez-Sanchez &lt;lope@usal.es&gt;</span>
<span class="comment"># License: BSD 3 clause</span>
<span class="keyword">import</span> <span class="identifier">matplotlib</span><span class="punctuation">.</span><span class="identifier">pyplot</span> <span class="keyword">as</span> <span class="identifier">plt</span>
<span class="keyword">from</span> <span class="identifier">sklearn</span><span class="punctuation">.</span><span class="identifier">datasets</span> <span class="keyword">import</span> <span class="identifier">fetch_covtype</span>
<span class="keyword">from</span> <span class="identifier">sklearn</span><span class="punctuation">.</span><span class="identifier">model_selection</span> <span class="keyword">import</span> <span class="identifier">train_test_split</span>
<span class="keyword">from</span> <span class="identifier">sklearn</span><span class="punctuation">.</span><span class="identifier">preprocessing</span> <span class="keyword">import</span> <span class="identifier">MinMaxScaler</span><span class="punctuation">,</span> <span class="identifier">Normalizer</span>
<span class="keyword">from</span> <span class="identifier">sklearn</span><span class="punctuation">.</span><span class="identifier">svm</span> <span class="keyword">import</span> <span class="identifier">LinearSVC</span>
<span class="keyword">from</span> <span class="identifier">sklearn</span><span class="punctuation">.</span><span class="identifier">kernel_approximation</span> <span class="keyword">import</span> <span class="identifier">PolynomialCountSketch</span>
<span class="keyword">from</span> <span class="identifier">sklearn</span><span class="punctuation">.</span><span class="identifier">pipeline</span> <span class="keyword">import</span> <span class="identifier">Pipeline</span><span class="punctuation">,</span> <span class="identifier">make_pipeline</span>
<span class="keyword">import</span> <span class="identifier">time</span>

<span class="comment"># %%</span>
<span class="comment"># Load the Covtype dataset, which contains 581,012 samples</span>
<span class="comment"># with 54 features each, distributed among 6 classes. The goal of this dataset</span>
<span class="comment"># is to predict forest cover type from cartographic variables only</span>
<span class="comment"># (no remotely sensed data). After loading, we transform it into a binary</span>
<span class="comment"># classification problem to match the version of the dataset in the</span>
<span class="comment"># LIBSVM webpage [2], which was the one used in [1].</span>

<span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fetch_covtype</span><span class="grouping">(</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">X</span><span class="invalid">_</span><span class="invalid">y</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

<span class="identifier">y</span><span class="grouping">[</span><span class="identifier">y</span> <span class="relational-operator">!=</span> <span class="int-literal">2</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
<span class="identifier">y</span><span class="grouping">[</span><span class="identifier">y</span> <span class="relational-operator">==</span> <span class="int-literal">2</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>  <span class="comment"># We will try to separate class 2 from the other 6 classes.</span>

<span class="comment"># %%</span>
<span class="comment"># Here we select 5,000 samples for training and 10,000 for testing.</span>
<span class="comment"># To actually reproduce the results in the original Tensor Sketch paper,</span>
<span class="comment"># select 100,000 for training.</span>

<span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">X_test</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">y_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">train_test_split</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">train_size</span><span class="arithmetic-assignment">=</span><span class="int-literal">5</span><span class="invalid">_</span><span class="int-literal">000</span><span class="punctuation">,</span>
                                                    <span class="identifier">test_size</span><span class="arithmetic-assignment">=</span><span class="int-literal">10</span><span class="invalid">_</span><span class="int-literal">000</span><span class="punctuation">,</span>
                                                    <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="int-literal">42</span><span class="grouping">)</span>

<span class="comment"># %%</span>
<span class="comment"># Now scale features to the range [0, 1] to match the format of the dataset in</span>
<span class="comment"># the LIBSVM webpage, and then normalize to unit length as done in the</span>
<span class="comment"># original Tensor Sketch paper [1].</span>

<span class="identifier">mm</span> <span class="arithmetic-assignment">=</span> <span class="identifier">make_pipeline</span><span class="grouping">(</span><span class="identifier">MinMaxScaler</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">Normalizer</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span>
<span class="identifier">X_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">mm</span><span class="punctuation">.</span><span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">X_train</span><span class="grouping">)</span>
<span class="identifier">X_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">mm</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">X_test</span><span class="grouping">)</span>


<span class="comment"># %%</span>
<span class="comment"># As a baseline, train a linear SVM on the original features and print the</span>
<span class="comment"># accuracy. We also measure and store accuracies and training times to</span>
<span class="comment"># plot them latter.</span>

<span class="identifier">results</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="grouping">}</span>

<span class="identifier">lsvm</span> <span class="arithmetic-assignment">=</span> <span class="identifier">LinearSVC</span><span class="grouping">(</span><span class="grouping">)</span>
<span class="identifier">start</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="punctuation">.</span><span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
<span class="identifier">lsvm</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="grouping">)</span>
<span class="identifier">lsvm_time</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="punctuation">.</span><span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">start</span>
<span class="identifier">lsvm_score</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">100</span> <span class="arithmetic-operator">*</span> <span class="identifier">lsvm</span><span class="punctuation">.</span><span class="identifier">score</span><span class="grouping">(</span><span class="identifier">X_test</span><span class="punctuation">,</span> <span class="identifier">y_test</span><span class="grouping">)</span>

<span class="identifier">results</span><span class="grouping">[</span><span class="string-literal">"LSVM"] = {"time": lsvm_time, "score"</span><span class="punctuation">:</span> <span class="identifier">lsvm_score</span><span class="grouping">}</span>
<span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Linear SVM score on raw features: {lsvm_score:.2f}%"</span><span class="grouping">)</span>

<span class="comment"># %%</span>
<span class="comment"># Then we train linear SVMs on the features generated by</span>
<span class="comment"># :class:`PolynomialCountSketch` with different values for `n_components`,</span>
<span class="comment"># showing that these kernel feature approximations improve the accuracy</span>
<span class="comment"># of linear classification. In typical application scenarios, `n_components`</span>
<span class="comment"># should be larger than the number of features in the input representation</span>
<span class="comment"># in order to achieve an improvement with respect to linear classification.</span>
<span class="comment"># As a rule of thumb, the optimum of evaluation score / run time cost is</span>
<span class="comment"># typically achieved at around `n_components` = 10 * `n_features`, though this</span>
<span class="comment"># might depend on the specific dataset being handled. Note that, since the</span>
<span class="comment"># original samples have 54 features, the explicit feature map of the</span>
<span class="comment"># polynomial kernel of degree four would have approximately 8.5 million</span>
<span class="comment"># features (precisely, 54^4). Thanks to :class:`PolynomialCountSketch`, we can</span>
<span class="comment"># condense most of the discriminative information of that feature space into a</span>
<span class="comment"># much more compact representation. We repeat the experiment 5 times to</span>
<span class="comment"># compensate for the stochastic nature of :class:`PolynomialCountSketch`.</span>

<span class="identifier">n_runs</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">3</span>
<span class="keyword">for</span> <span class="identifier">n_components</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="int-literal">250</span><span class="punctuation">,</span> <span class="int-literal">500</span><span class="punctuation">,</span> <span class="int-literal">1000</span><span class="punctuation">,</span> <span class="int-literal">2000</span><span class="grouping">]</span><span class="punctuation">:</span>

    <span class="identifier">ps_lsvm_time</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
    <span class="identifier">ps_lsvm_score</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
    <span class="keyword">for</span> <span class="identifier">_</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_runs</span><span class="grouping">)</span><span class="punctuation">:</span>

        <span class="identifier">pipeline</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Pipeline</span><span class="grouping">(</span><span class="identifier">steps</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="grouping">(</span><span class="string-literal">"kernel_approximator"</span><span class="punctuation">,</span>
                                    <span class="identifier">PolynomialCountSketch</span><span class="grouping">(</span>
                                        <span class="identifier">n_components</span><span class="arithmetic-assignment">=</span><span class="identifier">n_components</span><span class="punctuation">,</span>
                                        <span class="identifier">degree</span><span class="arithmetic-assignment">=</span><span class="int-literal">4</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">,</span>
                                   <span class="grouping">(</span><span class="string-literal">"linear_classifier"</span><span class="punctuation">,</span> <span class="identifier">LinearSVC</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="identifier">start</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="punctuation">.</span><span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">pipeline</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="grouping">)</span>
        <span class="identifier">ps_lsvm_time</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">time</span><span class="punctuation">.</span><span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">start</span>
        <span class="identifier">ps_lsvm_score</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">100</span> <span class="arithmetic-operator">*</span> <span class="identifier">pipeline</span><span class="punctuation">.</span><span class="identifier">score</span><span class="grouping">(</span><span class="identifier">X_test</span><span class="punctuation">,</span> <span class="identifier">y_test</span><span class="grouping">)</span>

    <span class="identifier">ps_lsvm_time</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">n_runs</span>
    <span class="identifier">ps_lsvm_score</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">n_runs</span>

    <span class="identifier">results</span><span class="grouping">[</span><span class="identifier">f</span><span class="string-literal">"LSVM + PS({n_components})"</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span>
        <span class="string-literal">"time": ps_lsvm_time, "score"</span><span class="punctuation">:</span> <span class="identifier">ps_lsvm_score</span>
    <span class="grouping">}</span>
    <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Linear SVM score on {n_components} PolynomialCountSketch "</span> <span class="arithmetic-operator">+</span>
          <span class="identifier">f</span><span class="string-literal">"features: {ps_lsvm_score:.2f}%"</span><span class="grouping">)</span>

<span class="comment"># %%</span>
<span class="comment"># Train a kernelized SVM to see how well :class:`PolynomialCountSketch`</span>
<span class="comment"># is approximating the performance of the kernel. This, of course, may take</span>
<span class="comment"># some time, as the SVC class has a relatively poor scalability. This is the</span>
<span class="comment"># reason why kernel approximators are so useful:</span>

<span class="keyword">from</span> <span class="identifier">sklearn</span><span class="punctuation">.</span><span class="identifier">svm</span> <span class="keyword">import</span> <span class="identifier">SVC</span>

<span class="identifier">ksvm</span> <span class="arithmetic-assignment">=</span> <span class="identifier">SVC</span><span class="grouping">(</span><span class="identifier">C</span><span class="arithmetic-assignment">=</span><span class="int-literal">500</span><span class="punctuation">.</span><span class="punctuation">,</span> <span class="identifier">kernel</span><span class="arithmetic-assignment">=</span><span class="string-literal">"poly"</span><span class="punctuation">,</span> <span class="identifier">degree</span><span class="arithmetic-assignment">=</span><span class="int-literal">4</span><span class="punctuation">,</span> <span class="identifier">coef0</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">gamma</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">.</span><span class="grouping">)</span>

<span class="identifier">start</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="punctuation">.</span><span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
<span class="identifier">ksvm</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="grouping">)</span>
<span class="identifier">ksvm_time</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="punctuation">.</span><span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">start</span>
<span class="identifier">ksvm_score</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">100</span> <span class="arithmetic-operator">*</span> <span class="identifier">ksvm</span><span class="punctuation">.</span><span class="identifier">score</span><span class="grouping">(</span><span class="identifier">X_test</span><span class="punctuation">,</span> <span class="identifier">y_test</span><span class="grouping">)</span>

<span class="identifier">results</span><span class="grouping">[</span><span class="string-literal">"KSVM"] = {"time": ksvm_time, "score"</span><span class="punctuation">:</span> <span class="identifier">ksvm_score</span><span class="grouping">}</span>
<span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Kernel-SVM score on raw featrues: {ksvm_score:.2f}%"</span><span class="grouping">)</span>

<span class="comment"># %%</span>
<span class="comment"># Finally, plot the resuts of the different methods against their training</span>
<span class="comment"># times. As we can see, the kernelized SVM achieves a higher accuracy,</span>
<span class="comment"># but its training time is much larger and, most importantly, will grow</span>
<span class="comment"># much faster if the number of training samples increases.</span>

<span class="identifier">N_COMPONENTS</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="int-literal">250</span><span class="punctuation">,</span> <span class="int-literal">500</span><span class="punctuation">,</span> <span class="int-literal">1000</span><span class="punctuation">,</span> <span class="int-literal">2000</span><span class="grouping">]</span>

<span class="identifier">fig</span><span class="punctuation">,</span> <span class="identifier">ax</span> <span class="arithmetic-assignment">=</span> <span class="identifier">plt</span><span class="punctuation">.</span><span class="identifier">subplots</span><span class="grouping">(</span><span class="identifier">figsize</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="int-literal">7</span><span class="punctuation">,</span> <span class="int-literal">7</span><span class="grouping">)</span><span class="grouping">)</span>
<span class="identifier">ax</span><span class="punctuation">.</span><span class="identifier">scatter</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">results</span><span class="grouping">[</span><span class="string-literal">"LSVM"]["time"], ], [results["LSVM"]["score"</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="grouping">]</span><span class="punctuation">,</span>
           <span class="identifier">label</span><span class="arithmetic-assignment">=</span><span class="string-literal">"Linear SVM", c="green", marker="^"</span><span class="grouping">)</span>

<span class="identifier">ax</span><span class="punctuation">.</span><span class="identifier">scatter</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">results</span><span class="grouping">[</span><span class="string-literal">"LSVM + PS(250)"]["time"</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="grouping">]</span><span class="punctuation">,</span>
           <span class="grouping">[</span><span class="identifier">results</span><span class="grouping">[</span><span class="string-literal">"LSVM + PS(250)"]["score"</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="grouping">]</span><span class="punctuation">,</span>
           <span class="identifier">label</span><span class="arithmetic-assignment">=</span><span class="string-literal">"Linear SVM + PolynomialCountSketch", c="blue"</span><span class="grouping">)</span>
<span class="keyword">for</span> <span class="identifier">n_components</span> <span class="relational-operator">in</span> <span class="identifier">N_COMPONENTS</span><span class="punctuation">:</span>
    <span class="identifier">ax</span><span class="punctuation">.</span><span class="identifier">scatter</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">results</span><span class="grouping">[</span><span class="identifier">f</span><span class="string-literal">"LSVM + PS({n_components})"]["time"</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="grouping">]</span><span class="punctuation">,</span>
               <span class="grouping">[</span><span class="identifier">results</span><span class="grouping">[</span><span class="identifier">f</span><span class="string-literal">"LSVM + PS({n_components})"]["score"</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="grouping">]</span><span class="punctuation">,</span>
               <span class="identifier">c</span><span class="arithmetic-assignment">=</span><span class="string-literal">"blue"</span><span class="grouping">)</span>
    <span class="identifier">ax</span><span class="punctuation">.</span><span class="identifier">annotate</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"n_comp.={n_components}"</span><span class="punctuation">,</span>
                <span class="grouping">(</span><span class="identifier">results</span><span class="grouping">[</span><span class="identifier">f</span><span class="string-literal">"LSVM + PS({n_components})"]["time"</span><span class="grouping">]</span><span class="punctuation">,</span>
                 <span class="identifier">results</span><span class="grouping">[</span><span class="identifier">f</span><span class="string-literal">"LSVM + PS({n_components})"]["score"</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">,</span>
                <span class="identifier">xytext</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="int-literal">30</span><span class="punctuation">,</span> <span class="int-literal">10</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">textcoords</span><span class="arithmetic-assignment">=</span><span class="string-literal">"offset pixels"</span><span class="grouping">)</span>

<span class="identifier">ax</span><span class="punctuation">.</span><span class="identifier">scatter</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">results</span><span class="grouping">[</span><span class="string-literal">"KSVM"]["time"], ], [results["KSVM"]["score"</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="grouping">]</span><span class="punctuation">,</span>
           <span class="identifier">label</span><span class="arithmetic-assignment">=</span><span class="string-literal">"Kernel SVM", c="red", marker="x"</span><span class="grouping">)</span>

<span class="identifier">ax</span><span class="punctuation">.</span><span class="identifier">set_xlabel</span><span class="grouping">(</span><span class="string-literal">"Training time (s)"</span><span class="grouping">)</span>
<span class="identifier">ax</span><span class="punctuation">.</span><span class="identifier">set_ylabel</span><span class="grouping">(</span><span class="string-literal">"Accurary (%)"</span><span class="grouping">)</span>
<span class="identifier">ax</span><span class="punctuation">.</span><span class="identifier">legend</span><span class="grouping">(</span><span class="grouping">)</span>
<span class="identifier">plt</span><span class="punctuation">.</span><span class="identifier">show</span><span class="grouping">(</span><span class="grouping">)</span>

<span class="comment"># %%</span>
<span class="comment"># References</span>
<span class="comment"># ==========</span>
<span class="comment">#</span>
<span class="comment"># [1] Pham, Ninh and Rasmus Pagh. "Fast and scalable polynomial kernels via</span>
<span class="comment"># explicit feature maps." KDD '13 (2013).</span>
<span class="comment"># https://doi.org/10.1145/2487575.2487591</span>
<span class="comment">#</span>
<span class="comment"># [2] LIBSVM binary datasets repository</span>
<span class="comment"># https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/binary.html</span>

    </pre>
  </body>
</html>