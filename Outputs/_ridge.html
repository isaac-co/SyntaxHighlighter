<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""
Ridge regression
"""</span>

<span class="comment"># Author: Mathieu Blondel &lt;mathieu@mblondel.org&gt;</span>
<span class="comment">#         Reuben Fletcher-Costin &lt;reuben.fletchercostin@gmail.com&gt;</span>
<span class="comment">#         Fabian Pedregosa &lt;fabian@fseoane.net&gt;</span>
<span class="comment">#         Michael Eickenberg &lt;michael.eickenberg@nsup.org&gt;</span>
<span class="comment"># License: BSD 3 clause</span>


<span class="keyword">from</span> <span class="identifier">abc</span> <span class="keyword">import</span> <span class="identifier">ABCMeta</span><span class="punctuation">,</span> <span class="identifier">abstractmethod</span>
<span class="keyword">import</span> <span class="identifier">warnings</span>

<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">from</span> <span class="identifier">scipy</span> <span class="keyword">import</span> <span class="identifier">linalg</span>
<span class="keyword">from</span> <span class="identifier">scipy</span> <span class="keyword">import</span> <span class="identifier">sparse</span>
<span class="keyword">from</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">sparse</span> <span class="keyword">import</span> <span class="identifier">linalg</span> <span class="keyword">as</span> <span class="identifier">sp_linalg</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_base</span> <span class="keyword">import</span> <span class="identifier">LinearClassifierMixin</span><span class="punctuation">,</span> <span class="identifier">LinearModel</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_base</span> <span class="keyword">import</span> <span class="identifier">_deprecate_normalize</span><span class="punctuation">,</span> <span class="identifier">_rescale_data</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_sag</span> <span class="keyword">import</span> <span class="identifier">sag_solver</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">RegressorMixin</span><span class="punctuation">,</span> <span class="identifier">MultiOutputMixin</span><span class="punctuation">,</span> <span class="identifier">is_classifier</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">extmath</span> <span class="keyword">import</span> <span class="identifier">safe_sparse_dot</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">extmath</span> <span class="keyword">import</span> <span class="identifier">row_norms</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">check_array</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">check_consistent_length</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">compute_sample_weight</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">column_or_1d</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">_check_sample_weight</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">preprocessing</span> <span class="keyword">import</span> <span class="identifier">LabelBinarizer</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">model_selection</span> <span class="keyword">import</span> <span class="identifier">GridSearchCV</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">metrics</span> <span class="keyword">import</span> <span class="identifier">check_scoring</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="invalid">e</span><span class="invalid">x</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="invalid">i</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">s</span> <span class="keyword">import</span> <span class="identifier">ConvergenceWarning</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">sparsefuncs</span> <span class="keyword">import</span> <span class="identifier">mean_variance_axis</span>


<span class="keyword">def</span> <span class="identifier">_solve_sparse_cg</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span>
                     <span class="identifier">X_offset</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">X_scale</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>

    <span class="keyword">def</span> <span class="identifier">_get_rescaled_operator</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>

        <span class="identifier">X_offset_scale</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_offset</span> <span class="arithmetic-operator">/</span> <span class="identifier">X_scale</span>

        <span class="keyword">def</span> <span class="identifier">matvec</span><span class="grouping">(</span><span class="identifier">b</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">b</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">b</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X_offset_scale</span><span class="grouping">)</span>

        <span class="keyword">def</span> <span class="identifier">rmatvec</span><span class="grouping">(</span><span class="identifier">b</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">b</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">X_offset_scale</span> <span class="arithmetic-operator">*</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">b</span><span class="grouping">)</span>

        <span class="identifier">X1</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">LinearOperator</span><span class="grouping">(</span><span class="identifier">shape</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="punctuation">,</span>
                                          <span class="identifier">matvec</span><span class="arithmetic-assignment">=</span><span class="identifier">matvec</span><span class="punctuation">,</span>
                                          <span class="identifier">rmatvec</span><span class="arithmetic-assignment">=</span><span class="identifier">rmatvec</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">X1</span>

    <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>

    <span class="keyword">if</span> <span class="identifier">X_offset</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="logical-operator">or</span> <span class="identifier">X_scale</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">X1</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sp_linalg</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">l</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">e</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">o</span><span class="invalid">p</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">o</span><span class="invalid">r</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">X1</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_get_rescaled_operator</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

    <span class="identifier">coefs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">n_features</span> <span class="relational-operator">&gt;</span> <span class="identifier">n_samples</span><span class="punctuation">:</span>
        <span class="keyword">def</span> <span class="identifier">create_mv</span><span class="grouping">(</span><span class="identifier">curr_alpha</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">def</span> <span class="identifier">_mv</span><span class="grouping">(</span><span class="identifier">x</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">return</span> <span class="identifier">X1</span><span class="punctuation">.</span><span class="identifier">matvec</span><span class="grouping">(</span><span class="identifier">X1</span><span class="punctuation">.</span><span class="identifier">rmatvec</span><span class="grouping">(</span><span class="identifier">x</span><span class="grouping">)</span><span class="grouping">)</span> <span class="arithmetic-operator">+</span> <span class="identifier">curr_alpha</span> <span class="arithmetic-operator">*</span> <span class="identifier">x</span>
            <span class="keyword">return</span> <span class="identifier">_mv</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">def</span> <span class="identifier">create_mv</span><span class="grouping">(</span><span class="identifier">curr_alpha</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">def</span> <span class="identifier">_mv</span><span class="grouping">(</span><span class="identifier">x</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">return</span> <span class="identifier">X1</span><span class="punctuation">.</span><span class="identifier">rmatvec</span><span class="grouping">(</span><span class="identifier">X1</span><span class="punctuation">.</span><span class="identifier">matvec</span><span class="grouping">(</span><span class="identifier">x</span><span class="grouping">)</span><span class="grouping">)</span> <span class="arithmetic-operator">+</span> <span class="identifier">curr_alpha</span> <span class="arithmetic-operator">*</span> <span class="identifier">x</span>
            <span class="keyword">return</span> <span class="identifier">_mv</span>

    <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">y_column</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="grouping">]</span>

        <span class="identifier">mv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">create_mv</span><span class="grouping">(</span><span class="identifier">alpha</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">n_features</span> <span class="relational-operator">&gt;</span> <span class="identifier">n_samples</span><span class="punctuation">:</span>
            <span class="comment"># kernel ridge</span>
            <span class="comment"># w = X.T * inv(X X^t + alpha*Id) y</span>
            <span class="identifier">C</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sp_linalg</span><span class="punctuation">.</span><span class="identifier">LinearOperator</span><span class="grouping">(</span>
                <span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">matvec</span><span class="arithmetic-assignment">=</span><span class="identifier">mv</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
            <span class="comment"># FIXME atol</span>
            <span class="keyword">try</span><span class="punctuation">:</span>
                <span class="identifier">coef</span><span class="punctuation">,</span> <span class="identifier">info</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sp_linalg</span><span class="punctuation">.</span><span class="identifier">cg</span><span class="grouping">(</span><span class="identifier">C</span><span class="punctuation">,</span> <span class="identifier">y_column</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">atol</span><span class="arithmetic-assignment">=</span><span class="string-literal">'legacy'</span><span class="grouping">)</span>
            <span class="keyword">except</span> <span class="identifier">TypeError</span><span class="punctuation">:</span>
                <span class="comment"># old scipy</span>
                <span class="identifier">coef</span><span class="punctuation">,</span> <span class="identifier">info</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sp_linalg</span><span class="punctuation">.</span><span class="identifier">cg</span><span class="grouping">(</span><span class="identifier">C</span><span class="punctuation">,</span> <span class="identifier">y_column</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="grouping">)</span>
            <span class="identifier">coefs</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X1</span><span class="punctuation">.</span><span class="identifier">rmatvec</span><span class="grouping">(</span><span class="identifier">coef</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># linear ridge</span>
            <span class="comment"># w = inv(X^t X + alpha*Id) * X.T y</span>
            <span class="identifier">y_column</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X1</span><span class="punctuation">.</span><span class="identifier">rmatvec</span><span class="grouping">(</span><span class="identifier">y_column</span><span class="grouping">)</span>
            <span class="identifier">C</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sp_linalg</span><span class="punctuation">.</span><span class="identifier">LinearOperator</span><span class="grouping">(</span>
                <span class="grouping">(</span><span class="identifier">n_features</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">matvec</span><span class="arithmetic-assignment">=</span><span class="identifier">mv</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
            <span class="comment"># FIXME atol</span>
            <span class="keyword">try</span><span class="punctuation">:</span>
                <span class="identifier">coefs</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">info</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sp_linalg</span><span class="punctuation">.</span><span class="identifier">cg</span><span class="grouping">(</span><span class="identifier">C</span><span class="punctuation">,</span> <span class="identifier">y_column</span><span class="punctuation">,</span> <span class="identifier">maxiter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
                                              <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">atol</span><span class="arithmetic-assignment">=</span><span class="string-literal">'legacy'</span><span class="grouping">)</span>
            <span class="keyword">except</span> <span class="identifier">TypeError</span><span class="punctuation">:</span>
                <span class="comment"># old scipy</span>
                <span class="identifier">coefs</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">info</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sp_linalg</span><span class="punctuation">.</span><span class="identifier">cg</span><span class="grouping">(</span><span class="identifier">C</span><span class="punctuation">,</span> <span class="identifier">y_column</span><span class="punctuation">,</span> <span class="identifier">maxiter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
                                              <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">info</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Failed with error code %d"</span> <span class="arithmetic-operator">%</span> <span class="identifier">info</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">max_iter</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">info</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span> <span class="logical-operator">and</span> <span class="identifier">verbose</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">"sparse_cg did not converge after %d iterations."</span> <span class="arithmetic-operator">%</span>
                          <span class="identifier">info</span><span class="punctuation">,</span> <span class="identifier">ConvergenceWarning</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">coefs</span>


<span class="keyword">def</span> <span class="identifier">_solve_lsqr</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>
    <span class="identifier">coefs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
    <span class="identifier">n_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">int32</span><span class="grouping">)</span>

    <span class="comment"># According to the lsqr documentation, alpha = damp^2.</span>
    <span class="identifier">sqrt_alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">alpha</span><span class="grouping">)</span>

    <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">y_column</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="grouping">]</span>
        <span class="identifier">info</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sp_linalg</span><span class="punctuation">.</span><span class="identifier">lsqr</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y_column</span><span class="punctuation">,</span> <span class="identifier">damp</span><span class="arithmetic-assignment">=</span><span class="identifier">sqrt_alpha</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span>
                              <span class="identifier">atol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">btol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">iter_lim</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="grouping">)</span>
        <span class="identifier">coefs</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">info</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">n_iter</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">info</span><span class="grouping">[</span><span class="int-literal">2</span><span class="grouping">]</span>

    <span class="keyword">return</span> <span class="identifier">coefs</span><span class="punctuation">,</span> <span class="identifier">n_iter</span>


<span class="keyword">def</span> <span class="identifier">_solve_cholesky</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment"># w = inv(X^t X + alpha*Id) * X.T y</span>
    <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>
    <span class="identifier">n_targets</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>

    <span class="identifier">A</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
    <span class="identifier">Xy</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

    <span class="identifier">one_alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array_equal</span><span class="grouping">(</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">alpha</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="grouping">[</span><span class="identifier">alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">]</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">one_alpha</span><span class="punctuation">:</span>
        <span class="identifier">A</span><span class="punctuation">.</span><span class="identifier">flat</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="identifier">n_features</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">solve</span><span class="grouping">(</span><span class="identifier">A</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="punctuation">,</span> <span class="identifier">sym_pos</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                            <span class="identifier">overwrite_a</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">T</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">coefs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">n_targets</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">coef</span><span class="punctuation">,</span> <span class="identifier">target</span><span class="punctuation">,</span> <span class="identifier">current_alpha</span> <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">coefs</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">A</span><span class="punctuation">.</span><span class="identifier">flat</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="identifier">n_features</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">current_alpha</span>
            <span class="identifier">coef</span><span class="grouping">[</span><span class="punctuation">:</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">solve</span><span class="grouping">(</span><span class="identifier">A</span><span class="punctuation">,</span> <span class="identifier">target</span><span class="punctuation">,</span> <span class="identifier">sym_pos</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                                   <span class="identifier">overwrite_a</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="identifier">A</span><span class="punctuation">.</span><span class="identifier">flat</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="identifier">n_features</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">current_alpha</span>
        <span class="keyword">return</span> <span class="identifier">coefs</span>


<span class="keyword">def</span> <span class="identifier">_solve_cholesky_kernel</span><span class="grouping">(</span><span class="identifier">K</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment"># dual_coef = inv(X X^t + alpha*Id) y</span>
    <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">K</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
    <span class="identifier">n_targets</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>

    <span class="keyword">if</span> <span class="identifier">copy</span><span class="punctuation">:</span>
        <span class="identifier">K</span> <span class="arithmetic-assignment">=</span> <span class="identifier">K</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">atleast_1d</span><span class="grouping">(</span><span class="identifier">alpha</span><span class="grouping">)</span>
    <span class="identifier">one_alpha</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">alpha</span> <span class="relational-operator">==</span> <span class="identifier">alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">all</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="identifier">has_sw</span> <span class="arithmetic-assignment">=</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ndarray</span><span class="grouping">)</span> <span class="invalid">\</span>
        <span class="logical-operator">or</span> <span class="identifier">sample_weight</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="float-literal">1.0</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">]</span>

    <span class="keyword">if</span> <span class="identifier">has_sw</span><span class="punctuation">:</span>
        <span class="comment"># Unlike other solvers, we need to support sample_weight directly</span>
        <span class="comment"># because K might be a pre-computed kernel.</span>
        <span class="identifier">sw</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">atleast_1d</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span> <span class="arithmetic-operator">*</span> <span class="identifier">sw</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
        <span class="identifier">K</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">outer</span><span class="grouping">(</span><span class="identifier">sw</span><span class="punctuation">,</span> <span class="identifier">sw</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">one_alpha</span><span class="punctuation">:</span>
        <span class="comment"># Only one penalty, we can solve multi-target problems in one time.</span>
        <span class="identifier">K</span><span class="punctuation">.</span><span class="identifier">flat</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="identifier">n_samples</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

        <span class="keyword">try</span><span class="punctuation">:</span>
            <span class="comment"># Note: we must use overwrite_a=False in order to be able to</span>
            <span class="comment">#       use the fall-back solution below in case a LinAlgError</span>
            <span class="comment">#       is raised</span>
            <span class="identifier">dual_coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">solve</span><span class="grouping">(</span><span class="identifier">K</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sym_pos</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                                     <span class="identifier">overwrite_a</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="keyword">except</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">LinAlgError</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">"Singular matrix in solving dual problem. Using "</span>
                          <span class="string-literal">"least-squares solution instead."</span><span class="grouping">)</span>
            <span class="identifier">dual_coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">lstsq</span><span class="grouping">(</span><span class="identifier">K</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

        <span class="comment"># K is expensive to compute and store in memory so change it back in</span>
        <span class="comment"># case it was user-given.</span>
        <span class="identifier">K</span><span class="punctuation">.</span><span class="identifier">flat</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="identifier">n_samples</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

        <span class="keyword">if</span> <span class="identifier">has_sw</span><span class="punctuation">:</span>
            <span class="identifier">dual_coef</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">sw</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>

        <span class="keyword">return</span> <span class="identifier">dual_coef</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="comment"># One penalty per target. We need to solve each target separately.</span>
        <span class="identifier">dual_coefs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">n_targets</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">K</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="keyword">for</span> <span class="identifier">dual_coef</span><span class="punctuation">,</span> <span class="identifier">target</span><span class="punctuation">,</span> <span class="identifier">current_alpha</span> <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">dual_coefs</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">K</span><span class="punctuation">.</span><span class="identifier">flat</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="identifier">n_samples</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">current_alpha</span>

            <span class="identifier">dual_coef</span><span class="grouping">[</span><span class="punctuation">:</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">solve</span><span class="grouping">(</span><span class="identifier">K</span><span class="punctuation">,</span> <span class="identifier">target</span><span class="punctuation">,</span> <span class="identifier">sym_pos</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                                        <span class="identifier">overwrite_a</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>

            <span class="identifier">K</span><span class="punctuation">.</span><span class="identifier">flat</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="identifier">n_samples</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">current_alpha</span>

        <span class="keyword">if</span> <span class="identifier">has_sw</span><span class="punctuation">:</span>
            <span class="identifier">dual_coefs</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">sw</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span>

        <span class="keyword">return</span> <span class="identifier">dual_coefs</span><span class="punctuation">.</span><span class="identifier">T</span>


<span class="keyword">def</span> <span class="identifier">_solve_svd</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="identifier">U</span><span class="punctuation">,</span> <span class="identifier">s</span><span class="punctuation">,</span> <span class="identifier">Vt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">svd</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">full_matrices</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
    <span class="identifier">idx</span> <span class="arithmetic-assignment">=</span> <span class="identifier">s</span> <span class="relational-operator">&gt;</span> <span class="float-literal">1e-15</span>  <span class="comment"># same default value as scipy.linalg.pinv</span>
    <span class="identifier">s_nnz</span> <span class="arithmetic-assignment">=</span> <span class="identifier">s</span><span class="grouping">[</span><span class="identifier">idx</span><span class="grouping">]</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
    <span class="identifier">UTy</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">U</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>
    <span class="identifier">d</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">s</span><span class="punctuation">.</span><span class="identifier">size</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">.</span><span class="identifier">size</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
    <span class="identifier">d</span><span class="grouping">[</span><span class="identifier">idx</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">s_nnz</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">s_nnz</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span> <span class="arithmetic-operator">+</span> <span class="identifier">alpha</span><span class="grouping">)</span>
    <span class="identifier">d_UT_y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">d</span> <span class="arithmetic-operator">*</span> <span class="identifier">UTy</span>
    <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">Vt</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">d_UT_y</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">T</span>


<span class="keyword">def</span> <span class="identifier">_get_valid_accept_sparse</span><span class="grouping">(</span><span class="identifier">is_X_sparse</span><span class="punctuation">,</span> <span class="identifier">solver</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="keyword">if</span> <span class="identifier">is_X_sparse</span> <span class="logical-operator">and</span> <span class="identifier">solver</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="string-literal">'auto', 'sag', 'saga'</span><span class="grouping">]</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="string-literal">'csr'</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">[</span><span class="string-literal">'csr', 'csc', 'coo'</span><span class="grouping">]</span>


<span class="keyword">def</span> <span class="identifier">ridge_regression</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">solver</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span>
                     <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                     <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                     <span class="identifier">check_input</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Solve the ridge equation by the method of normal equations.

    Read more in the :ref:`User Guide &lt;ridge_regression&gt;`.

    Parameters
    ----------
    X : {ndarray, sparse matrix, LinearOperator} of shape \
        (n_samples, n_features)
        Training data

    y : ndarray of shape (n_samples,) or (n_samples, n_targets)
        Target values

    alpha : float or array-like of shape (n_targets,)
        Regularization strength; must be a positive float. Regularization
        improves the conditioning of the problem and reduces the variance of
        the estimates. Larger values specify stronger regularization.
        Alpha corresponds to ``1 / (2C)`` in other linear models such as
        :class:`~sklearn.linear_model.LogisticRegression` or
        :class:`~sklearn.svm.LinearSVC`. If an array is passed, penalties are
        assumed to be specific to the targets. Hence they must correspond in
        number.

    sample_weight : float or array-like of shape (n_samples,), default=None
        Individual weights for each sample. If given a float, every sample
        will have the same weight. If sample_weight is not None and
        solver='auto', the solver will be set to 'cholesky'.

        .. versionadded:: 0.17

    solver : {'auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'}, \
        default='auto'
        Solver to use in the computational routines:

        - 'auto' chooses the solver automatically based on the type of data.

        - 'svd' uses a Singular Value Decomposition of X to compute the Ridge
          coefficients. More stable for singular matrices than 'cholesky'.

        - 'cholesky' uses the standard scipy.linalg.solve function to
          obtain a closed-form solution via a Cholesky decomposition of
          dot(X.T, X)

        - 'sparse_cg' uses the conjugate gradient solver as found in
          scipy.sparse.linalg.cg. As an iterative algorithm, this solver is
          more appropriate than 'cholesky' for large-scale data
          (possibility to set `tol` and `max_iter`).

        - 'lsqr' uses the dedicated regularized least-squares routine
          scipy.sparse.linalg.lsqr. It is the fastest and uses an iterative
          procedure.

        - 'sag' uses a Stochastic Average Gradient descent, and 'saga' uses
          its improved, unbiased version named SAGA. Both methods also use an
          iterative procedure, and are often faster than other solvers when
          both n_samples and n_features are large. Note that 'sag' and
          'saga' fast convergence is only guaranteed on features with
          approximately the same scale. You can preprocess the data with a
          scaler from sklearn.preprocessing.


        All last five solvers support both dense and sparse data. However, only
        'sag' and 'sparse_cg' supports sparse input when `fit_intercept` is
        True.

        .. versionadded:: 0.17
           Stochastic Average Gradient descent solver.
        .. versionadded:: 0.19
           SAGA solver.

    max_iter : int, default=None
        Maximum number of iterations for conjugate gradient solver.
        For the 'sparse_cg' and 'lsqr' solvers, the default value is determined
        by scipy.sparse.linalg. For 'sag' and saga solver, the default value is
        1000.

    tol : float, default=1e-3
        Precision of the solution.

    verbose : int, default=0
        Verbosity level. Setting verbose &gt; 0 will display additional
        information depending on the solver used.

    random_state : int, RandomState instance, default=None
        Used when ``solver`` == 'sag' or 'saga' to shuffle the data.
        See :term:`Glossary &lt;random_state&gt;` for details.

    return_n_iter : bool, default=False
        If True, the method also returns `n_iter`, the actual number of
        iteration performed by the solver.

        .. versionadded:: 0.17

    return_intercept : bool, default=False
        If True and if X is sparse, the method also returns the intercept,
        and the solver is automatically changed to 'sag'. This is only a
        temporary fix for fitting the intercept with sparse data. For dense
        data, use sklearn.linear_model._preprocess_data before your regression.

        .. versionadded:: 0.17

    check_input : bool, default=True
        If False, the input arrays X and y will not be checked.

        .. versionadded:: 0.21

    Returns
    -------
    coef : ndarray of shape (n_features,) or (n_targets, n_features)
        Weight vector(s).

    n_iter : int, optional
        The actual number of iteration performed by the solver.
        Only returned if `return_n_iter` is True.

    intercept : float or ndarray of shape (n_targets,)
        The intercept of the model. Only returned if `return_intercept`
        is True and if X is a scipy sparse array.

    Notes
    -----
    This function won't compute the intercept.
    """</span>
    <span class="keyword">return</span> <span class="identifier">_ridge_regression</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span>
                             <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="punctuation">,</span>
                             <span class="identifier">solver</span><span class="arithmetic-assignment">=</span><span class="identifier">solver</span><span class="punctuation">,</span>
                             <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
                             <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span>
                             <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="punctuation">,</span>
                             <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="punctuation">,</span>
                             <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="punctuation">,</span>
                             <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="arithmetic-assignment">=</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="punctuation">,</span>
                             <span class="identifier">X_scale</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                             <span class="identifier">X_offset</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                             <span class="identifier">check_input</span><span class="arithmetic-assignment">=</span><span class="identifier">check_input</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_ridge_regression</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">solver</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span>
                      <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                      <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                      <span class="identifier">X_scale</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">X_offset</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">check_input</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>

    <span class="identifier">has_sw</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span>

    <span class="keyword">if</span> <span class="identifier">solver</span> <span class="relational-operator">==</span> <span class="string-literal">'auto'</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="punctuation">:</span>
            <span class="comment"># only sag supports fitting intercept directly</span>
            <span class="identifier">solver</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"sag"</span>
        <span class="keyword">elif</span> <span class="logical-operator">not</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">solver</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"cholesky"</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">solver</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"sparse_cg"</span>

    <span class="keyword">if</span> <span class="identifier">solver</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="string-literal">'sparse_cg', 'cholesky', 'svd', 'lsqr', 'sag', 'saga'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Known solvers are 'sparse_cg', 'cholesky', 'svd'"</span>
                         <span class="string-literal">" 'lsqr', 'sag' or 'saga'. Got %s."</span> <span class="arithmetic-operator">%</span> <span class="identifier">solver</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span> <span class="logical-operator">and</span> <span class="identifier">solver</span> <span class="relational-operator">!=</span> <span class="string-literal">'sag'</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"In Ridge, only 'sag' solver can directly fit the "</span>
                         <span class="string-literal">"intercept. Please change solver to 'sag' or set "</span>
                         <span class="string-literal">"return_intercept=False."</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">check_input</span><span class="punctuation">:</span>
        <span class="identifier">_dtype</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span>
        <span class="identifier">_accept_sparse</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_get_valid_accept_sparse</span><span class="grouping">(</span><span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">solver</span><span class="grouping">)</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="identifier">_accept_sparse</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">_dtype</span><span class="punctuation">,</span>
                        <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">"C"</span><span class="grouping">)</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span> <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span>
    <span class="identifier">check_consistent_length</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>

    <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>

    <span class="keyword">if</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">&gt;</span> <span class="int-literal">2</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Target y has the wrong shape %s"</span> <span class="arithmetic-operator">%</span> <span class="identifier">str</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="identifier">ravel</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
    <span class="keyword">if</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span>
        <span class="identifier">ravel</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>

    <span class="identifier">n_samples_</span><span class="punctuation">,</span> <span class="identifier">n_targets</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span>

    <span class="keyword">if</span> <span class="identifier">n_samples</span> <span class="relational-operator">!=</span> <span class="identifier">n_samples_</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Number of samples in X and y does not correspond:"</span>
                         <span class="string-literal">" %d != %d"</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_samples_</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">has_sw</span><span class="punctuation">:</span>
        <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_sample_weight</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">solver</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="string-literal">'sag', 'saga'</span><span class="grouping">]</span><span class="punctuation">:</span>
            <span class="comment"># SAG supports sample_weight directly. For other solvers,</span>
            <span class="comment"># we implement sample_weight via a simple rescaling.</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_rescale_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="grouping">)</span>

    <span class="comment"># There should be either 1 or n_targets penalties</span>
    <span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">alpha</span><span class="punctuation">.</span><span class="identifier">size</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">n_targets</span><span class="grouping">]</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Number of targets and number of penalties "</span>
                         <span class="string-literal">"do not correspond: %d != %d"</span>
                         <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">alpha</span><span class="punctuation">.</span><span class="identifier">size</span><span class="punctuation">,</span> <span class="identifier">n_targets</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">alpha</span><span class="punctuation">.</span><span class="identifier">size</span> <span class="relational-operator">==</span> <span class="int-literal">1</span> <span class="logical-operator">and</span> <span class="identifier">n_targets</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">repeat</span><span class="grouping">(</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">n_targets</span><span class="grouping">)</span>

    <span class="identifier">n_iter</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
    <span class="keyword">if</span> <span class="identifier">solver</span> <span class="relational-operator">==</span> <span class="string-literal">'sparse_cg'</span><span class="punctuation">:</span>
        <span class="identifier">coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_solve_sparse_cg</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span>
                                <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
                                <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span>
                                <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="punctuation">,</span>
                                <span class="identifier">X_offset</span><span class="arithmetic-assignment">=</span><span class="identifier">X_offset</span><span class="punctuation">,</span>
                                <span class="identifier">X_scale</span><span class="arithmetic-assignment">=</span><span class="identifier">X_scale</span><span class="grouping">)</span>

    <span class="keyword">elif</span> <span class="identifier">solver</span> <span class="relational-operator">==</span> <span class="string-literal">'lsqr'</span><span class="punctuation">:</span>
        <span class="identifier">coef</span><span class="punctuation">,</span> <span class="identifier">n_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_solve_lsqr</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="grouping">)</span>

    <span class="keyword">elif</span> <span class="identifier">solver</span> <span class="relational-operator">==</span> <span class="string-literal">'cholesky'</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">n_features</span> <span class="relational-operator">&gt;</span> <span class="identifier">n_samples</span><span class="punctuation">:</span>
            <span class="identifier">K</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
            <span class="keyword">try</span><span class="punctuation">:</span>
                <span class="identifier">dual_coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_solve_cholesky_kernel</span><span class="grouping">(</span><span class="identifier">K</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="grouping">)</span>

                <span class="identifier">coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">dual_coef</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">T</span>
            <span class="keyword">except</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">LinAlgError</span><span class="punctuation">:</span>
                <span class="comment"># use SVD solver if matrix is singular</span>
                <span class="identifier">solver</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'svd'</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">try</span><span class="punctuation">:</span>
                <span class="identifier">coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_solve_cholesky</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="grouping">)</span>
            <span class="keyword">except</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">LinAlgError</span><span class="punctuation">:</span>
                <span class="comment"># use SVD solver if matrix is singular</span>
                <span class="identifier">solver</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'svd'</span>

    <span class="keyword">elif</span> <span class="identifier">solver</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="string-literal">'sag', 'saga'</span><span class="grouping">]</span><span class="punctuation">:</span>
        <span class="comment"># precompute max_squared_sum for all targets</span>
        <span class="identifier">max_squared_sum</span> <span class="arithmetic-assignment">=</span> <span class="identifier">row_norms</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">squared</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">max</span><span class="grouping">(</span><span class="grouping">)</span>

        <span class="identifier">coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="identifier">n_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">int32</span><span class="grouping">)</span>
        <span class="identifier">intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">alpha_i</span><span class="punctuation">,</span> <span class="identifier">target</span><span class="grouping">)</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">init</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="string-literal">'coef'</span><span class="punctuation">:</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">n_features</span> <span class="arithmetic-operator">+</span> <span class="identifier">int</span><span class="grouping">(</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">,</span>
                                     <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span><span class="grouping">}</span>
            <span class="identifier">coef_</span><span class="punctuation">,</span> <span class="identifier">n_iter_</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sag_solver</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">target</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="string-literal">'squared'</span><span class="punctuation">,</span> <span class="identifier">alpha_i</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="punctuation">,</span>
                <span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="punctuation">,</span> <span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">max_squared_sum</span><span class="punctuation">,</span>
                <span class="identifier">init</span><span class="punctuation">,</span> <span class="identifier">is_saga</span><span class="arithmetic-assignment">=</span><span class="identifier">solver</span> <span class="relational-operator">==</span> <span class="string-literal">'saga'</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="punctuation">:</span>
                <span class="identifier">coef</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coef_</span><span class="grouping">[</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span>
                <span class="identifier">intercept</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coef_</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">coef</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coef_</span>
            <span class="identifier">n_iter</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_iter_</span>

        <span class="keyword">if</span> <span class="identifier">intercept</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">intercept</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">coef</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">solver</span> <span class="relational-operator">==</span> <span class="string-literal">'svd'</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">'SVD solver does not support sparse'</span>
                            <span class="string-literal">' inputs currently'</span><span class="grouping">)</span>
        <span class="identifier">coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_solve_svd</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">ravel</span><span class="punctuation">:</span>
        <span class="comment"># When y was passed as a 1d-array, we flatten the coefficients.</span>
        <span class="identifier">coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coef</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span> <span class="logical-operator">and</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">coef</span><span class="punctuation">,</span> <span class="identifier">n_iter</span><span class="punctuation">,</span> <span class="identifier">intercept</span>
    <span class="keyword">elif</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">coef</span><span class="punctuation">,</span> <span class="identifier">intercept</span>
    <span class="keyword">elif</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">coef</span><span class="punctuation">,</span> <span class="identifier">n_iter</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">coef</span>


<span class="keyword">class</span> <span class="identifier">_BaseRidge</span><span class="grouping">(</span><span class="identifier">LinearModel</span><span class="punctuation">,</span> <span class="identifier">metaclass</span><span class="arithmetic-assignment">=</span><span class="identifier">ABCMeta</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="punctuation">@</span><span class="identifier">abstractmethod</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="float-literal">1.0</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="string-literal">'deprecated'</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="punctuation">,</span>
                 <span class="identifier">solver</span><span class="arithmetic-assignment">=</span><span class="string-literal">"auto"</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_intercept</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">normalize</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy_X</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span> <span class="arithmetic-assignment">=</span> <span class="identifier">tol</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">solver</span> <span class="arithmetic-assignment">=</span> <span class="identifier">solver</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_deprecate_normalize</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span><span class="punctuation">,</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
            <span class="identifier">estimator_name</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__class__</span><span class="punctuation">.</span><span class="identifier">__name__</span>
        <span class="grouping">)</span>

        <span class="identifier">_dtype</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span>
        <span class="identifier">_accept_sparse</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_get_valid_accept_sparse</span><span class="grouping">(</span><span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span>
                                                  <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">solver</span><span class="grouping">)</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span>
                                   <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="identifier">_accept_sparse</span><span class="punctuation">,</span>
                                   <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">_dtype</span><span class="punctuation">,</span>
                                   <span class="identifier">multi_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">y_numeric</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">solver</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="string-literal">'auto', 'sparse_cg', 'sag'</span><span class="grouping">]</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                    <span class="string-literal">"solver='{}' does not support fitting the intercept "</span>
                    <span class="string-literal">"on sparse data. Please set the solver to 'auto' or "</span>
                    <span class="string-literal">"'sparse_cg', 'sag', or set `fit_intercept=False`"</span>
                    <span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">solver</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">solver</span> <span class="relational-operator">==</span> <span class="string-literal">'sag'</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="logical-operator">and</span>
                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span> <span class="relational-operator">&gt;</span> <span class="float-literal">1e-4</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span>
                    <span class="string-literal">'"sag" solver requires many iterations to fit '</span>
                    <span class="string-literal">'an intercept with sparse inputs. Either set the '</span>
                    <span class="string-literal">'solver to "auto" or "sparse_cg", or set a low '</span>
                    <span class="string-literal">'"tol" and a high "max_iter" (especially if inputs are '</span>
                    <span class="string-literal">'not standardized).'</span><span class="grouping">)</span>
                <span class="identifier">solver</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'sag'</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">solver</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'sparse_cg'</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">solver</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">solver</span>

        <span class="keyword">if</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_sample_weight</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span>
                                                 <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="comment"># when X is sparse we only remove offset from y</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">X_offset</span><span class="punctuation">,</span> <span class="identifier">y_offset</span><span class="punctuation">,</span> <span class="identifier">X_scale</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_preprocess_data</span><span class="grouping">(</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_normalize</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span><span class="punctuation">,</span>
            <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">a</span><span class="invalid">n</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">solver</span> <span class="relational-operator">==</span> <span class="string-literal">'sag'</span> <span class="logical-operator">and</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">intercept_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_ridge_regression</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="punctuation">,</span>
                <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">solver</span><span class="arithmetic-assignment">=</span><span class="string-literal">'sag'</span><span class="punctuation">,</span>
                <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">check_input</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
            <span class="comment"># add the offset which was subtracted by _preprocess_data</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">intercept_</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">y_offset</span>

        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">:</span>
                <span class="comment"># required to fit intercept with sparse_cg solver</span>
                <span class="identifier">params</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="string-literal">'X_offset': X_offset, 'X_scale'</span><span class="punctuation">:</span> <span class="identifier">X_scale</span><span class="grouping">}</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="comment"># for dense matrices or when intercept is set to 0</span>
                <span class="identifier">params</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="grouping">}</span>

            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_ridge_regression</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="punctuation">,</span>
                <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">solver</span><span class="arithmetic-assignment">=</span><span class="identifier">solver</span><span class="punctuation">,</span>
                <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">check_input</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">params</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_set_intercept</span><span class="grouping">(</span><span class="identifier">X_offset</span><span class="punctuation">,</span> <span class="identifier">y_offset</span><span class="punctuation">,</span> <span class="identifier">X_scale</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span>


<span class="keyword">class</span> <span class="identifier">Ridge</span><span class="grouping">(</span><span class="identifier">MultiOutputMixin</span><span class="punctuation">,</span> <span class="identifier">RegressorMixin</span><span class="punctuation">,</span> <span class="identifier">_BaseRidge</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Linear least squares with l2 regularization.

    Minimizes the objective function::

    ||y - Xw||^2_2 + alpha * ||w||^2_2

    This model solves a regression model where the loss function is
    the linear least squares function and regularization is given by
    the l2-norm. Also known as Ridge Regression or Tikhonov regularization.
    This estimator has built-in support for multi-variate regression
    (i.e., when y is a 2d-array of shape (n_samples, n_targets)).

    Read more in the :ref:`User Guide &lt;ridge_regression&gt;`.

    Parameters
    ----------
    alpha : {float, ndarray of shape (n_targets,)}, default=1.0
        Regularization strength; must be a positive float. Regularization
        improves the conditioning of the problem and reduces the variance of
        the estimates. Larger values specify stronger regularization.
        Alpha corresponds to ``1 / (2C)`` in other linear models such as
        :class:`~sklearn.linear_model.LogisticRegression` or
        :class:`~sklearn.svm.LinearSVC`. If an array is passed, penalties are
        assumed to be specific to the targets. Hence they must correspond in
        number.

    fit_intercept : bool, default=True
        Whether to fit the intercept for this model. If set
        to false, no intercept will be used in calculations
        (i.e. ``X`` and ``y`` are expected to be centered).

    normalize : bool, default=False
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

        .. deprecated:: 1.0
            ``normalize`` was deprecated in version 1.0 and
            will be removed in 1.2.

    copy_X : bool, default=True
        If True, X will be copied; else, it may be overwritten.

    max_iter : int, default=None
        Maximum number of iterations for conjugate gradient solver.
        For 'sparse_cg' and 'lsqr' solvers, the default value is determined
        by scipy.sparse.linalg. For 'sag' solver, the default value is 1000.

    tol : float, default=1e-3
        Precision of the solution.

    solver : {'auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'}, \
        default='auto'
        Solver to use in the computational routines:

        - 'auto' chooses the solver automatically based on the type of data.

        - 'svd' uses a Singular Value Decomposition of X to compute the Ridge
          coefficients. More stable for singular matrices than 'cholesky'.

        - 'cholesky' uses the standard scipy.linalg.solve function to
          obtain a closed-form solution.

        - 'sparse_cg' uses the conjugate gradient solver as found in
          scipy.sparse.linalg.cg. As an iterative algorithm, this solver is
          more appropriate than 'cholesky' for large-scale data
          (possibility to set `tol` and `max_iter`).

        - 'lsqr' uses the dedicated regularized least-squares routine
          scipy.sparse.linalg.lsqr. It is the fastest and uses an iterative
          procedure.

        - 'sag' uses a Stochastic Average Gradient descent, and 'saga' uses
          its improved, unbiased version named SAGA. Both methods also use an
          iterative procedure, and are often faster than other solvers when
          both n_samples and n_features are large. Note that 'sag' and
          'saga' fast convergence is only guaranteed on features with
          approximately the same scale. You can preprocess the data with a
          scaler from sklearn.preprocessing.

        All last five solvers support both dense and sparse data. However, only
        'sag' and 'sparse_cg' supports sparse input when `fit_intercept` is
        True.

        .. versionadded:: 0.17
           Stochastic Average Gradient descent solver.
        .. versionadded:: 0.19
           SAGA solver.

    random_state : int, RandomState instance, default=None
        Used when ``solver`` == 'sag' or 'saga' to shuffle the data.
        See :term:`Glossary &lt;random_state&gt;` for details.

        .. versionadded:: 0.17
           `random_state` to support Stochastic Average Gradient.

    Attributes
    ----------
    coef_ : ndarray of shape (n_features,) or (n_targets, n_features)
        Weight vector(s).

    intercept_ : float or ndarray of shape (n_targets,)
        Independent term in decision function. Set to 0.0 if
        ``fit_intercept = False``.

    n_iter_ : None or ndarray of shape (n_targets,)
        Actual number of iterations for each target. Available only for
        sag and lsqr solvers. Other solvers will return None.

        .. versionadded:: 0.17

    See Also
    --------
    RidgeClassifier : Ridge classifier.
    RidgeCV : Ridge regression with built-in cross validation.
    :class:`~sklearn.kernel_ridge.KernelRidge` : Kernel ridge regression
        combines ridge regression with the kernel trick.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.linear_model import Ridge
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; n_samples, n_features = 10, 5
    &gt;&gt;&gt; rng = np.random.RandomState(0)
    &gt;&gt;&gt; y = rng.randn(n_samples)
    &gt;&gt;&gt; X = rng.randn(n_samples, n_features)
    &gt;&gt;&gt; clf = Ridge(alpha=1.0)
    &gt;&gt;&gt; clf.fit(X, y)
    Ridge()
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="float-literal">1.0</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="string-literal">'deprecated'</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="punctuation">,</span>
                 <span class="identifier">solver</span><span class="arithmetic-assignment">=</span><span class="string-literal">"auto"</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span>
            <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="identifier">normalize</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="identifier">copy_X</span><span class="punctuation">,</span>
            <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">solver</span><span class="arithmetic-assignment">=</span><span class="identifier">solver</span><span class="punctuation">,</span>
            <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit Ridge regression model.

        Parameters
        ----------
        X : {ndarray, sparse matrix} of shape (n_samples, n_features)
            Training data

        y : ndarray of shape (n_samples,) or (n_samples, n_targets)
            Target values

        sample_weight : float or ndarray of shape (n_samples,), default=None
            Individual weights for each sample. If given a float, every sample
            will have the same weight.

        Returns
        -------
        self : returns an instance of self.
        """</span>
        <span class="keyword">return</span> <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">RidgeClassifier</span><span class="grouping">(</span><span class="identifier">LinearClassifierMixin</span><span class="punctuation">,</span> <span class="identifier">_BaseRidge</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Classifier using Ridge regression.

    This classifier first converts the target values into ``{-1, 1}`` and
    then treats the problem as a regression task (multi-output regression in
    the multiclass case).

    Read more in the :ref:`User Guide &lt;ridge_regression&gt;`.

    Parameters
    ----------
    alpha : float, default=1.0
        Regularization strength; must be a positive float. Regularization
        improves the conditioning of the problem and reduces the variance of
        the estimates. Larger values specify stronger regularization.
        Alpha corresponds to ``1 / (2C)`` in other linear models such as
        :class:`~sklearn.linear_model.LogisticRegression` or
        :class:`~sklearn.svm.LinearSVC`.

    fit_intercept : bool, default=True
        Whether to calculate the intercept for this model. If set to false, no
        intercept will be used in calculations (e.g. data is expected to be
        already centered).

    normalize : bool, default=False
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

        .. deprecated:: 1.0
            ``normalize`` was deprecated in version 1.0 and
            will be removed in 1.2.

    copy_X : bool, default=True
        If True, X will be copied; else, it may be overwritten.

    max_iter : int, default=None
        Maximum number of iterations for conjugate gradient solver.
        The default value is determined by scipy.sparse.linalg.

    tol : float, default=1e-3
        Precision of the solution.

    class_weight : dict or 'balanced', default=None
        Weights associated with classes in the form ``{class_label: weight}``.
        If not given, all classes are supposed to have weight one.

        The "balanced" mode uses the values of y to automatically adjust
        weights inversely proportional to class frequencies in the input data
        as ``n_samples / (n_classes * np.bincount(y))``.

    solver : {'auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'}, \
        default='auto'
        Solver to use in the computational routines:

        - 'auto' chooses the solver automatically based on the type of data.

        - 'svd' uses a Singular Value Decomposition of X to compute the Ridge
          coefficients. More stable for singular matrices than 'cholesky'.

        - 'cholesky' uses the standard scipy.linalg.solve function to
          obtain a closed-form solution.

        - 'sparse_cg' uses the conjugate gradient solver as found in
          scipy.sparse.linalg.cg. As an iterative algorithm, this solver is
          more appropriate than 'cholesky' for large-scale data
          (possibility to set `tol` and `max_iter`).

        - 'lsqr' uses the dedicated regularized least-squares routine
          scipy.sparse.linalg.lsqr. It is the fastest and uses an iterative
          procedure.

        - 'sag' uses a Stochastic Average Gradient descent, and 'saga' uses
          its unbiased and more flexible version named SAGA. Both methods
          use an iterative procedure, and are often faster than other solvers
          when both n_samples and n_features are large. Note that 'sag' and
          'saga' fast convergence is only guaranteed on features with
          approximately the same scale. You can preprocess the data with a
          scaler from sklearn.preprocessing.

          .. versionadded:: 0.17
             Stochastic Average Gradient descent solver.
          .. versionadded:: 0.19
           SAGA solver.

    random_state : int, RandomState instance, default=None
        Used when ``solver`` == 'sag' or 'saga' to shuffle the data.
        See :term:`Glossary &lt;random_state&gt;` for details.

    Attributes
    ----------
    coef_ : ndarray of shape (1, n_features) or (n_classes, n_features)
        Coefficient of the features in the decision function.

        ``coef_`` is of shape (1, n_features) when the given problem is binary.

    intercept_ : float or ndarray of shape (n_targets,)
        Independent term in decision function. Set to 0.0 if
        ``fit_intercept = False``.

    n_iter_ : None or ndarray of shape (n_targets,)
        Actual number of iterations for each target. Available only for
        sag and lsqr solvers. Other solvers will return None.

    classes_ : ndarray of shape (n_classes,)
        The classes labels.

    See Also
    --------
    Ridge : Ridge regression.
    RidgeClassifierCV :  Ridge classifier with built-in cross validation.

    Notes
    -----
    For multi-class classification, n_class classifiers are trained in
    a one-versus-all approach. Concretely, this is implemented by taking
    advantage of the multi-variate response support in Ridge.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.datasets import load_breast_cancer
    &gt;&gt;&gt; from sklearn.linear_model import RidgeClassifier
    &gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True)
    &gt;&gt;&gt; clf = RidgeClassifier().fit(X, y)
    &gt;&gt;&gt; clf.score(X, y)
    0.9595...
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="float-literal">1.0</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="string-literal">'deprecated'</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">w</span><span class="invalid">e</span><span class="invalid">i</span><span class="invalid">g</span><span class="invalid">h</span><span class="invalid">t</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">solver</span><span class="arithmetic-assignment">=</span><span class="string-literal">"auto"</span><span class="punctuation">,</span>
                 <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="identifier">normalize</span><span class="punctuation">,</span>
            <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="identifier">copy_X</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">solver</span><span class="arithmetic-assignment">=</span><span class="identifier">solver</span><span class="punctuation">,</span>
            <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">w</span><span class="invalid">e</span><span class="invalid">i</span><span class="invalid">g</span><span class="invalid">h</span><span class="invalid">t</span> <span class="arithmetic-assignment">=</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">w</span><span class="invalid">e</span><span class="invalid">i</span><span class="invalid">g</span><span class="invalid">h</span><span class="invalid">t</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit Ridge classifier model.

        Parameters
        ----------
        X : {ndarray, sparse matrix} of shape (n_samples, n_features)
            Training data.

        y : ndarray of shape (n_samples,)
            Target values.

        sample_weight : float or ndarray of shape (n_samples,), default=None
            Individual weights for each sample. If given a float, every sample
            will have the same weight.

            .. versionadded:: 0.17
               *sample_weight* support to Classifier.

        Returns
        -------
        self : object
            Instance of the estimator.
        """</span>
        <span class="identifier">_accept_sparse</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_get_valid_accept_sparse</span><span class="grouping">(</span><span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span>
                                                  <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">solver</span><span class="grouping">)</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="identifier">_accept_sparse</span><span class="punctuation">,</span>
                                   <span class="identifier">multi_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">y_numeric</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_sample_weight</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_label_binarizer</span> <span class="arithmetic-assignment">=</span> <span class="identifier">LabelBinarizer</span><span class="grouping">(</span><span class="identifier">pos_label</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">neg_label</span><span class="arithmetic-assignment">=</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span>
        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_label_binarizer</span><span class="punctuation">.</span><span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_label_binarizer</span><span class="punctuation">.</span><span class="identifier">y_type_</span><span class="punctuation">.</span><span class="identifier">startswith</span><span class="grouping">(</span><span class="string-literal">'multilabel'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">warn</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># we don't (yet) support multi-label classification in Ridge</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">"%s doesn't support multi-label classification"</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span>
                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__class__</span><span class="punctuation">.</span><span class="identifier">__name__</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">w</span><span class="invalid">e</span><span class="invalid">i</span><span class="invalid">g</span><span class="invalid">h</span><span class="invalid">t</span><span class="punctuation">:</span>
            <span class="comment"># modify the sample weights with the corresponding class weight</span>
            <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">sample_weight</span> <span class="arithmetic-operator">*</span>
                             <span class="identifier">compute_sample_weight</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">w</span><span class="invalid">e</span><span class="invalid">i</span><span class="invalid">g</span><span class="invalid">h</span><span class="invalid">t</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">Y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_label_binarizer</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span>


<span class="keyword">def</span> <span class="identifier">_check_gcv_mode</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">gcv_mode</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="identifier">possible_gcv_modes</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="string-literal">'auto', 'svd', 'eigen'</span><span class="grouping">]</span>
    <span class="keyword">if</span> <span class="identifier">gcv_mode</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="identifier">possible_gcv_modes</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
            <span class="string-literal">"Unknown value for 'gcv_mode'. "</span>
            <span class="string-literal">"Got {} instead of one of {}"</span> <span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span>
                <span class="identifier">gcv_mode</span><span class="punctuation">,</span> <span class="identifier">possible_gcv_modes</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">gcv_mode</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="string-literal">'eigen', 'svd'</span><span class="grouping">]</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">gcv_mode</span>
    <span class="comment"># if X has more rows than columns, use decomposition of X^T.X,</span>
    <span class="comment"># otherwise X.X^T</span>
    <span class="keyword">if</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">&gt;</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="string-literal">'svd'</span>
    <span class="keyword">return</span> <span class="string-literal">'eigen'</span>


<span class="keyword">def</span> <span class="identifier">_find_smallest_angle</span><span class="grouping">(</span><span class="identifier">query</span><span class="punctuation">,</span> <span class="identifier">vectors</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Find the column of vectors that is most aligned with the query.

    Both query and the columns of vectors must have their l2 norm equal to 1.

    Parameters
    ----------
    query : ndarray of shape (n_samples,)
        Normalized query vector.

    vectors : ndarray of shape (n_samples, n_features)
        Vectors to which we compare query, as columns. Must be normalized.
    """</span>
    <span class="identifier">abs_cosine</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">query</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">vectors</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="identifier">index</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argmax</span><span class="grouping">(</span><span class="identifier">abs_cosine</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">index</span>


<span class="keyword">class</span> <span class="identifier">_X_CenterStackOp</span><span class="grouping">(</span><span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">LinearOperator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Behaves as centered and scaled X with an added intercept column.

    This operator behaves as
    np.hstack([X - sqrt_sw[:, None] * X_mean, sqrt_sw[:, None]])
    """</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X_mean</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_mean</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sqrt_sw</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sqrt_sw</span>

    <span class="keyword">def</span> <span class="identifier">_matvec</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">v</span> <span class="arithmetic-assignment">=</span> <span class="identifier">v</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="grouping">[</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span>
        <span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sqrt_sw</span> <span class="arithmetic-operator">*</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X_mean</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">v</span><span class="grouping">[</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span> <span class="arithmetic-operator">+</span> <span class="identifier">v</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sqrt_sw</span>

    <span class="keyword">def</span> <span class="identifier">_matmat</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">(</span>
            <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="grouping">[</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sqrt_sw</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X_mean</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">v</span><span class="grouping">[</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span> <span class="arithmetic-operator">+</span> <span class="identifier">v</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sqrt_sw</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">]</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_transpose</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">_XT_CenterStackOp</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sqrt_sw</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">_XT_CenterStackOp</span><span class="grouping">(</span><span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">LinearOperator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Behaves as transposed centered and scaled X with an intercept column.

    This operator behaves as
    np.hstack([X - sqrt_sw[:, None] * X_mean, sqrt_sw[:, None]]).T
    """</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">n_features</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X_mean</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_mean</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sqrt_sw</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sqrt_sw</span>

    <span class="keyword">def</span> <span class="identifier">_matvec</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">v</span> <span class="arithmetic-assignment">=</span> <span class="identifier">v</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">res</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">n_features</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="identifier">res</span><span class="grouping">[</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span>
            <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span>
            <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X_mean</span> <span class="arithmetic-operator">*</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sqrt_sw</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">v</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="grouping">)</span>
        <span class="identifier">res</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sqrt_sw</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">res</span>

    <span class="keyword">def</span> <span class="identifier">_matmat</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">res</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">n_features</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="identifier">res</span><span class="grouping">[</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span>
            <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X_mean</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sqrt_sw</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">v</span><span class="grouping">)</span>
        <span class="grouping">)</span>
        <span class="identifier">res</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sqrt_sw</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">res</span>


<span class="keyword">class</span> <span class="identifier">_IdentityRegressor</span><span class="punctuation">:</span>
    <span class="comment">"""Fake regressor which will directly output the prediction."""</span>

    <span class="keyword">def</span> <span class="identifier">decision_function</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y_predict</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">y_predict</span>

    <span class="keyword">def</span> <span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y_predict</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">y_predict</span>


<span class="keyword">class</span> <span class="identifier">_IdentityClassifier</span><span class="grouping">(</span><span class="identifier">LinearClassifierMixin</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Fake classifier which will directly output the prediction.

    We inherit from LinearClassifierMixin to get the proper shape for the
    output `y`.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span> <span class="arithmetic-assignment">=</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span>

    <span class="keyword">def</span> <span class="identifier">decision_function</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y_predict</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">y_predict</span>


<span class="keyword">class</span> <span class="identifier">_RidgeGCV</span><span class="grouping">(</span><span class="identifier">LinearModel</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Ridge regression with built-in Leave-one-out Cross-Validation.

    This class is not intended to be used directly. Use RidgeCV instead.

    Notes
    -----

    We want to solve (K + alpha*Id)c = y,
    where K = X X^T is the kernel matrix.

    Let G = (K + alpha*Id).

    Dual solution: c = G^-1y
    Primal solution: w = X^T c

    Compute eigendecomposition K = Q V Q^T.
    Then G^-1 = Q (V + alpha*Id)^-1 Q^T,
    where (V + alpha*Id) is diagonal.
    It is thus inexpensive to inverse for many alphas.

    Let loov be the vector of prediction values for each example
    when the model was fitted with all examples but this example.

    loov = (KG^-1Y - diag(KG^-1)Y) / diag(I-KG^-1)

    Let looe be the vector of prediction errors for each example
    when the model was fitted with all examples but this example.

    looe = y - loov = c / diag(G^-1)

    The best score (negative mean squared error or user-provided scoring) is
    stored in the `best_score_` attribute, and the selected hyperparameter in
    `alpha_`.

    References
    ----------
    http://cbcl.mit.edu/publications/ps/MIT-CSAIL-TR-2007-025.pdf
    https://www.mit.edu/~9.520/spring07/Classes/rlsslides.pdf
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="float-literal">0.1</span><span class="punctuation">,</span> <span class="float-literal">1.0</span><span class="punctuation">,</span> <span class="float-literal">10.0</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span>
                 <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="string-literal">'deprecated'</span><span class="punctuation">,</span>
                 <span class="identifier">scoring</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">gcv_mode</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">store_cv_values</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                 <span class="identifier">is_clf</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">alpha_per_target</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">alphas</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_intercept</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">normalize</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span> <span class="arithmetic-assignment">=</span> <span class="identifier">scoring</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy_X</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">gcv_mode</span> <span class="arithmetic-assignment">=</span> <span class="identifier">gcv_mode</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">store_cv_values</span> <span class="arithmetic-assignment">=</span> <span class="identifier">store_cv_values</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">is_clf</span> <span class="arithmetic-assignment">=</span> <span class="identifier">is_clf</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha_per_target</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha_per_target</span>

    <span class="punctuation">@</span><span class="identifier">staticmethod</span>
    <span class="keyword">def</span> <span class="identifier">_decomp_diag</span><span class="grouping">(</span><span class="identifier">v_prime</span><span class="punctuation">,</span> <span class="identifier">Q</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># compute diagonal of the matrix: dot(Q, dot(diag(v_prime), Q^T))</span>
        <span class="keyword">return</span> <span class="grouping">(</span><span class="identifier">v_prime</span> <span class="arithmetic-operator">*</span> <span class="identifier">Q</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="identifier">staticmethod</span>
    <span class="keyword">def</span> <span class="identifier">_diag_dot</span><span class="grouping">(</span><span class="identifier">D</span><span class="punctuation">,</span> <span class="identifier">B</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># compute dot(diag(D), B)</span>
        <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">B</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="comment"># handle case where B is &gt; 1-d</span>
            <span class="identifier">D</span> <span class="arithmetic-assignment">=</span> <span class="identifier">D</span><span class="grouping">[</span><span class="grouping">(</span><span class="identifier">slice</span><span class="grouping">(</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="grouping">)</span> <span class="arithmetic-operator">+</span> <span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="punctuation">,</span> <span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">B</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="identifier">D</span> <span class="arithmetic-operator">*</span> <span class="identifier">B</span>

    <span class="keyword">def</span> <span class="identifier">_compute_gram</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Computes the Gram matrix XX^T with possible centering.

        Parameters
        ----------
        X : {ndarray, sparse matrix} of shape (n_samples, n_features)
            The preprocessed design matrix.

        sqrt_sw : ndarray of shape (n_samples,)
            square roots of sample weights

        Returns
        -------
        gram : ndarray of shape (n_samples, n_samples)
            The Gram matrix.
        X_mean : ndarray of shape (n_feature,)
            The weighted mean of ``X`` for each feature.

        Notes
        -----
        When X is dense the centering has been done in preprocessing
        so the mean is 0 and we just compute XX^T.

        When X is sparse it has not been centered in preprocessing, but it has
        been scaled by sqrt(sample weights).

        When self.fit_intercept is False no centering is done.

        The centered X is never actually computed because centering would break
        the sparsity of X.
        """</span>
        <span class="identifier">center</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span> <span class="logical-operator">and</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">center</span><span class="punctuation">:</span>
            <span class="comment"># in this case centering has been done in preprocessing</span>
            <span class="comment"># or we are not fitting an intercept.</span>
            <span class="identifier">X_mean</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">X_mean</span>
        <span class="comment"># X is sparse</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">sample_weight_matrix</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">dia_matrix</span><span class="grouping">(</span>
            <span class="grouping">(</span><span class="identifier">sqrt_sw</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">shape</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">X_weighted</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sample_weight_matrix</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">mean_variance_axis</span><span class="grouping">(</span><span class="identifier">X_weighted</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
        <span class="identifier">X_mean</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">n_samples</span> <span class="arithmetic-operator">/</span> <span class="identifier">sqrt_sw</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">sqrt_sw</span><span class="grouping">)</span>
        <span class="identifier">X_mX</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sqrt_sw</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span>
            <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">X_mX_m</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">outer</span><span class="grouping">(</span><span class="identifier">sqrt_sw</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="grouping">(</span><span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span> <span class="arithmetic-operator">+</span> <span class="identifier">X_mX_m</span>
                <span class="arithmetic-operator">-</span> <span class="identifier">X_mX</span> <span class="arithmetic-operator">-</span> <span class="identifier">X_mX</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_compute_covariance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Computes covariance matrix X^TX with possible centering.

        Parameters
        ----------
        X : sparse matrix of shape (n_samples, n_features)
            The preprocessed design matrix.

        sqrt_sw : ndarray of shape (n_samples,)
            square roots of sample weights

        Returns
        -------
        covariance : ndarray of shape (n_features, n_features)
            The covariance matrix.
        X_mean : ndarray of shape (n_feature,)
            The weighted mean of ``X`` for each feature.

        Notes
        -----
        Since X is sparse it has not been centered in preprocessing, but it has
        been scaled by sqrt(sample weights).

        When self.fit_intercept is False no centering is done.

        The centered X is never actually computed because centering would break
        the sparsity of X.
        """</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">:</span>
            <span class="comment"># in this case centering has been done in preprocessing</span>
            <span class="comment"># or we are not fitting an intercept.</span>
            <span class="identifier">X_mean</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">X_mean</span>
        <span class="comment"># this function only gets called for sparse X</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">sample_weight_matrix</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">dia_matrix</span><span class="grouping">(</span>
            <span class="grouping">(</span><span class="identifier">sqrt_sw</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">shape</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">X_weighted</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sample_weight_matrix</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">mean_variance_axis</span><span class="grouping">(</span><span class="identifier">X_weighted</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
        <span class="identifier">X_mean</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_mean</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_samples</span> <span class="arithmetic-operator">/</span> <span class="identifier">sqrt_sw</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">sqrt_sw</span><span class="grouping">)</span>
        <span class="identifier">weight_sum</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sqrt_sw</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">sqrt_sw</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="grouping">(</span><span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span>
                <span class="identifier">weight_sum</span> <span class="arithmetic-operator">*</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">outer</span><span class="grouping">(</span><span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="grouping">)</span><span class="punctuation">,</span>
                <span class="identifier">X_mean</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_sparse_multidot_diag</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">A</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute the diagonal of (X - X_mean).dot(A).dot((X - X_mean).T)
        without explicitely centering X nor computing X.dot(A)
        when X is sparse.

        Parameters
        ----------
        X : sparse matrix of shape (n_samples, n_features)

        A : ndarray of shape (n_features, n_features)

        X_mean : ndarray of shape (n_features,)

        sqrt_sw : ndarray of shape (n_features,)
            square roots of sample weights

        Returns
        -------
        diag : np.ndarray, shape (n_samples,)
            The computed diagonal.
        """</span>
        <span class="identifier">intercept_col</span> <span class="arithmetic-assignment">=</span> <span class="identifier">scale</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sqrt_sw</span>
        <span class="identifier">batch_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>
        <span class="identifier">diag</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">start</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">batch_size</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">batch</span> <span class="arithmetic-assignment">=</span> <span class="identifier">slice</span><span class="grouping">(</span><span class="identifier">start</span><span class="punctuation">,</span> <span class="identifier">min</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">start</span> <span class="arithmetic-operator">+</span> <span class="identifier">batch_size</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span>
            <span class="identifier">X_batch</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span>
                <span class="grouping">(</span><span class="identifier">X</span><span class="grouping">[</span><span class="identifier">batch</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-operator">+</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="grouping">)</span><span class="punctuation">,</span>
                <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span>
            <span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">:</span>
                <span class="identifier">X_batch</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">batch</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">A</span> <span class="arithmetic-operator">-</span> <span class="identifier">X_mean</span> <span class="arithmetic-operator">*</span> <span class="identifier">scale</span><span class="grouping">[</span><span class="identifier">batch</span><span class="grouping">]</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">]</span>
                <span class="identifier">X_batch</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">intercept_col</span><span class="grouping">[</span><span class="identifier">batch</span><span class="grouping">]</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">X_batch</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">batch</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">A</span>
            <span class="identifier">diag</span><span class="grouping">[</span><span class="identifier">batch</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">X_batch</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">A</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">X_batch</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">diag</span>

    <span class="keyword">def</span> <span class="identifier">_eigen_decompose_gram</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Eigendecomposition of X.X^T, used when n_samples &lt;= n_features."""</span>
        <span class="comment"># if X is dense it has already been centered in preprocessing</span>
        <span class="identifier">K</span><span class="punctuation">,</span> <span class="identifier">X_mean</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_compute_gram</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">:</span>
            <span class="comment"># to emulate centering X with sample weights,</span>
            <span class="comment"># ie removing the weighted average, we add a column</span>
            <span class="comment"># containing the square roots of the sample weights.</span>
            <span class="comment"># by centering, it is orthogonal to the other columns</span>
            <span class="identifier">K</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">outer</span><span class="grouping">(</span><span class="identifier">sqrt_sw</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span>
        <span class="identifier">eigvals</span><span class="punctuation">,</span> <span class="identifier">Q</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">eigh</span><span class="grouping">(</span><span class="identifier">K</span><span class="grouping">)</span>
        <span class="identifier">QT_y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">Q</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">eigvals</span><span class="punctuation">,</span> <span class="identifier">Q</span><span class="punctuation">,</span> <span class="identifier">QT_y</span>

    <span class="keyword">def</span> <span class="identifier">_solve_eigen_gram</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">eigvals</span><span class="punctuation">,</span> <span class="identifier">Q</span><span class="punctuation">,</span> <span class="identifier">QT_y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute dual coefficients and diagonal of G^-1.

        Used when we have a decomposition of X.X^T (n_samples &lt;= n_features).
        """</span>
        <span class="identifier">w</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">eigvals</span> <span class="arithmetic-operator">+</span> <span class="identifier">alpha</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">:</span>
            <span class="comment"># the vector containing the square roots of the sample weights (1</span>
            <span class="comment"># when no sample weights) is the eigenvector of XX^T which</span>
            <span class="comment"># corresponds to the intercept; we cancel the regularization on</span>
            <span class="comment"># this dimension. the corresponding eigenvalue is</span>
            <span class="comment"># sum(sample_weight).</span>
            <span class="identifier">normalized_sw</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sqrt_sw</span> <span class="arithmetic-operator">/</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">norm</span><span class="grouping">(</span><span class="identifier">sqrt_sw</span><span class="grouping">)</span>
            <span class="identifier">intercept_dim</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_find_smallest_angle</span><span class="grouping">(</span><span class="identifier">normalized_sw</span><span class="punctuation">,</span> <span class="identifier">Q</span><span class="grouping">)</span>
            <span class="identifier">w</span><span class="grouping">[</span><span class="identifier">intercept_dim</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>  <span class="comment"># cancel regularization for the intercept</span>

        <span class="identifier">c</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">Q</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_diag_dot</span><span class="grouping">(</span><span class="identifier">w</span><span class="punctuation">,</span> <span class="identifier">QT_y</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">G_inverse_diag</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_decomp_diag</span><span class="grouping">(</span><span class="identifier">w</span><span class="punctuation">,</span> <span class="identifier">Q</span><span class="grouping">)</span>
        <span class="comment"># handle case where y is 2-d</span>
        <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span> <span class="relational-operator">!=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">G_inverse_diag</span> <span class="arithmetic-assignment">=</span> <span class="identifier">G_inverse_diag</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="identifier">G_inverse_diag</span><span class="punctuation">,</span> <span class="identifier">c</span>

    <span class="keyword">def</span> <span class="identifier">_eigen_decompose_covariance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Eigendecomposition of X^T.X, used when n_samples &gt; n_features
        and X is sparse.
        """</span>
        <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>
        <span class="identifier">cov</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">n_features</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="identifier">cov</span><span class="grouping">[</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X_mean</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_compute_covariance</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">:</span>
            <span class="identifier">cov</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cov</span><span class="grouping">[</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span>
        <span class="comment"># to emulate centering X with sample weights,</span>
        <span class="comment"># ie removing the weighted average, we add a column</span>
        <span class="comment"># containing the square roots of the sample weights.</span>
        <span class="comment"># by centering, it is orthogonal to the other columns</span>
        <span class="comment"># when all samples have the same weight we add a column of 1</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">cov</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
            <span class="identifier">cov</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
            <span class="identifier">cov</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sqrt_sw</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">sqrt_sw</span><span class="grouping">)</span>
        <span class="identifier">nullspace_dim</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-operator">-</span> <span class="identifier">n_samples</span><span class="grouping">)</span>
        <span class="identifier">eigvals</span><span class="punctuation">,</span> <span class="identifier">V</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">eigh</span><span class="grouping">(</span><span class="identifier">cov</span><span class="grouping">)</span>
        <span class="comment"># remove eigenvalues and vectors in the null space of X^T.X</span>
        <span class="identifier">eigvals</span> <span class="arithmetic-assignment">=</span> <span class="identifier">eigvals</span><span class="grouping">[</span><span class="identifier">nullspace_dim</span><span class="punctuation">:</span><span class="grouping">]</span>
        <span class="identifier">V</span> <span class="arithmetic-assignment">=</span> <span class="identifier">V</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">nullspace_dim</span><span class="punctuation">:</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">eigvals</span><span class="punctuation">,</span> <span class="identifier">V</span><span class="punctuation">,</span> <span class="identifier">X</span>

    <span class="keyword">def</span> <span class="identifier">_solve_eigen_covariance_no_intercept</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">eigvals</span><span class="punctuation">,</span> <span class="identifier">V</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute dual coefficients and diagonal of G^-1.

        Used when we have a decomposition of X^T.X
        (n_samples &gt; n_features and X is sparse), and not fitting an intercept.
        """</span>
        <span class="identifier">w</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">eigvals</span> <span class="arithmetic-operator">+</span> <span class="identifier">alpha</span><span class="grouping">)</span>
        <span class="identifier">A</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">V</span> <span class="arithmetic-operator">*</span> <span class="identifier">w</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">V</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span>
        <span class="identifier">AXy</span> <span class="arithmetic-assignment">=</span> <span class="identifier">A</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">y_hat</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">AXy</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">hat_diag</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_sparse_multidot_diag</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">A</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span> <span class="relational-operator">!=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="comment"># handle case where y is 2-d</span>
            <span class="identifier">hat_diag</span> <span class="arithmetic-assignment">=</span> <span class="identifier">hat_diag</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="grouping">(</span><span class="int-literal">1</span> <span class="arithmetic-operator">-</span> <span class="identifier">hat_diag</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">y</span> <span class="arithmetic-operator">-</span> <span class="identifier">y_hat</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">alpha</span>

    <span class="keyword">def</span> <span class="identifier">_solve_eigen_covariance_intercept</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">eigvals</span><span class="punctuation">,</span> <span class="identifier">V</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute dual coefficients and diagonal of G^-1.

        Used when we have a decomposition of X^T.X
        (n_samples &gt; n_features and X is sparse),
        and we are fitting an intercept.
        """</span>
        <span class="comment"># the vector [0, 0, ..., 0, 1]</span>
        <span class="comment"># is the eigenvector of X^TX which</span>
        <span class="comment"># corresponds to the intercept; we cancel the regularization on</span>
        <span class="comment"># this dimension. the corresponding eigenvalue is</span>
        <span class="comment"># sum(sample_weight), e.g. n when uniform sample weights.</span>
        <span class="identifier">intercept_sv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">V</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="identifier">intercept_sv</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>
        <span class="identifier">intercept_dim</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_find_smallest_angle</span><span class="grouping">(</span><span class="identifier">intercept_sv</span><span class="punctuation">,</span> <span class="identifier">V</span><span class="grouping">)</span>
        <span class="identifier">w</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">eigvals</span> <span class="arithmetic-operator">+</span> <span class="identifier">alpha</span><span class="grouping">)</span>
        <span class="identifier">w</span><span class="grouping">[</span><span class="identifier">intercept_dim</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span> <span class="arithmetic-operator">/</span> <span class="identifier">eigvals</span><span class="grouping">[</span><span class="identifier">intercept_dim</span><span class="grouping">]</span>
        <span class="identifier">A</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">V</span> <span class="arithmetic-operator">*</span> <span class="identifier">w</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">V</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span>
        <span class="comment"># add a column to X containing the square roots of sample weights</span>
        <span class="identifier">X_op</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_X_CenterStackOp</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span>
        <span class="identifier">AXy</span> <span class="arithmetic-assignment">=</span> <span class="identifier">A</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X_op</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">y_hat</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_op</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">AXy</span><span class="grouping">)</span>
        <span class="identifier">hat_diag</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_sparse_multidot_diag</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">A</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span>
        <span class="comment"># return (1 - hat_diag), (y - y_hat)</span>
        <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span> <span class="relational-operator">!=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="comment"># handle case where y is 2-d</span>
            <span class="identifier">hat_diag</span> <span class="arithmetic-assignment">=</span> <span class="identifier">hat_diag</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="grouping">(</span><span class="int-literal">1</span> <span class="arithmetic-operator">-</span> <span class="identifier">hat_diag</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">y</span> <span class="arithmetic-operator">-</span> <span class="identifier">y_hat</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">alpha</span>

    <span class="keyword">def</span> <span class="identifier">_solve_eigen_covariance</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">eigvals</span><span class="punctuation">,</span> <span class="identifier">V</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute dual coefficients and diagonal of G^-1.

        Used when we have a decomposition of X^T.X
        (n_samples &gt; n_features and X is sparse).
        """</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_solve_eigen_covariance_intercept</span><span class="grouping">(</span>
                <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">eigvals</span><span class="punctuation">,</span> <span class="identifier">V</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_solve_eigen_covariance_no_intercept</span><span class="grouping">(</span>
            <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">eigvals</span><span class="punctuation">,</span> <span class="identifier">V</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_svd_decompose_design_matrix</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># X already centered</span>
        <span class="identifier">X_mean</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">:</span>
            <span class="comment"># to emulate fit_intercept=True situation, add a column</span>
            <span class="comment"># containing the square roots of the sample weights</span>
            <span class="comment"># by centering, the other columns are orthogonal to that one</span>
            <span class="identifier">intercept_column</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sqrt_sw</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">]</span>
            <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">hstack</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">intercept_column</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">U</span><span class="punctuation">,</span> <span class="identifier">singvals</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">svd</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">full_matrices</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
        <span class="identifier">singvals_sq</span> <span class="arithmetic-assignment">=</span> <span class="identifier">singvals</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span>
        <span class="identifier">UT_y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">U</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">singvals_sq</span><span class="punctuation">,</span> <span class="identifier">U</span><span class="punctuation">,</span> <span class="identifier">UT_y</span>

    <span class="keyword">def</span> <span class="identifier">_solve_svd_design_matrix</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="identifier">singvals_sq</span><span class="punctuation">,</span> <span class="identifier">U</span><span class="punctuation">,</span> <span class="identifier">UT_y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute dual coefficients and diagonal of G^-1.

        Used when we have an SVD decomposition of X
        (n_samples &gt; n_features and X is dense).
        """</span>
        <span class="identifier">w</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="grouping">(</span><span class="identifier">singvals_sq</span> <span class="arithmetic-operator">+</span> <span class="identifier">alpha</span><span class="grouping">)</span> <span class="arithmetic-operator">**</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="grouping">(</span><span class="identifier">alpha</span> <span class="arithmetic-operator">**</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">:</span>
            <span class="comment"># detect intercept column</span>
            <span class="identifier">normalized_sw</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sqrt_sw</span> <span class="arithmetic-operator">/</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">norm</span><span class="grouping">(</span><span class="identifier">sqrt_sw</span><span class="grouping">)</span>
            <span class="identifier">intercept_dim</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_find_smallest_angle</span><span class="grouping">(</span><span class="identifier">normalized_sw</span><span class="punctuation">,</span> <span class="identifier">U</span><span class="grouping">)</span>
            <span class="comment"># cancel the regularization for the intercept</span>
            <span class="identifier">w</span><span class="grouping">[</span><span class="identifier">intercept_dim</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="arithmetic-operator">-</span> <span class="grouping">(</span><span class="identifier">alpha</span> <span class="arithmetic-operator">**</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span>
        <span class="identifier">c</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">U</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_diag_dot</span><span class="grouping">(</span><span class="identifier">w</span><span class="punctuation">,</span> <span class="identifier">UT_y</span><span class="grouping">)</span><span class="grouping">)</span> <span class="arithmetic-operator">+</span> <span class="grouping">(</span><span class="identifier">alpha</span> <span class="arithmetic-operator">**</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">y</span>
        <span class="identifier">G_inverse_diag</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_decomp_diag</span><span class="grouping">(</span><span class="identifier">w</span><span class="punctuation">,</span> <span class="identifier">U</span><span class="grouping">)</span> <span class="arithmetic-operator">+</span> <span class="grouping">(</span><span class="identifier">alpha</span> <span class="arithmetic-operator">**</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span> <span class="relational-operator">!=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="comment"># handle case where y is 2-d</span>
            <span class="identifier">G_inverse_diag</span> <span class="arithmetic-assignment">=</span> <span class="identifier">G_inverse_diag</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="identifier">G_inverse_diag</span><span class="punctuation">,</span> <span class="identifier">c</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit Ridge regression model with gcv.

        Parameters
        ----------
        X : {ndarray, sparse matrix} of shape (n_samples, n_features)
            Training data. Will be cast to float64 if necessary.

        y : ndarray of shape (n_samples,) or (n_samples, n_targets)
            Target values. Will be cast to float64 if necessary.

        sample_weight : float or ndarray of shape (n_samples,), default=None
            Individual weights for each sample. If given a float, every sample
            will have the same weight.

        Returns
        -------
        self : object
        """</span>
        <span class="identifier">_normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_deprecate_normalize</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span><span class="punctuation">,</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
            <span class="identifier">estimator_name</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__class__</span><span class="punctuation">.</span><span class="identifier">__name__</span>
        <span class="grouping">)</span>

        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="string-literal">'csr', 'csc', 'coo'</span><span class="grouping">]</span><span class="punctuation">,</span>
                                   <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="grouping">]</span><span class="punctuation">,</span>
                                   <span class="identifier">multi_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">y_numeric</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

        <span class="comment"># alpha_per_target cannot be used in classifier mode. All subclasses</span>
        <span class="comment"># of _RidgeGCV that are classifiers keep alpha_per_target at its</span>
        <span class="comment"># default value: False, so the condition below should never happen.</span>
        <span class="keyword">assert</span> <span class="logical-operator">not</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">is_clf</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha_per_target</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_sample_weight</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span>
                                                 <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">any</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">"alphas must be strictly positive. Got {} containing some "</span>
                <span class="string-literal">"negative or null value instead."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">X_offset</span><span class="punctuation">,</span> <span class="identifier">y_offset</span><span class="punctuation">,</span> <span class="identifier">X_scale</span> <span class="arithmetic-assignment">=</span> <span class="identifier">LinearModel</span><span class="punctuation">.</span><span class="identifier">_preprocess_data</span><span class="grouping">(</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span> <span class="identifier">_normalize</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span><span class="punctuation">,</span>
            <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>

        <span class="identifier">gcv_mode</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_gcv_mode</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">gcv_mode</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">gcv_mode</span> <span class="relational-operator">==</span> <span class="string-literal">'eigen'</span><span class="punctuation">:</span>
            <span class="identifier">decompose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_eigen_decompose_gram</span>
            <span class="identifier">solve</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_solve_eigen_gram</span>
        <span class="keyword">elif</span> <span class="identifier">gcv_mode</span> <span class="relational-operator">==</span> <span class="string-literal">'svd'</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">decompose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_eigen_decompose_covariance</span>
                <span class="identifier">solve</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_solve_eigen_covariance</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">decompose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_svd_decompose_design_matrix</span>
                <span class="identifier">solve</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_solve_svd_design_matrix</span>

        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

        <span class="keyword">if</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_rescale_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="grouping">)</span>
            <span class="identifier">sqrt_sw</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">sqrt_sw</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ones</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="identifier">decomposition</span> <span class="arithmetic-assignment">=</span> <span class="identifier">decompose</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="grouping">)</span>

        <span class="identifier">scorer</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_scoring</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">scoring</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span><span class="punctuation">,</span> <span class="identifier">allow_none</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">error</span> <span class="arithmetic-assignment">=</span> <span class="identifier">scorer</span> <span class="relational-operator">is</span> <span class="none-literal">None</span>

        <span class="identifier">n_y</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span> <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">1</span> <span class="keyword">else</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>
        <span class="identifier">n_alphas</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span> <span class="keyword">if</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ndim</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">0</span> <span class="keyword">else</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">store_cv_values</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv_values_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span>
                <span class="grouping">(</span><span class="identifier">n_samples</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_y</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="identifier">best_coef</span><span class="punctuation">,</span> <span class="identifier">best_score</span><span class="punctuation">,</span> <span class="identifier">best_alpha</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="punctuation">,</span> <span class="none-literal">None</span>

        <span class="keyword">for</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">alpha</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">atleast_1d</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">G_inverse_diag</span><span class="punctuation">,</span> <span class="identifier">c</span> <span class="arithmetic-assignment">=</span> <span class="identifier">solve</span><span class="grouping">(</span>
                <span class="identifier">float</span><span class="grouping">(</span><span class="identifier">alpha</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sqrt_sw</span><span class="punctuation">,</span> <span class="identifier">X_mean</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="identifier">decomposition</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">error</span><span class="punctuation">:</span>
                <span class="identifier">squared_errors</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">c</span> <span class="arithmetic-operator">/</span> <span class="identifier">G_inverse_diag</span><span class="grouping">)</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span>
                <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha_per_target</span><span class="punctuation">:</span>
                    <span class="identifier">alpha_score</span> <span class="arithmetic-assignment">=</span> <span class="arithmetic-operator">-</span><span class="identifier">squared_errors</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
                <span class="keyword">else</span><span class="punctuation">:</span>
                    <span class="identifier">alpha_score</span> <span class="arithmetic-assignment">=</span> <span class="arithmetic-operator">-</span><span class="identifier">squared_errors</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="grouping">)</span>
                <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">store_cv_values</span><span class="punctuation">:</span>
                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv_values_</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">squared_errors</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span> <span class="arithmetic-operator">-</span> <span class="grouping">(</span><span class="identifier">c</span> <span class="arithmetic-operator">/</span> <span class="identifier">G_inverse_diag</span><span class="grouping">)</span>
                <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">store_cv_values</span><span class="punctuation">:</span>
                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv_values_</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">predictions</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>

                <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">is_clf</span><span class="punctuation">:</span>
                    <span class="identifier">identity_estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_IdentityClassifier</span><span class="grouping">(</span>
                        <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">n_y</span><span class="grouping">)</span>
                    <span class="grouping">)</span>
                    <span class="identifier">alpha_score</span> <span class="arithmetic-assignment">=</span> <span class="identifier">scorer</span><span class="grouping">(</span><span class="identifier">identity_estimator</span><span class="punctuation">,</span>
                                         <span class="identifier">predictions</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">argmax</span><span class="grouping">(</span><span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
                <span class="keyword">else</span><span class="punctuation">:</span>
                    <span class="identifier">identity_estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_IdentityRegressor</span><span class="grouping">(</span><span class="grouping">)</span>
                    <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha_per_target</span><span class="punctuation">:</span>
                        <span class="identifier">alpha_score</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span>
                            <span class="identifier">scorer</span><span class="grouping">(</span><span class="identifier">identity_estimator</span><span class="punctuation">,</span>
                                   <span class="identifier">predictions</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">j</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">j</span><span class="grouping">]</span><span class="grouping">)</span>
                            <span class="keyword">for</span> <span class="identifier">j</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_y</span><span class="grouping">)</span>
                        <span class="grouping">]</span><span class="grouping">)</span>
                    <span class="keyword">else</span><span class="punctuation">:</span>
                        <span class="identifier">alpha_score</span> <span class="arithmetic-assignment">=</span> <span class="identifier">scorer</span><span class="grouping">(</span><span class="identifier">identity_estimator</span><span class="punctuation">,</span>
                                             <span class="identifier">predictions</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span>

            <span class="comment"># Keep track of the best model</span>
            <span class="keyword">if</span> <span class="identifier">best_score</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                <span class="comment"># initialize</span>
                <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha_per_target</span> <span class="logical-operator">and</span> <span class="identifier">n_y</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                    <span class="identifier">best_coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">c</span>
                    <span class="identifier">best_score</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">atleast_1d</span><span class="grouping">(</span><span class="identifier">alpha_score</span><span class="grouping">)</span>
                    <span class="identifier">best_alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">full</span><span class="grouping">(</span><span class="identifier">n_y</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="grouping">)</span>
                <span class="keyword">else</span><span class="punctuation">:</span>
                    <span class="identifier">best_coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">c</span>
                    <span class="identifier">best_score</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha_score</span>
                    <span class="identifier">best_alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="comment"># update</span>
                <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha_per_target</span> <span class="logical-operator">and</span> <span class="identifier">n_y</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                    <span class="identifier">to_update</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha_score</span> <span class="relational-operator">&gt;</span> <span class="identifier">best_score</span>
                    <span class="identifier">best_coef</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">to_update</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">c</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">to_update</span><span class="grouping">]</span>
                    <span class="identifier">best_score</span><span class="grouping">[</span><span class="identifier">to_update</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha_score</span><span class="grouping">[</span><span class="identifier">to_update</span><span class="grouping">]</span>
                    <span class="identifier">best_alpha</span><span class="grouping">[</span><span class="identifier">to_update</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha</span>
                <span class="keyword">elif</span> <span class="identifier">alpha_score</span> <span class="relational-operator">&gt;</span> <span class="identifier">best_score</span><span class="punctuation">:</span>
                    <span class="identifier">best_coef</span><span class="punctuation">,</span> <span class="identifier">best_score</span><span class="punctuation">,</span> <span class="identifier">best_alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">c</span><span class="punctuation">,</span> <span class="identifier">alpha_score</span><span class="punctuation">,</span> <span class="identifier">alpha</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">best_alpha</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_score_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">best_score</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dual_coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">best_coef</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dual_coef_</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span>

        <span class="identifier">X_offset</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">X_mean</span> <span class="arithmetic-operator">*</span> <span class="identifier">X_scale</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_set_intercept</span><span class="grouping">(</span><span class="identifier">X_offset</span><span class="punctuation">,</span> <span class="identifier">y_offset</span><span class="punctuation">,</span> <span class="identifier">X_scale</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">store_cv_values</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="identifier">cv_values_shape</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">cv_values_shape</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_y</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv_values_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv_values_</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="identifier">cv_values_shape</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span>


<span class="keyword">class</span> <span class="identifier">_BaseRidgeCV</span><span class="grouping">(</span><span class="identifier">LinearModel</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="float-literal">0.1</span><span class="punctuation">,</span> <span class="float-literal">1.0</span><span class="punctuation">,</span> <span class="float-literal">10.0</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span>
                 <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="string-literal">'deprecated'</span><span class="punctuation">,</span> <span class="identifier">scoring</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">gcv_mode</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">store_cv_values</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                 <span class="identifier">alpha_per_target</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">alphas</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_intercept</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">normalize</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span> <span class="arithmetic-assignment">=</span> <span class="identifier">scoring</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cv</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">gcv_mode</span> <span class="arithmetic-assignment">=</span> <span class="identifier">gcv_mode</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">store_cv_values</span> <span class="arithmetic-assignment">=</span> <span class="identifier">store_cv_values</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha_per_target</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha_per_target</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit Ridge regression model with cv.

        Parameters
        ----------
        X : ndarray of shape (n_samples, n_features)
            Training data. If using GCV, will be cast to float64
            if necessary.

        y : ndarray of shape (n_samples,) or (n_samples, n_targets)
            Target values. Will be cast to X's dtype if necessary.

        sample_weight : float or ndarray of shape (n_samples,), default=None
            Individual weights for each sample. If given a float, every sample
            will have the same weight.

        Returns
        -------
        self : object

        Notes
        -----
        When sample_weight is provided, the selected hyperparameter may depend
        on whether we use leave-one-out cross-validation (cv=None or cv='auto')
        or another form of cross-validation, because only leave-one-out
        cross-validation takes the sample weights into account when computing
        the validation score.
        """</span>
        <span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span>
        <span class="keyword">if</span> <span class="identifier">cv</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_RidgeGCV</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas</span><span class="punctuation">,</span>
                                  <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span>
                                  <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span><span class="punctuation">,</span>
                                  <span class="identifier">scoring</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span><span class="punctuation">,</span>
                                  <span class="identifier">gcv_mode</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">gcv_mode</span><span class="punctuation">,</span>
                                  <span class="identifier">store_cv_values</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">store_cv_values</span><span class="punctuation">,</span>
                                  <span class="identifier">is_clf</span><span class="arithmetic-assignment">=</span><span class="identifier">is_classifier</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">,</span>
                                  <span class="identifier">alpha_per_target</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha_per_target</span><span class="grouping">)</span>
            <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">alpha_</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_score_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">best_score_</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">store_cv_values</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv_values_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">cv_values_</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">store_cv_values</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"cv!=None and store_cv_values=True"</span>
                                 <span class="string-literal">" are incompatible"</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha_per_target</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"cv!=None and alpha_per_target=True"</span>
                                 <span class="string-literal">" are incompatible"</span><span class="grouping">)</span>
            <span class="identifier">parameters</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="string-literal">'alpha'</span><span class="punctuation">:</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas</span><span class="grouping">}</span>
            <span class="identifier">solver</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'sparse_cg' if sparse.issparse(X) else 'auto'</span>
            <span class="identifier">model</span> <span class="arithmetic-assignment">=</span> <span class="identifier">RidgeClassifier</span> <span class="keyword">if</span> <span class="identifier">is_classifier</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span> <span class="keyword">else</span> <span class="identifier">Ridge</span>
            <span class="identifier">gs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">GridSearchCV</span><span class="grouping">(</span><span class="identifier">model</span><span class="grouping">(</span><span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span>
                                    <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span><span class="punctuation">,</span>
                                    <span class="identifier">solver</span><span class="arithmetic-assignment">=</span><span class="identifier">solver</span><span class="grouping">)</span><span class="punctuation">,</span>
                              <span class="identifier">parameters</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="identifier">scoring</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span><span class="grouping">)</span>
            <span class="identifier">gs</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>
            <span class="identifier">estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">gs</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">gs</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span><span class="punctuation">.</span><span class="identifier">alpha</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_score_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">gs</span><span class="punctuation">.</span><span class="identifier">best_score_</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">coef_</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">intercept_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">intercept_</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_features_in_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">n_features_in_</span>

        <span class="keyword">return</span> <span class="identifier">self</span>


<span class="keyword">class</span> <span class="identifier">RidgeCV</span><span class="grouping">(</span><span class="identifier">MultiOutputMixin</span><span class="punctuation">,</span> <span class="identifier">RegressorMixin</span><span class="punctuation">,</span> <span class="identifier">_BaseRidgeCV</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Ridge regression with built-in cross-validation.

    See glossary entry for :term:`cross-validation estimator`.

    By default, it performs efficient Leave-One-Out Cross-Validation.

    Read more in the :ref:`User Guide &lt;ridge_regression&gt;`.

    Parameters
    ----------
    alphas : ndarray of shape (n_alphas,), default=(0.1, 1.0, 10.0)
        Array of alpha values to try.
        Regularization strength; must be a positive float. Regularization
        improves the conditioning of the problem and reduces the variance of
        the estimates. Larger values specify stronger regularization.
        Alpha corresponds to ``1 / (2C)`` in other linear models such as
        :class:`~sklearn.linear_model.LogisticRegression` or
        :class:`~sklearn.svm.LinearSVC`.
        If using Leave-One-Out cross-validation, alphas must be positive.

    fit_intercept : bool, default=True
        Whether to calculate the intercept for this model. If set
        to false, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    normalize : bool, default=False
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

        .. deprecated:: 1.0
            ``normalize`` was deprecated in version 1.0 and will be removed in
            1.2.

    scoring : string, callable, default=None
        A string (see model evaluation documentation) or
        a scorer callable object / function with signature
        ``scorer(estimator, X, y)``.
        If None, the negative mean squared error if cv is 'auto' or None
        (i.e. when using leave-one-out cross-validation), and r2 score
        otherwise.

    cv : int, cross-validation generator or an iterable, default=None
        Determines the cross-validation splitting strategy.
        Possible inputs for cv are:

        - None, to use the efficient Leave-One-Out cross-validation
        - integer, to specify the number of folds.
        - :term:`CV splitter`,
        - An iterable yielding (train, test) splits as arrays of indices.

        For integer/None inputs, if ``y`` is binary or multiclass,
        :class:`~sklearn.model_selection.StratifiedKFold` is used, else,
        :class:`~sklearn.model_selection.KFold` is used.

        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
        cross-validation strategies that can be used here.

    gcv_mode : {'auto', 'svd', eigen'}, default='auto'
        Flag indicating which strategy to use when performing
        Leave-One-Out Cross-Validation. Options are::

            'auto' : use 'svd' if n_samples &gt; n_features, otherwise use 'eigen'
            'svd' : force use of singular value decomposition of X when X is
                dense, eigenvalue decomposition of X^T.X when X is sparse.
            'eigen' : force computation via eigendecomposition of X.X^T

        The 'auto' mode is the default and is intended to pick the cheaper
        option of the two depending on the shape of the training data.

    store_cv_values : bool, default=False
        Flag indicating if the cross-validation values corresponding to
        each alpha should be stored in the ``cv_values_`` attribute (see
        below). This flag is only compatible with ``cv=None`` (i.e. using
        Leave-One-Out Cross-Validation).

    alpha_per_target : bool, default=False
        Flag indicating whether to optimize the alpha value (picked from the
        `alphas` parameter list) for each target separately (for multi-output
        settings: multiple prediction targets). When set to `True`, after
        fitting, the `alpha_` attribute will contain a value for each target.
        When set to `False`, a single alpha is used for all targets.

        .. versionadded:: 0.24

    Attributes
    ----------
    cv_values_ : ndarray of shape (n_samples, n_alphas) or \
        shape (n_samples, n_targets, n_alphas), optional
        Cross-validation values for each alpha (only available if
        ``store_cv_values=True`` and ``cv=None``). After ``fit()`` has been
        called, this attribute will contain the mean squared errors
        (by default) or the values of the ``{loss,score}_func`` function
        (if provided in the constructor).

    coef_ : ndarray of shape (n_features) or (n_targets, n_features)
        Weight vector(s).

    intercept_ : float or ndarray of shape (n_targets,)
        Independent term in decision function. Set to 0.0 if
        ``fit_intercept = False``.

    alpha_ : float or ndarray of shape (n_targets,)
        Estimated regularization parameter, or, if ``alpha_per_target=True``,
        the estimated regularization parameter for each target.

    best_score_ : float or ndarray of shape (n_targets,)
        Score of base estimator with best alpha, or, if
        ``alpha_per_target=True``, a score for each target.

        .. versionadded:: 0.23

    Examples
    --------
    &gt;&gt;&gt; from sklearn.datasets import load_diabetes
    &gt;&gt;&gt; from sklearn.linear_model import RidgeCV
    &gt;&gt;&gt; X, y = load_diabetes(return_X_y=True)
    &gt;&gt;&gt; clf = RidgeCV(alphas=[1e-3, 1e-2, 1e-1, 1]).fit(X, y)
    &gt;&gt;&gt; clf.score(X, y)
    0.5166...

    See Also
    --------
    Ridge : Ridge regression.
    RidgeClassifier : Ridge classifier.
    RidgeClassifierCV : Ridge classifier with built-in cross validation.
    """</span>


<span class="keyword">class</span> <span class="identifier">RidgeClassifierCV</span><span class="grouping">(</span><span class="identifier">LinearClassifierMixin</span><span class="punctuation">,</span> <span class="identifier">_BaseRidgeCV</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Ridge classifier with built-in cross-validation.

    See glossary entry for :term:`cross-validation estimator`.

    By default, it performs Leave-One-Out Cross-Validation. Currently,
    only the n_features &gt; n_samples case is handled efficiently.

    Read more in the :ref:`User Guide &lt;ridge_regression&gt;`.

    Parameters
    ----------
    alphas : ndarray of shape (n_alphas,), default=(0.1, 1.0, 10.0)
        Array of alpha values to try.
        Regularization strength; must be a positive float. Regularization
        improves the conditioning of the problem and reduces the variance of
        the estimates. Larger values specify stronger regularization.
        Alpha corresponds to ``1 / (2C)`` in other linear models such as
        :class:`~sklearn.linear_model.LogisticRegression` or
        :class:`~sklearn.svm.LinearSVC`.

    fit_intercept : bool, default=True
        Whether to calculate the intercept for this model. If set
        to false, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    normalize : bool, default=False
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

        .. deprecated:: 1.0
            ``normalize`` was deprecated in version 1.0 and
            will be removed in 1.2.

    scoring : string, callable, default=None
        A string (see model evaluation documentation) or
        a scorer callable object / function with signature
        ``scorer(estimator, X, y)``.

    cv : int, cross-validation generator or an iterable, default=None
        Determines the cross-validation splitting strategy.
        Possible inputs for cv are:

        - None, to use the efficient Leave-One-Out cross-validation
        - integer, to specify the number of folds.
        - :term:`CV splitter`,
        - An iterable yielding (train, test) splits as arrays of indices.

        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
        cross-validation strategies that can be used here.

    class_weight : dict or 'balanced', default=None
        Weights associated with classes in the form ``{class_label: weight}``.
        If not given, all classes are supposed to have weight one.

        The "balanced" mode uses the values of y to automatically adjust
        weights inversely proportional to class frequencies in the input data
        as ``n_samples / (n_classes * np.bincount(y))``

    store_cv_values : bool, default=False
        Flag indicating if the cross-validation values corresponding to
        each alpha should be stored in the ``cv_values_`` attribute (see
        below). This flag is only compatible with ``cv=None`` (i.e. using
        Leave-One-Out Cross-Validation).

    Attributes
    ----------
    cv_values_ : ndarray of shape (n_samples, n_targets, n_alphas), optional
        Cross-validation values for each alpha (if ``store_cv_values=True`` and
        ``cv=None``). After ``fit()`` has been called, this attribute will
        contain the mean squared errors (by default) or the values of the
        ``{loss,score}_func`` function (if provided in the constructor). This
        attribute exists only when ``store_cv_values`` is True.

    coef_ : ndarray of shape (1, n_features) or (n_targets, n_features)
        Coefficient of the features in the decision function.

        ``coef_`` is of shape (1, n_features) when the given problem is binary.

    intercept_ : float or ndarray of shape (n_targets,)
        Independent term in decision function. Set to 0.0 if
        ``fit_intercept = False``.

    alpha_ : float
        Estimated regularization parameter.

    best_score_ : float
        Score of base estimator with best alpha.

        .. versionadded:: 0.23

    classes_ : ndarray of shape (n_classes,)
        The classes labels.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.datasets import load_breast_cancer
    &gt;&gt;&gt; from sklearn.linear_model import RidgeClassifierCV
    &gt;&gt;&gt; X, y = load_breast_cancer(return_X_y=True)
    &gt;&gt;&gt; clf = RidgeClassifierCV(alphas=[1e-3, 1e-2, 1e-1, 1]).fit(X, y)
    &gt;&gt;&gt; clf.score(X, y)
    0.9630...

    See Also
    --------
    Ridge : Ridge regression.
    RidgeClassifier : Ridge classifier.
    RidgeCV : Ridge regression with built-in cross validation.

    Notes
    -----
    For multi-class classification, n_class classifiers are trained in
    a one-versus-all approach. Concretely, this is implemented by taking
    advantage of the multi-variate response support in Ridge.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="float-literal">0.1</span><span class="punctuation">,</span> <span class="float-literal">1.0</span><span class="punctuation">,</span> <span class="float-literal">10.0</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="string-literal">'deprecated'</span><span class="punctuation">,</span> <span class="identifier">scoring</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">w</span><span class="invalid">e</span><span class="invalid">i</span><span class="invalid">g</span><span class="invalid">h</span><span class="invalid">t</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">store_cv_values</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="identifier">alphas</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="identifier">normalize</span><span class="punctuation">,</span>
            <span class="identifier">scoring</span><span class="arithmetic-assignment">=</span><span class="identifier">scoring</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="identifier">store_cv_values</span><span class="arithmetic-assignment">=</span><span class="identifier">store_cv_values</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">w</span><span class="invalid">e</span><span class="invalid">i</span><span class="invalid">g</span><span class="invalid">h</span><span class="invalid">t</span> <span class="arithmetic-assignment">=</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">w</span><span class="invalid">e</span><span class="invalid">i</span><span class="invalid">g</span><span class="invalid">h</span><span class="invalid">t</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit Ridge classifier with cv.

        Parameters
        ----------
        X : ndarray of shape (n_samples, n_features)
            Training vectors, where n_samples is the number of samples
            and n_features is the number of features. When using GCV,
            will be cast to float64 if necessary.

        y : ndarray of shape (n_samples,)
            Target values. Will be cast to X's dtype if necessary.

        sample_weight : float or ndarray of shape (n_samples,), default=None
            Individual weights for each sample. If given a float, every sample
            will have the same weight.

        Returns
        -------
        self : object
        """</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="string-literal">'csr', 'csc', 'coo'</span><span class="grouping">]</span><span class="punctuation">,</span>
                                   <span class="identifier">multi_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">y_numeric</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_sample_weight</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_label_binarizer</span> <span class="arithmetic-assignment">=</span> <span class="identifier">LabelBinarizer</span><span class="grouping">(</span><span class="identifier">pos_label</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">neg_label</span><span class="arithmetic-assignment">=</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span>
        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_label_binarizer</span><span class="punctuation">.</span><span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_label_binarizer</span><span class="punctuation">.</span><span class="identifier">y_type_</span><span class="punctuation">.</span><span class="identifier">startswith</span><span class="grouping">(</span><span class="string-literal">'multilabel'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">warn</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">w</span><span class="invalid">e</span><span class="invalid">i</span><span class="invalid">g</span><span class="invalid">h</span><span class="invalid">t</span><span class="punctuation">:</span>
            <span class="comment"># modify the sample weights with the corresponding class weight</span>
            <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">sample_weight</span> <span class="arithmetic-operator">*</span>
                             <span class="identifier">compute_sample_weight</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">w</span><span class="invalid">e</span><span class="invalid">i</span><span class="invalid">g</span><span class="invalid">h</span><span class="invalid">t</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">target</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Y</span> <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="keyword">else</span> <span class="identifier">y</span>
        <span class="identifier">_BaseRidgeCV</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">target</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_label_binarizer</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span>
            <span class="string-literal">'_xfail_checks'</span><span class="punctuation">:</span> <span class="grouping">{</span>
                <span class="string-literal">'check_sample_weights_invariance'</span><span class="punctuation">:</span>
                <span class="string-literal">'zero sample_weight is not equivalent to removing samples'</span><span class="punctuation">,</span>
            <span class="grouping">}</span>
        <span class="grouping">}</span>

    </pre>
  </body>
</html>