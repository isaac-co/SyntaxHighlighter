<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment"># Authors: Alexandre Gramfort &lt;alexandre.gramfort@inria.fr&gt;</span>
<span class="comment">#          Mathieu Blondel &lt;mathieu@mblondel.org&gt;</span>
<span class="comment">#          Olivier Grisel &lt;olivier.grisel@ensta.org&gt;</span>
<span class="comment">#          Andreas Mueller &lt;amueller@ais.uni-bonn.de&gt;</span>
<span class="comment">#          Joel Nothman &lt;joel.nothman@gmail.com&gt;</span>
<span class="comment">#          Hamzeh Alsalhi &lt;ha258@cornell.edu&gt;</span>
<span class="comment"># License: BSD 3 clause</span>

<span class="keyword">from</span> <span class="identifier">collections</span> <span class="keyword">import</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">d</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">t</span>
<span class="keyword">import</span> <span class="identifier">itertools</span>
<span class="keyword">import</span> <span class="identifier">array</span>
<span class="keyword">import</span> <span class="identifier">warnings</span>

<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">import</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">sparse</span> <span class="keyword">as</span> <span class="identifier">sp</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">BaseEstimator</span><span class="punctuation">,</span> <span class="identifier">TransformerMixin</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">sparsefuncs</span> <span class="keyword">import</span> <span class="identifier">min_max_axis</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">column_or_1d</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_array</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_is_fitted</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">_num_samples</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">multiclass</span> <span class="keyword">import</span> <span class="identifier">unique_labels</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">multiclass</span> <span class="keyword">import</span> <span class="identifier">type_of_target</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">_encode</span> <span class="keyword">import</span> <span class="identifier">_encode</span><span class="punctuation">,</span> <span class="identifier">_unique</span>


<span class="identifier">__all__</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span>
    <span class="string-literal">'label_binarize'</span><span class="punctuation">,</span>
    <span class="string-literal">'LabelBinarizer'</span><span class="punctuation">,</span>
    <span class="string-literal">'LabelEncoder'</span><span class="punctuation">,</span>
    <span class="string-literal">'MultiLabelBinarizer'</span><span class="punctuation">,</span>
<span class="grouping">]</span>


<span class="keyword">class</span> <span class="identifier">LabelEncoder</span><span class="grouping">(</span><span class="identifier">TransformerMixin</span><span class="punctuation">,</span> <span class="identifier">BaseEstimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Encode target labels with value between 0 and n_classes-1.

    This transformer should be used to encode target values, *i.e.* `y`, and
    not the input `X`.

    Read more in the :ref:`User Guide &lt;preprocessing_targets&gt;`.

    .. versionadded:: 0.12

    Attributes
    ----------
    classes_ : ndarray of shape (n_classes,)
        Holds the label for each class.

    Examples
    --------
    `LabelEncoder` can be used to normalize labels.

    &gt;&gt;&gt; from sklearn import preprocessing
    &gt;&gt;&gt; le = preprocessing.LabelEncoder()
    &gt;&gt;&gt; le.fit([1, 2, 2, 6])
    LabelEncoder()
    &gt;&gt;&gt; le.classes_
    array([1, 2, 6])
    &gt;&gt;&gt; le.transform([1, 1, 2, 6])
    array([0, 0, 1, 2]...)
    &gt;&gt;&gt; le.inverse_transform([0, 0, 1, 2])
    array([1, 1, 2, 6])

    It can also be used to transform non-numerical labels (as long as they are
    hashable and comparable) to numerical labels.

    &gt;&gt;&gt; le = preprocessing.LabelEncoder()
    &gt;&gt;&gt; le.fit(["paris", "paris", "tokyo", "amsterdam"])
    LabelEncoder()
    &gt;&gt;&gt; list(le.classes_)
    ['amsterdam', 'paris', 'tokyo']
    &gt;&gt;&gt; le.transform(["tokyo", "tokyo", "paris"])
    array([2, 2, 1]...)
    &gt;&gt;&gt; list(le.inverse_transform([2, 2, 1]))
    ['tokyo', 'tokyo', 'paris']

    See Also
    --------
    OrdinalEncoder : Encode categorical features using an ordinal encoding
        scheme.
    OneHotEncoder : Encode categorical features as a one-hot numeric array.
    """</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit label encoder.

        Parameters
        ----------
        y : array-like of shape (n_samples,)
            Target values.

        Returns
        -------
        self : returns an instance of self.
        """</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">warn</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_unique</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit label encoder and return encoded labels.

        Parameters
        ----------
        y : array-like of shape (n_samples,)
            Target values.

        Returns
        -------
        y : array-like of shape (n_samples,)
        """</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">warn</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_unique</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">v</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">s</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">y</span>

    <span class="keyword">def</span> <span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Transform labels to normalized encoding.

        Parameters
        ----------
        y : array-like of shape (n_samples,)
            Target values.

        Returns
        -------
        y : array-like of shape (n_samples,)
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">warn</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="comment"># transform of empty array is empty array</span>
        <span class="keyword">if</span> <span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">_encode</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">uniques</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">inverse_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Transform labels back to original encoding.

        Parameters
        ----------
        y : ndarray of shape (n_samples,)
            Target values.

        Returns
        -------
        y : ndarray of shape (n_samples,)
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">warn</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="comment"># inverse transform of empty array is empty array</span>
        <span class="keyword">if</span> <span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="identifier">diff</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">setdiff1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">diff</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                    <span class="string-literal">"y contains previously unseen labels: %s"</span> <span class="arithmetic-operator">%</span> <span class="identifier">str</span><span class="grouping">(</span><span class="identifier">diff</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="identifier">y</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'X_types': ['1dlabels'</span><span class="grouping">]</span><span class="grouping">}</span>


<span class="keyword">class</span> <span class="identifier">LabelBinarizer</span><span class="grouping">(</span><span class="identifier">TransformerMixin</span><span class="punctuation">,</span> <span class="identifier">BaseEstimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Binarize labels in a one-vs-all fashion.

    Several regression and binary classification algorithms are
    available in scikit-learn. A simple way to extend these algorithms
    to the multi-class classification case is to use the so-called
    one-vs-all scheme.

    At learning time, this simply consists in learning one regressor
    or binary classifier per class. In doing so, one needs to convert
    multi-class labels to binary labels (belong or does not belong
    to the class). LabelBinarizer makes this process easy with the
    transform method.

    At prediction time, one assigns the class for which the corresponding
    model gave the greatest confidence. LabelBinarizer makes this easy
    with the inverse_transform method.

    Read more in the :ref:`User Guide &lt;preprocessing_targets&gt;`.

    Parameters
    ----------

    neg_label : int, default=0
        Value with which negative labels must be encoded.

    pos_label : int, default=1
        Value with which positive labels must be encoded.

    sparse_output : bool, default=False
        True if the returned array from transform is desired to be in sparse
        CSR format.

    Attributes
    ----------

    classes_ : ndarray of shape (n_classes,)
        Holds the label for each class.

    y_type_ : str
        Represents the type of the target data as evaluated by
        utils.multiclass.type_of_target. Possible type are 'continuous',
        'continuous-multioutput', 'binary', 'multiclass',
        'multiclass-multioutput', 'multilabel-indicator', and 'unknown'.

    sparse_input_ : bool
        True if the input data to transform is given as a sparse matrix, False
        otherwise.

    Examples
    --------
    &gt;&gt;&gt; from sklearn import preprocessing
    &gt;&gt;&gt; lb = preprocessing.LabelBinarizer()
    &gt;&gt;&gt; lb.fit([1, 2, 6, 4, 2])
    LabelBinarizer()
    &gt;&gt;&gt; lb.classes_
    array([1, 2, 4, 6])
    &gt;&gt;&gt; lb.transform([1, 6])
    array([[1, 0, 0, 0],
           [0, 0, 0, 1]])

    Binary targets transform to a column vector

    &gt;&gt;&gt; lb = preprocessing.LabelBinarizer()
    &gt;&gt;&gt; lb.fit_transform(['yes', 'no', 'no', 'yes'])
    array([[1],
           [0],
           [0],
           [1]])

    Passing a 2D matrix for multilabel classification

    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; lb.fit(np.array([[0, 1, 1], [1, 0, 0]]))
    LabelBinarizer()
    &gt;&gt;&gt; lb.classes_
    array([0, 1, 2])
    &gt;&gt;&gt; lb.transform([0, 1, 2, 1])
    array([[1, 0, 0],
           [0, 1, 0],
           [0, 0, 1],
           [0, 1, 0]])

    See Also
    --------
    label_binarize : Function to perform the transform operation of
        LabelBinarizer with fixed classes.
    OneHotEncoder : Encode categorical features using a one-hot aka one-of-K
        scheme.
    """</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">neg_label</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">pos_label</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">sparse_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">neg_label</span> <span class="relational-operator">&gt;=</span> <span class="identifier">pos_label</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"neg_label={0} must be strictly less than "</span>
                             <span class="string-literal">"pos_label={1}."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">neg_label</span><span class="punctuation">,</span> <span class="identifier">pos_label</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">sparse_output</span> <span class="logical-operator">and</span> <span class="grouping">(</span><span class="identifier">pos_label</span> <span class="relational-operator">==</span> <span class="int-literal">0</span> <span class="logical-operator">or</span> <span class="identifier">neg_label</span> <span class="relational-operator">!=</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Sparse binarization is only supported with non "</span>
                             <span class="string-literal">"zero pos_label and zero neg_label, got "</span>
                             <span class="string-literal">"pos_label={0} and neg_label={1}"</span>
                             <span class="string-literal">""</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">pos_label</span><span class="punctuation">,</span> <span class="identifier">neg_label</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">neg_label</span> <span class="arithmetic-assignment">=</span> <span class="identifier">neg_label</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">pos_label</span> <span class="arithmetic-assignment">=</span> <span class="identifier">pos_label</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sparse_output</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sparse_output</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit label binarizer.

        Parameters
        ----------
        y : ndarray of shape (n_samples,) or (n_samples, n_classes)
            Target values. The 2-d matrix should only contain 0 and 1,
            represents multilabel classification.

        Returns
        -------
        self : returns an instance of self.
        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">y_type_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">type_of_target</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="string-literal">'multioutput'</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">y_type_</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Multioutput target data is not supported with "</span>
                             <span class="string-literal">"label binarization"</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'y has 0 samples: %r'</span> <span class="arithmetic-operator">%</span> <span class="identifier">y</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sparse_input_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">unique_labels</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit label binarizer and transform multi-class labels to binary
        labels.

        The output of transform is sometimes referred to as
        the 1-of-K coding scheme.

        Parameters
        ----------
        y : {ndarray, sparse matrix} of shape (n_samples,) or \
                (n_samples, n_classes)
            Target values. The 2-d matrix should only contain 0 and 1,
            represents multilabel classification. Sparse matrix can be
            CSR, CSC, COO, DOK, or LIL.

        Returns
        -------
        Y : {ndarray, sparse matrix} of shape (n_samples, n_classes)
            Shape will be (n_samples, 1) for binary problems. Sparse matrix
            will be of CSR format.
        """</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Transform multi-class labels to binary labels.

        The output of transform is sometimes referred to by some authors as
        the 1-of-K coding scheme.

        Parameters
        ----------
        y : {array, sparse matrix} of shape (n_samples,) or \
                (n_samples, n_classes)
            Target values. The 2-d matrix should only contain 0 and 1,
            represents multilabel classification. Sparse matrix can be
            CSR, CSC, COO, DOK, or LIL.

        Returns
        -------
        Y : {ndarray, sparse matrix} of shape (n_samples, n_classes)
            Shape will be (n_samples, 1) for binary problems. Sparse matrix
            will be of CSR format.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="identifier">y_is_multilabel</span> <span class="arithmetic-assignment">=</span> <span class="identifier">type_of_target</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">startswith</span><span class="grouping">(</span><span class="string-literal">'multilabel'</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">y_is_multilabel</span> <span class="logical-operator">and</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">y_type_</span><span class="punctuation">.</span><span class="identifier">startswith</span><span class="grouping">(</span><span class="string-literal">'multilabel'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"The object was not fitted with multilabel"</span>
                             <span class="string-literal">" input."</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">label_binarize</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="punctuation">,</span>
                              <span class="identifier">pos_label</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">pos_label</span><span class="punctuation">,</span>
                              <span class="identifier">neg_label</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">neg_label</span><span class="punctuation">,</span>
                              <span class="identifier">sparse_output</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sparse_output</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">inverse_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">Y</span><span class="punctuation">,</span> <span class="identifier">threshold</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Transform binary labels back to multi-class labels.

        Parameters
        ----------
        Y : {ndarray, sparse matrix} of shape (n_samples, n_classes)
            Target values. All sparse matrices are converted to CSR before
            inverse transformation.

        threshold : float, default=None
            Threshold used in the binary and multi-label cases.

            Use 0 when ``Y`` contains the output of decision_function
            (classifier).
            Use 0.5 when ``Y`` contains the output of predict_proba.

            If None, the threshold is assumed to be half way between
            neg_label and pos_label.

        Returns
        -------
        y : {ndarray, sparse matrix} of shape (n_samples,)
            Target values. Sparse matrix will be of CSR format.

        Notes
        -----
        In the case when the binary labels are fractional
        (probabilistic), inverse_transform chooses the class with the
        greatest value. Typically, this allows to use the output of a
        linear model's decision_function method directly as the input
        of inverse_transform.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">threshold</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">threshold</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">pos_label</span> <span class="arithmetic-operator">+</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">neg_label</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="int-literal">2</span><span class="punctuation">.</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">y_type_</span> <span class="relational-operator">==</span> <span class="string-literal">"multiclass"</span><span class="punctuation">:</span>
            <span class="identifier">y_inv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_inverse_binarize_multiclass</span><span class="grouping">(</span><span class="identifier">Y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">y_inv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_inverse_binarize_thresholding</span><span class="grouping">(</span><span class="identifier">Y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">y_type_</span><span class="punctuation">,</span>
                                                   <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="punctuation">,</span> <span class="identifier">threshold</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sparse_input_</span><span class="punctuation">:</span>
            <span class="identifier">y_inv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">csr_matrix</span><span class="grouping">(</span><span class="identifier">y_inv</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">y_inv</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">y_inv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y_inv</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">y_inv</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'X_types': ['1dlabels'</span><span class="grouping">]</span><span class="grouping">}</span>


<span class="keyword">def</span> <span class="identifier">label_binarize</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="punctuation">,</span> <span class="identifier">neg_label</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">pos_label</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span>
                   <span class="identifier">sparse_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Binarize labels in a one-vs-all fashion.

    Several regression and binary classification algorithms are
    available in scikit-learn. A simple way to extend these algorithms
    to the multi-class classification case is to use the so-called
    one-vs-all scheme.

    This function makes it possible to compute this transformation for a
    fixed set of class labels known ahead of time.

    Parameters
    ----------
    y : array-like
        Sequence of integer labels or multilabel data to encode.

    classes : array-like of shape (n_classes,)
        Uniquely holds the label for each class.

    neg_label : int, default=0
        Value with which negative labels must be encoded.

    pos_label : int, default=1
        Value with which positive labels must be encoded.

    sparse_output : bool, default=False,
        Set to true if output binary array is desired in CSR sparse format.

    Returns
    -------
    Y : {ndarray, sparse matrix} of shape (n_samples, n_classes)
        Shape will be (n_samples, 1) for binary problems. Sparse matrix will
        be of CSR format.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.preprocessing import label_binarize
    &gt;&gt;&gt; label_binarize([1, 6], classes=[1, 2, 4, 6])
    array([[1, 0, 0, 0],
           [0, 0, 0, 1]])

    The class ordering is preserved:

    &gt;&gt;&gt; label_binarize([1, 6], classes=[1, 6, 4, 2])
    array([[1, 0, 0, 0],
           [0, 1, 0, 0]])

    Binary targets transform to a column vector

    &gt;&gt;&gt; label_binarize(['yes', 'no', 'no', 'yes'], classes=['no', 'yes'])
    array([[1],
           [0],
           [0],
           [1]])

    See Also
    --------
    LabelBinarizer : Class used to wrap the functionality of label_binarize and
        allow for fitting to classes independently of the transform operation.
    """</span>
    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">list</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># XXX Workaround that will be removed when list of list format is</span>
        <span class="comment"># dropped</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csr'</span><span class="punctuation">,</span> <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'y has 0 samples: %r'</span> <span class="arithmetic-operator">%</span> <span class="identifier">y</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">neg_label</span> <span class="relational-operator">&gt;=</span> <span class="identifier">pos_label</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"neg_label={0} must be strictly less than "</span>
                         <span class="string-literal">"pos_label={1}."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">neg_label</span><span class="punctuation">,</span> <span class="identifier">pos_label</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">sparse_output</span> <span class="logical-operator">and</span> <span class="grouping">(</span><span class="identifier">pos_label</span> <span class="relational-operator">==</span> <span class="int-literal">0</span> <span class="logical-operator">or</span> <span class="identifier">neg_label</span> <span class="relational-operator">!=</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Sparse binarization is only supported with non "</span>
                         <span class="string-literal">"zero pos_label and zero neg_label, got "</span>
                         <span class="string-literal">"pos_label={0} and neg_label={1}"</span>
                         <span class="string-literal">""</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">pos_label</span><span class="punctuation">,</span> <span class="identifier">neg_label</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="comment"># To account for pos_label == 0 in the dense case</span>
    <span class="identifier">pos_switch</span> <span class="arithmetic-assignment">=</span> <span class="identifier">pos_label</span> <span class="relational-operator">==</span> <span class="int-literal">0</span>
    <span class="keyword">if</span> <span class="identifier">pos_switch</span><span class="punctuation">:</span>
        <span class="identifier">pos_label</span> <span class="arithmetic-assignment">=</span> <span class="arithmetic-operator">-</span><span class="identifier">neg_label</span>

    <span class="identifier">y_type</span> <span class="arithmetic-assignment">=</span> <span class="identifier">type_of_target</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="string-literal">'multioutput'</span> <span class="relational-operator">in</span> <span class="identifier">y_type</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Multioutput target data is not supported with label "</span>
                         <span class="string-literal">"binarization"</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">y_type</span> <span class="relational-operator">==</span> <span class="string-literal">'unknown'</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"The type of target data is not known"</span><span class="grouping">)</span>

    <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span> <span class="keyword">else</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
    <span class="identifier">n_classes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span>
    <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">y_type</span> <span class="relational-operator">==</span> <span class="string-literal">"binary"</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">n_classes</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">sparse_output</span><span class="punctuation">:</span>
                <span class="keyword">return</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">csr_matrix</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">int</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">int</span><span class="grouping">)</span>
                <span class="identifier">Y</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">neg_label</span>
                <span class="keyword">return</span> <span class="identifier">Y</span>
        <span class="keyword">elif</span> <span class="identifier">len</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span> <span class="relational-operator">&gt;=</span> <span class="int-literal">3</span><span class="punctuation">:</span>
            <span class="identifier">y_type</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"multiclass"</span>

    <span class="identifier">sorted_class</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sort</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">y_type</span> <span class="relational-operator">==</span> <span class="string-literal">"multilabel-indicator"</span><span class="punctuation">:</span>
        <span class="identifier">y_n_classes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="string-literal">'shape'</span><span class="grouping">)</span> <span class="keyword">else</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="punctuation">.</span><span class="identifier">size</span> <span class="relational-operator">!=</span> <span class="identifier">y_n_classes</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"classes {0} mismatch with the labels {1}"</span>
                             <span class="string-literal">" found in the data"</span>
                             <span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="punctuation">,</span> <span class="identifier">unique_labels</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">y_type</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="string-literal">"binary", "multiclass"</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>

        <span class="comment"># pick out the known labels from y</span>
        <span class="identifier">y_in_classes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">in1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span>
        <span class="identifier">y_seen</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="grouping">[</span><span class="identifier">y_in_classes</span><span class="grouping">]</span>
        <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">searchsorted</span><span class="grouping">(</span><span class="identifier">sorted_class</span><span class="punctuation">,</span> <span class="identifier">y_seen</span><span class="grouping">)</span>
        <span class="identifier">indptr</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">hstack</span><span class="grouping">(</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">cumsum</span><span class="grouping">(</span><span class="identifier">y_in_classes</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty_like</span><span class="grouping">(</span><span class="identifier">indices</span><span class="grouping">)</span>
        <span class="identifier">data</span><span class="punctuation">.</span><span class="identifier">fill</span><span class="grouping">(</span><span class="identifier">pos_label</span><span class="grouping">)</span>
        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">csr_matrix</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">data</span><span class="punctuation">,</span> <span class="identifier">indices</span><span class="punctuation">,</span> <span class="identifier">indptr</span><span class="grouping">)</span><span class="punctuation">,</span>
                          <span class="identifier">shape</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_classes</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">elif</span> <span class="identifier">y_type</span> <span class="relational-operator">==</span> <span class="string-literal">"multilabel-indicator"</span><span class="punctuation">:</span>
        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">csr_matrix</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">pos_label</span> <span class="relational-operator">!=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty_like</span><span class="grouping">(</span><span class="identifier">Y</span><span class="punctuation">.</span><span class="identifier">data</span><span class="grouping">)</span>
            <span class="identifier">data</span><span class="punctuation">.</span><span class="identifier">fill</span><span class="grouping">(</span><span class="identifier">pos_label</span><span class="grouping">)</span>
            <span class="identifier">Y</span><span class="punctuation">.</span><span class="identifier">data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">data</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"%s target data is not supported with label "</span>
                         <span class="string-literal">"binarization"</span> <span class="arithmetic-operator">%</span> <span class="identifier">y_type</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">sparse_output</span><span class="punctuation">:</span>
        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Y</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Y</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">int</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">neg_label</span> <span class="relational-operator">!=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="identifier">Y</span><span class="grouping">[</span><span class="identifier">Y</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">neg_label</span>

        <span class="keyword">if</span> <span class="identifier">pos_switch</span><span class="punctuation">:</span>
            <span class="identifier">Y</span><span class="grouping">[</span><span class="identifier">Y</span> <span class="relational-operator">==</span> <span class="identifier">pos_label</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">Y</span><span class="punctuation">.</span><span class="identifier">data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Y</span><span class="punctuation">.</span><span class="identifier">data</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">int</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="comment"># preserve label ordering</span>
    <span class="keyword">if</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">any</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span> <span class="relational-operator">!=</span> <span class="identifier">sorted_class</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">searchsorted</span><span class="grouping">(</span><span class="identifier">sorted_class</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span>
        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Y</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">indices</span><span class="grouping">]</span>

    <span class="keyword">if</span> <span class="identifier">y_type</span> <span class="relational-operator">==</span> <span class="string-literal">"binary"</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">sparse_output</span><span class="punctuation">:</span>
            <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Y</span><span class="punctuation">.</span><span class="identifier">getcol</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Y</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">Y</span>


<span class="keyword">def</span> <span class="identifier">_inverse_binarize_multiclass</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Inverse label binarization transformation for multiclass.

    Multiclass uses the maximal score instead of a threshold.
    """</span>
    <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># Find the argmax for each row in y where y is a CSR matrix</span>

        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">tocsr</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_outputs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span>
        <span class="identifier">outputs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">n_outputs</span><span class="grouping">)</span>
        <span class="identifier">row_max</span> <span class="arithmetic-assignment">=</span> <span class="identifier">min_max_axis</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>
        <span class="identifier">row_nnz</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">diff</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">indptr</span><span class="grouping">)</span>

        <span class="identifier">y_data_repeated_max</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">repeat</span><span class="grouping">(</span><span class="identifier">row_max</span><span class="punctuation">,</span> <span class="identifier">row_nnz</span><span class="grouping">)</span>
        <span class="comment"># picks out all indices obtaining the maximum per row</span>
        <span class="identifier">y_i_all_argmax</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">flatnonzero</span><span class="grouping">(</span><span class="identifier">y_data_repeated_max</span> <span class="relational-operator">==</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">data</span><span class="grouping">)</span>

        <span class="comment"># For corner case where last row has a max of 0</span>
        <span class="keyword">if</span> <span class="identifier">row_max</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="identifier">y_i_all_argmax</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">y_i_all_argmax</span><span class="punctuation">,</span> <span class="grouping">[</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">data</span><span class="grouping">)</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="comment"># Gets the index of the first argmax in each row from y_i_all_argmax</span>
        <span class="identifier">index_first_argmax</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">searchsorted</span><span class="grouping">(</span><span class="identifier">y_i_all_argmax</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">indptr</span><span class="grouping">[</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="comment"># first argmax of each row</span>
        <span class="identifier">y_ind_ext</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">indices</span><span class="punctuation">,</span> <span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="identifier">y_i_argmax</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y_ind_ext</span><span class="grouping">[</span><span class="identifier">y_i_all_argmax</span><span class="grouping">[</span><span class="identifier">index_first_argmax</span><span class="grouping">]</span><span class="grouping">]</span>
        <span class="comment"># Handle rows of all 0</span>
        <span class="identifier">y_i_argmax</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">where</span><span class="grouping">(</span><span class="identifier">row_nnz</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>

        <span class="comment"># Handles rows with max of 0 that contain negative numbers</span>
        <span class="identifier">samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="grouping">)</span><span class="grouping">[</span><span class="grouping">(</span><span class="identifier">row_nnz</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="grouping">)</span> <span class="bitwise-operator">&</span>
                                       <span class="grouping">(</span><span class="identifier">row_max</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">]</span>
        <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">samples</span><span class="punctuation">:</span>
            <span class="identifier">ind</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">indptr</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">:</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">indptr</span><span class="grouping">[</span><span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">]</span>
            <span class="identifier">y_i_argmax</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">setdiff1d</span><span class="grouping">(</span><span class="identifier">outputs</span><span class="punctuation">,</span> <span class="identifier">ind</span><span class="grouping">)</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

        <span class="keyword">return</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">[</span><span class="identifier">y_i_argmax</span><span class="grouping">]</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="punctuation">.</span><span class="identifier">take</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">argmax</span><span class="grouping">(</span><span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">mode</span><span class="arithmetic-assignment">=</span><span class="string-literal">"clip"</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_inverse_binarize_thresholding</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">output_type</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="punctuation">,</span> <span class="identifier">threshold</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Inverse label binarization transformation using thresholding."""</span>

    <span class="keyword">if</span> <span class="identifier">output_type</span> <span class="relational-operator">==</span> <span class="string-literal">"binary"</span> <span class="logical-operator">and</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">2</span> <span class="logical-operator">and</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="relational-operator">&gt;</span> <span class="int-literal">2</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"output_type='binary', but y.shape = {0}"</span><span class="punctuation">.</span>
                         <span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">output_type</span> <span class="relational-operator">!=</span> <span class="string-literal">"binary"</span> <span class="logical-operator">and</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="relational-operator">!=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"The number of class is not equal to the number of "</span>
                         <span class="string-literal">"dimension of y."</span><span class="grouping">)</span>

    <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span>

    <span class="comment"># Perform thresholding</span>
    <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">threshold</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="string-literal">'csr', 'csc'</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">tocsr</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">data</span> <span class="relational-operator">&gt;</span> <span class="identifier">threshold</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">int</span><span class="grouping">)</span>
            <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">eliminate_zeros</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="identifier">threshold</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">int</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="identifier">y</span> <span class="relational-operator">&gt;</span> <span class="identifier">threshold</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">int</span><span class="grouping">)</span>

    <span class="comment"># Inverse transform data</span>
    <span class="keyword">if</span> <span class="identifier">output_type</span> <span class="relational-operator">==</span> <span class="string-literal">"binary"</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">2</span> <span class="logical-operator">and</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="relational-operator">==</span> <span class="int-literal">2</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">[</span><span class="identifier">y</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">]</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">repeat</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="keyword">return</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">[</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">]</span>

    <span class="keyword">elif</span> <span class="identifier">output_type</span> <span class="relational-operator">==</span> <span class="string-literal">"multilabel-indicator"</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">y</span>

    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"{0} format is not supported"</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">output_type</span><span class="grouping">)</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">MultiLabelBinarizer</span><span class="grouping">(</span><span class="identifier">TransformerMixin</span><span class="punctuation">,</span> <span class="identifier">BaseEstimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Transform between iterable of iterables and a multilabel format.

    Although a list of sets or tuples is a very intuitive format for multilabel
    data, it is unwieldy to process. This transformer converts between this
    intuitive format and the supported multilabel format: a (samples x classes)
    binary matrix indicating the presence of a class label.

    Parameters
    ----------
    classes : array-like of shape (n_classes,), default=None
        Indicates an ordering for the class labels.
        All entries should be unique (cannot contain duplicate classes).

    sparse_output : bool, default=False
        Set to True if output binary array is desired in CSR sparse format.

    Attributes
    ----------
    classes_ : ndarray of shape (n_classes,)
        A copy of the `classes` parameter when provided.
        Otherwise it corresponds to the sorted set of classes found
        when fitting.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.preprocessing import MultiLabelBinarizer
    &gt;&gt;&gt; mlb = MultiLabelBinarizer()
    &gt;&gt;&gt; mlb.fit_transform([(1, 2), (3,)])
    array([[1, 1, 0],
           [0, 0, 1]])
    &gt;&gt;&gt; mlb.classes_
    array([1, 2, 3])

    &gt;&gt;&gt; mlb.fit_transform([{'sci-fi', 'thriller'}, {'comedy'}])
    array([[0, 1, 1],
           [1, 0, 0]])
    &gt;&gt;&gt; list(mlb.classes_)
    ['comedy', 'sci-fi', 'thriller']

    A common mistake is to pass in a list, which leads to the following issue:

    &gt;&gt;&gt; mlb = MultiLabelBinarizer()
    &gt;&gt;&gt; mlb.fit(['sci-fi', 'thriller', 'comedy'])
    MultiLabelBinarizer()
    &gt;&gt;&gt; mlb.classes_
    array(['-', 'c', 'd', 'e', 'f', 'h', 'i', 'l', 'm', 'o', 'r', 's', 't',
        'y'], dtype=object)

    To correct this, the list of labels should be passed in as:

    &gt;&gt;&gt; mlb = MultiLabelBinarizer()
    &gt;&gt;&gt; mlb.fit([['sci-fi', 'thriller', 'comedy']])
    MultiLabelBinarizer()
    &gt;&gt;&gt; mlb.classes_
    array(['comedy', 'sci-fi', 'thriller'], dtype=object)

    See Also
    --------
    OneHotEncoder : Encode categorical features using a one-hot aka one-of-K
        scheme.
    """</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">sparse_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span> <span class="arithmetic-assignment">=</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sparse_output</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sparse_output</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the label sets binarizer, storing :term:`classes_`.

        Parameters
        ----------
        y : iterable of iterables
            A set of labels (any orderable and hashable object) for each
            sample. If the `classes` parameter is set, `y` will not be
            iterated.

        Returns
        -------
        self : returns this MultiLabelBinarizer instance
        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_cached_dict</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sorted</span><span class="grouping">(</span><span class="identifier">set</span><span class="grouping">(</span><span class="identifier">itertools</span><span class="punctuation">.</span><span class="identifier">chain</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">r</span><span class="invalid">o</span><span class="invalid">m</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">b</span><span class="invalid">l</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">set</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span><span class="grouping">)</span> <span class="relational-operator">&lt;</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"The classes argument contains duplicate "</span>
                             <span class="string-literal">"classes. Remove these duplicates before passing "</span>
                             <span class="string-literal">"them to MultiLabelBinarizer."</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span>
        <span class="identifier">dtype</span> <span class="arithmetic-assignment">=</span> <span class="identifier">int</span> <span class="keyword">if</span> <span class="identifier">all</span><span class="grouping">(</span><span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">c</span><span class="punctuation">,</span> <span class="identifier">int</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">c</span> <span class="relational-operator">in</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span> <span class="keyword">else</span> <span class="identifier">object</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="punctuation">:</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the label sets binarizer and transform the given label sets.

        Parameters
        ----------
        y : iterable of iterables
            A set of labels (any orderable and hashable object) for each
            sample. If the `classes` parameter is set, `y` will not be
            iterated.

        Returns
        -------
        y_indicator : {ndarray, sparse matrix} of shape (n_samples, n_classes)
            A matrix such that `y_indicator[i, j] = 1` i.f.f. `classes_[j]`
            is in `y[i]`, and 0 otherwise. Sparse matrix will be of CSR
            format.
        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_cached_dict</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>

        <span class="comment"># Automatically increment on new class</span>
        <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">p</span><span class="invalid">p</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">g</span> <span class="arithmetic-assignment">=</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">d</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">int</span><span class="grouping">)</span>
        <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">p</span><span class="invalid">p</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">g</span><span class="punctuation">.</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">c</span><span class="invalid">t</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">y</span> <span class="arithmetic-assignment">=</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">p</span><span class="invalid">p</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">g</span><span class="punctuation">.</span><span class="identifier">__len__</span>
        <span class="identifier">yt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_transform</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">p</span><span class="invalid">p</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">g</span><span class="grouping">)</span>

        <span class="comment"># sort classes and reorder columns</span>
        <span class="identifier">tmp</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sorted</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">p</span><span class="invalid">p</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">g</span><span class="punctuation">,</span> <span class="identifier">key</span><span class="arithmetic-assignment">=</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">p</span><span class="invalid">p</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">g</span><span class="punctuation">.</span><span class="identifier">get</span><span class="grouping">)</span>

        <span class="comment"># (make safe for tuples)</span>
        <span class="identifier">dtype</span> <span class="arithmetic-assignment">=</span> <span class="identifier">int</span> <span class="keyword">if</span> <span class="identifier">all</span><span class="grouping">(</span><span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">c</span><span class="punctuation">,</span> <span class="identifier">int</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">c</span> <span class="relational-operator">in</span> <span class="identifier">tmp</span><span class="grouping">)</span> <span class="keyword">else</span> <span class="identifier">object</span>
        <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">p</span><span class="invalid">p</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">g</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">tmp</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">p</span><span class="invalid">p</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">g</span><span class="grouping">[</span><span class="punctuation">:</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">tmp</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="punctuation">,</span> <span class="identifier">inverse</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">p</span><span class="invalid">p</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">g</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">v</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">s</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="comment"># ensure yt.indices keeps its current dtype</span>
        <span class="identifier">yt</span><span class="punctuation">.</span><span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="identifier">inverse</span><span class="grouping">[</span><span class="identifier">yt</span><span class="punctuation">.</span><span class="identifier">indices</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">yt</span><span class="punctuation">.</span><span class="identifier">indices</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span>
                              <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sparse_output</span><span class="punctuation">:</span>
            <span class="identifier">yt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">yt</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">yt</span>

    <span class="keyword">def</span> <span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Transform the given label sets.

        Parameters
        ----------
        y : iterable of iterables
            A set of labels (any orderable and hashable object) for each
            sample. If the `classes` parameter is set, `y` will not be
            iterated.

        Returns
        -------
        y_indicator : array or CSR matrix, shape (n_samples, n_classes)
            A matrix such that `y_indicator[i, j] = 1` iff `classes_[j]` is in
            `y[i]`, and 0 otherwise.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">o</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">x</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_build_cache</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">yt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_transform</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">o</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">x</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sparse_output</span><span class="punctuation">:</span>
            <span class="identifier">yt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">yt</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">yt</span>

    <span class="keyword">def</span> <span class="identifier">_build_cache</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_cached_dict</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_cached_dict</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dict</span><span class="grouping">(</span><span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="punctuation">,</span>
                                         <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_cached_dict</span>

    <span class="keyword">def</span> <span class="identifier">_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">p</span><span class="invalid">p</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">g</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Transforms the label sets with a given mapping

        Parameters
        ----------
        y : iterable of iterables
        class_mapping : Mapping
            Maps from label to column index in label indicator matrix.

        Returns
        -------
        y_indicator : sparse matrix of shape (n_samples, n_classes)
            Label indicator matrix. Will be of CSR format.
        """</span>
        <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">array</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="string-literal">'i'</span><span class="grouping">)</span>
        <span class="identifier">indptr</span> <span class="arithmetic-assignment">=</span> <span class="identifier">array</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="string-literal">'i'</span><span class="punctuation">,</span> <span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="identifier">unknown</span> <span class="arithmetic-assignment">=</span> <span class="identifier">set</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">labels</span> <span class="relational-operator">in</span> <span class="identifier">y</span><span class="punctuation">:</span>
            <span class="identifier">index</span> <span class="arithmetic-assignment">=</span> <span class="identifier">set</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="keyword">for</span> <span class="identifier">label</span> <span class="relational-operator">in</span> <span class="identifier">labels</span><span class="punctuation">:</span>
                <span class="keyword">try</span><span class="punctuation">:</span>
                    <span class="identifier">index</span><span class="punctuation">.</span><span class="identifier">add</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">p</span><span class="invalid">p</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">g</span><span class="grouping">[</span><span class="identifier">label</span><span class="grouping">]</span><span class="grouping">)</span>
                <span class="keyword">except</span> <span class="identifier">KeyError</span><span class="punctuation">:</span>
                    <span class="identifier">unknown</span><span class="punctuation">.</span><span class="identifier">add</span><span class="grouping">(</span><span class="identifier">label</span><span class="grouping">)</span>
            <span class="identifier">indices</span><span class="punctuation">.</span><span class="identifier">extend</span><span class="grouping">(</span><span class="identifier">index</span><span class="grouping">)</span>
            <span class="identifier">indptr</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">indices</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">unknown</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">'unknown class(es) {0} will be ignored'</span>
                          <span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">sorted</span><span class="grouping">(</span><span class="identifier">unknown</span><span class="punctuation">,</span> <span class="identifier">key</span><span class="arithmetic-assignment">=</span><span class="identifier">str</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ones</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">indices</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">int</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">csr_matrix</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">data</span><span class="punctuation">,</span> <span class="identifier">indices</span><span class="punctuation">,</span> <span class="identifier">indptr</span><span class="grouping">)</span><span class="punctuation">,</span>
                             <span class="identifier">shape</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">indptr</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">len</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">p</span><span class="invalid">p</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">g</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">inverse_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">yt</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Transform the given indicator matrix into label sets.

        Parameters
        ----------
        yt : {ndarray, sparse matrix} of shape (n_samples, n_classes)
            A matrix containing only 1s ands 0s.

        Returns
        -------
        y : list of tuples
            The set of labels for each sample such that `y[i]` consists of
            `classes_[j]` for each `yt[i, j] == 1`.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">yt</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="relational-operator">!=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'Expected indicator for {0} classes, but got {1}'</span>
                             <span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">yt</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">yt</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">yt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">yt</span><span class="punctuation">.</span><span class="identifier">tocsr</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">yt</span><span class="punctuation">.</span><span class="identifier">data</span><span class="grouping">)</span> <span class="relational-operator">!=</span> <span class="int-literal">0</span> <span class="logical-operator">and</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">setdiff1d</span><span class="grouping">(</span><span class="identifier">yt</span><span class="punctuation">.</span><span class="identifier">data</span><span class="punctuation">,</span> <span class="grouping">[</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'Expected only 0s and 1s in label indicator.'</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="grouping">[</span><span class="identifier">tuple</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="punctuation">.</span><span class="identifier">take</span><span class="grouping">(</span><span class="identifier">yt</span><span class="punctuation">.</span><span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">start</span><span class="punctuation">:</span><span class="identifier">end</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>
                    <span class="keyword">for</span> <span class="identifier">start</span><span class="punctuation">,</span> <span class="identifier">end</span> <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">yt</span><span class="punctuation">.</span><span class="identifier">indptr</span><span class="grouping">[</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">yt</span><span class="punctuation">.</span><span class="identifier">indptr</span><span class="grouping">[</span><span class="int-literal">1</span><span class="punctuation">:</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">]</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">unexpected</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">setdiff1d</span><span class="grouping">(</span><span class="identifier">yt</span><span class="punctuation">,</span> <span class="grouping">[</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">unexpected</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'Expected only 0s and 1s in label indicator. '</span>
                                 <span class="string-literal">'Also got {0}'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">unexpected</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="grouping">[</span><span class="identifier">tuple</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="punctuation">.</span><span class="identifier">compress</span><span class="grouping">(</span><span class="identifier">indicators</span><span class="grouping">)</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">indicators</span>
                    <span class="relational-operator">in</span> <span class="identifier">yt</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'X_types': ['2dlabels'</span><span class="grouping">]</span><span class="grouping">}</span>

    </pre>
  </body>
</html>