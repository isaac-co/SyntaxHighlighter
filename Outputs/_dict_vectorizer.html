<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment"># Authors: Lars Buitinck</span>
<span class="comment">#          Dan Blanchard &lt;dblanchard@ets.org&gt;</span>
<span class="comment"># License: BSD 3 clause</span>

<span class="keyword">from</span> <span class="identifier">array</span> <span class="keyword">import</span> <span class="identifier">array</span>
<span class="keyword">from</span> <span class="identifier">collections</span><span class="punctuation">.</span><span class="identifier">abc</span> <span class="keyword">import</span> <span class="identifier">Mapping</span><span class="punctuation">,</span> <span class="identifier">Iterable</span>
<span class="keyword">from</span> <span class="identifier">operator</span> <span class="keyword">import</span> <span class="identifier">itemgetter</span>
<span class="keyword">from</span> <span class="identifier">numbers</span> <span class="keyword">import</span> <span class="identifier">Number</span>

<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">import</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">sparse</span> <span class="keyword">as</span> <span class="identifier">sp</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">BaseEstimator</span><span class="punctuation">,</span> <span class="identifier">TransformerMixin</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">check_array</span><span class="punctuation">,</span> <span class="identifier">tosequence</span>


<span class="keyword">def</span> <span class="identifier">_tosequence</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Turn X into a sequence or ndarray, avoiding a copy if possible."""</span>
    <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">Mapping</span><span class="grouping">)</span><span class="punctuation">:</span>  <span class="comment"># single sample</span>
        <span class="keyword">return</span> <span class="grouping">[</span><span class="identifier">X</span><span class="grouping">]</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">tosequence</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">DictVectorizer</span><span class="grouping">(</span><span class="identifier">TransformerMixin</span><span class="punctuation">,</span> <span class="identifier">BaseEstimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Transforms lists of feature-value mappings to vectors.

    This transformer turns lists of mappings (dict-like objects) of feature
    names to feature values into Numpy arrays or scipy.sparse matrices for use
    with scikit-learn estimators.

    When feature values are strings, this transformer will do a binary one-hot
    (aka one-of-K) coding: one boolean-valued feature is constructed for each
    of the possible string values that the feature can take on. For instance,
    a feature "f" that can take on the values "ham" and "spam" will become two
    features in the output, one signifying "f=ham", the other "f=spam".

    If a feature value is a sequence or set of strings, this transformer
    will iterate over the values and will count the occurrences of each string
    value.

    However, note that this transformer will only do a binary one-hot encoding
    when feature values are of type string. If categorical features are
    represented as numeric values such as int or iterables of strings, the
    DictVectorizer can be followed by
    :class:`~sklearn.preprocessing.OneHotEncoder` to complete
    binary one-hot encoding.

    Features that do not occur in a sample (mapping) will have a zero value
    in the resulting array/matrix.

    Read more in the :ref:`User Guide &lt;dict_feature_extraction&gt;`.

    Parameters
    ----------
    dtype : dtype, default=np.float64
        The type of feature values. Passed to Numpy array/scipy.sparse matrix
        constructors as the dtype argument.
    separator : str, default="="
        Separator string used when constructing new features for one-hot
        coding.
    sparse : bool, default=True
        Whether transform should produce scipy.sparse matrices.
    sort : bool, default=True
        Whether ``feature_names_`` and ``vocabulary_`` should be
        sorted when fitting.

    Attributes
    ----------
    vocabulary_ : dict
        A dictionary mapping feature names to feature indices.

    feature_names_ : list
        A list of length n_features containing the feature names (e.g., "f=ham"
        and "f=spam").

    Examples
    --------
    &gt;&gt;&gt; from sklearn.feature_extraction import DictVectorizer
    &gt;&gt;&gt; v = DictVectorizer(sparse=False)
    &gt;&gt;&gt; D = [{'foo': 1, 'bar': 2}, {'foo': 3, 'baz': 1}]
    &gt;&gt;&gt; X = v.fit_transform(D)
    &gt;&gt;&gt; X
    array([[2., 0., 1.],
           [0., 1., 3.]])
    &gt;&gt;&gt; v.inverse_transform(X) == [{'bar': 2.0, 'foo': 1.0},
    ...                            {'baz': 1.0, 'foo': 3.0}]
    True
    &gt;&gt;&gt; v.transform({'foo': 4, 'unseen_feature': 3})
    array([[0., 0., 4.]])

    See Also
    --------
    FeatureHasher : Performs vectorization using only a hash function.
    sklearn.preprocessing.OrdinalEncoder : Handles nominal/categorical
        features encoded as columns of arbitrary data types.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">separator</span><span class="arithmetic-assignment">=</span><span class="string-literal">"="</span><span class="punctuation">,</span> <span class="identifier">sparse</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">sort</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dtype</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dtype</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">separator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">separator</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sparse</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sparse</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sort</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sort</span>

    <span class="keyword">def</span> <span class="identifier">_add_iterable_element</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">f</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">feature_names</span><span class="punctuation">,</span> <span class="identifier">vocab</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span>
                              <span class="identifier">fitting</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">transforming</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                              <span class="identifier">indices</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">values</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Add feature names for iterable of strings"""</span>
        <span class="keyword">for</span> <span class="identifier">vv</span> <span class="relational-operator">in</span> <span class="identifier">v</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">vv</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">feature_name</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"%s%s%s"</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">f</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">separator</span><span class="punctuation">,</span> <span class="identifier">vv</span><span class="grouping">)</span>
                <span class="identifier">vv</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">'Unsupported type {type(vv)} in iterable '</span>
                                <span class="string-literal">'value. Only iterables of string are '</span>
                                <span class="string-literal">'supported.'</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">fitting</span> <span class="logical-operator">and</span> <span class="identifier">feature_name</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="identifier">vocab</span><span class="punctuation">:</span>
                <span class="identifier">vocab</span><span class="grouping">[</span><span class="identifier">feature_name</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">feature_names</span><span class="grouping">)</span>
                <span class="identifier">feature_names</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">feature_name</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="identifier">transforming</span> <span class="logical-operator">and</span> <span class="identifier">feature_name</span> <span class="relational-operator">in</span> <span class="identifier">vocab</span><span class="punctuation">:</span>
                <span class="identifier">indices</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">vocab</span><span class="grouping">[</span><span class="identifier">feature_name</span><span class="grouping">]</span><span class="grouping">)</span>
                <span class="identifier">values</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">(</span><span class="identifier">vv</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">return</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Learn a list of feature name -&gt; indices mappings.

        Parameters
        ----------
        X : Mapping or iterable over Mappings
            Dict(s) or Mapping(s) from feature names (arbitrary Python
            objects) to feature values (strings or convertible to dtype).

            .. versionchanged:: 0.24
               Accepts multiple string values for one categorical feature.

        y : (ignored)

        Returns
        -------
        self
        """</span>
        <span class="identifier">feature_names</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
        <span class="identifier">vocab</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="grouping">}</span>

        <span class="keyword">for</span> <span class="identifier">x</span> <span class="relational-operator">in</span> <span class="identifier">X</span><span class="punctuation">:</span>
            <span class="keyword">for</span> <span class="identifier">f</span><span class="punctuation">,</span> <span class="identifier">v</span> <span class="relational-operator">in</span> <span class="identifier">x</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">feature_name</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"%s%s%s"</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">f</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">separator</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="grouping">)</span>
                    <span class="identifier">v</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>
                <span class="keyword">elif</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">Number</span><span class="grouping">)</span> <span class="logical-operator">or</span> <span class="grouping">(</span><span class="identifier">v</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">feature_name</span> <span class="arithmetic-assignment">=</span> <span class="identifier">f</span>
                <span class="keyword">elif</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">Mapping</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">'Unsupported value type {type(v)} '</span>
                                    <span class="identifier">f</span><span class="string-literal">'for {f}: {v}.\n'</span>
                                    <span class="string-literal">'Mapping objects are not supported.'</span><span class="grouping">)</span>
                <span class="keyword">elif</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">Iterable</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">feature_name</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_add_iterable_element</span><span class="grouping">(</span><span class="identifier">f</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">feature_names</span><span class="punctuation">,</span> <span class="identifier">vocab</span><span class="grouping">)</span>

                <span class="keyword">if</span> <span class="identifier">feature_name</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                    <span class="keyword">if</span> <span class="identifier">feature_name</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="identifier">vocab</span><span class="punctuation">:</span>
                        <span class="identifier">vocab</span><span class="grouping">[</span><span class="identifier">feature_name</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">feature_names</span><span class="grouping">)</span>
                        <span class="identifier">feature_names</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">feature_name</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sort</span><span class="punctuation">:</span>
            <span class="identifier">feature_names</span><span class="punctuation">.</span><span class="identifier">sort</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="identifier">vocab</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="identifier">f</span><span class="punctuation">:</span> <span class="identifier">i</span> <span class="keyword">for</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">f</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">feature_names</span><span class="grouping">)</span><span class="grouping">}</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">feature_names_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">feature_names</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">vocabulary_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">vocab</span>

        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">fitting</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># Sanity check: Python's array has no way of explicitly requesting the</span>
        <span class="comment"># signed 32-bit integers that scipy.sparse needs, so we use the next</span>
        <span class="comment"># best thing: typecode "i" (int). However, if that gives larger or</span>
        <span class="comment"># smaller integers than 32-bit ones, np.frombuffer screws up.</span>
        <span class="keyword">assert</span> <span class="identifier">array</span><span class="grouping">(</span><span class="string-literal">"i"</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">itemsize</span> <span class="relational-operator">==</span> <span class="int-literal">4</span><span class="punctuation">,</span> <span class="grouping">(</span>
            <span class="string-literal">"sizeof(int) != 4 on your platform; please report this at"</span>
            <span class="string-literal">" https://github.com/scikit-learn/scikit-learn/issues and"</span>
            <span class="string-literal">" include the output from platform.platform() in your bug report"</span><span class="grouping">)</span>

        <span class="identifier">dtype</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dtype</span>
        <span class="keyword">if</span> <span class="identifier">fitting</span><span class="punctuation">:</span>
            <span class="identifier">feature_names</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
            <span class="identifier">vocab</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="grouping">}</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">feature_names</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">feature_names_</span>
            <span class="identifier">vocab</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">vocabulary_</span>

        <span class="identifier">transforming</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>

        <span class="comment"># Process everything as sparse regardless of setting</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">X</span><span class="grouping">]</span> <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">Mapping</span><span class="grouping">)</span> <span class="keyword">else</span> <span class="identifier">X</span>

        <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">array</span><span class="grouping">(</span><span class="string-literal">"i"</span><span class="grouping">)</span>
        <span class="identifier">indptr</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="comment"># XXX we could change values to an array.array as well, but it</span>
        <span class="comment"># would require (heuristic) conversion of dtype to typecode...</span>
        <span class="identifier">values</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>

        <span class="comment"># collect all the possible feature names and build sparse matrix at</span>
        <span class="comment"># same time</span>
        <span class="keyword">for</span> <span class="identifier">x</span> <span class="relational-operator">in</span> <span class="identifier">X</span><span class="punctuation">:</span>
            <span class="keyword">for</span> <span class="identifier">f</span><span class="punctuation">,</span> <span class="identifier">v</span> <span class="relational-operator">in</span> <span class="identifier">x</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">feature_name</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"%s%s%s"</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">f</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">separator</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="grouping">)</span>
                    <span class="identifier">v</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>
                <span class="keyword">elif</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">Number</span><span class="grouping">)</span> <span class="logical-operator">or</span> <span class="grouping">(</span><span class="identifier">v</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">feature_name</span> <span class="arithmetic-assignment">=</span> <span class="identifier">f</span>
                <span class="keyword">elif</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">Mapping</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">'Unsupported value Type {type(v)} '</span>
                                    <span class="identifier">f</span><span class="string-literal">'for {f}: {v}.\n'</span>
                                    <span class="string-literal">'Mapping objects are not supported.'</span><span class="grouping">)</span>
                <span class="keyword">elif</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">Iterable</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">feature_name</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_add_iterable_element</span><span class="grouping">(</span><span class="identifier">f</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">feature_names</span><span class="punctuation">,</span> <span class="identifier">vocab</span><span class="punctuation">,</span>
                                               <span class="identifier">fitting</span><span class="arithmetic-assignment">=</span><span class="identifier">fitting</span><span class="punctuation">,</span>
                                               <span class="identifier">transforming</span><span class="arithmetic-assignment">=</span><span class="identifier">transforming</span><span class="punctuation">,</span>
                                               <span class="identifier">indices</span><span class="arithmetic-assignment">=</span><span class="identifier">indices</span><span class="punctuation">,</span> <span class="identifier">values</span><span class="arithmetic-assignment">=</span><span class="identifier">values</span><span class="grouping">)</span>

                <span class="keyword">if</span> <span class="identifier">feature_name</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                    <span class="keyword">if</span> <span class="identifier">fitting</span> <span class="logical-operator">and</span> <span class="identifier">feature_name</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="identifier">vocab</span><span class="punctuation">:</span>
                        <span class="identifier">vocab</span><span class="grouping">[</span><span class="identifier">feature_name</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">feature_names</span><span class="grouping">)</span>
                        <span class="identifier">feature_names</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">feature_name</span><span class="grouping">)</span>

                    <span class="keyword">if</span> <span class="identifier">feature_name</span> <span class="relational-operator">in</span> <span class="identifier">vocab</span><span class="punctuation">:</span>
                        <span class="identifier">indices</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">vocab</span><span class="grouping">[</span><span class="identifier">feature_name</span><span class="grouping">]</span><span class="grouping">)</span>
                        <span class="identifier">values</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">(</span><span class="identifier">v</span><span class="grouping">)</span><span class="grouping">)</span>

            <span class="identifier">indptr</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">indices</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">indptr</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Sample sequence X is empty."</span><span class="grouping">)</span>

        <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">r</span><span class="invalid">o</span><span class="invalid">m</span><span class="invalid">b</span><span class="invalid">u</span><span class="invalid">f</span><span class="invalid">f</span><span class="invalid">e</span><span class="invalid">r</span><span class="grouping">(</span><span class="identifier">indices</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">intc</span><span class="grouping">)</span>
        <span class="identifier">shape</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">indptr</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">vocab</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">result_matrix</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">csr_matrix</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">values</span><span class="punctuation">,</span> <span class="identifier">indices</span><span class="punctuation">,</span> <span class="identifier">indptr</span><span class="grouping">)</span><span class="punctuation">,</span>
                                      <span class="identifier">shape</span><span class="arithmetic-assignment">=</span><span class="identifier">shape</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="comment"># Sort everything if asked</span>
        <span class="keyword">if</span> <span class="identifier">fitting</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sort</span><span class="punctuation">:</span>
            <span class="identifier">feature_names</span><span class="punctuation">.</span><span class="identifier">sort</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="identifier">map_index</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">feature_names</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">int32</span><span class="grouping">)</span>
            <span class="keyword">for</span> <span class="identifier">new_val</span><span class="punctuation">,</span> <span class="identifier">f</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">feature_names</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">map_index</span><span class="grouping">[</span><span class="identifier">new_val</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">vocab</span><span class="grouping">[</span><span class="identifier">f</span><span class="grouping">]</span>
                <span class="identifier">vocab</span><span class="grouping">[</span><span class="identifier">f</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_val</span>
            <span class="identifier">result_matrix</span> <span class="arithmetic-assignment">=</span> <span class="identifier">result_matrix</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">map_index</span><span class="grouping">]</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sparse</span><span class="punctuation">:</span>
            <span class="identifier">result_matrix</span><span class="punctuation">.</span><span class="identifier">sort_indices</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">result_matrix</span> <span class="arithmetic-assignment">=</span> <span class="identifier">result_matrix</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">fitting</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">feature_names_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">feature_names</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">vocabulary_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">vocab</span>

        <span class="keyword">return</span> <span class="identifier">result_matrix</span>

    <span class="keyword">def</span> <span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Learn a list of feature name -&gt; indices mappings and transform X.

        Like fit(X) followed by transform(X), but does not require
        materializing X in memory.

        Parameters
        ----------
        X : Mapping or iterable over Mappings
            Dict(s) or Mapping(s) from feature names (arbitrary Python
            objects) to feature values (strings or convertible to dtype).

            .. versionchanged:: 0.24
               Accepts multiple string values for one categorical feature.

        y : (ignored)

        Returns
        -------
        Xa : {array, sparse matrix}
            Feature vectors; always 2-d.
        """</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">fitting</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">inverse_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dict_type</span><span class="arithmetic-assignment">=</span><span class="identifier">dict</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Transform array or sparse matrix X back to feature mappings.

        X must have been produced by this DictVectorizer's transform or
        fit_transform method; it may only have passed through transformers
        that preserve the number of features and their order.

        In the case of one-hot/one-of-K coding, the constructed feature
        names and values are returned rather than the original ones.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            Sample matrix.
        dict_type : type, default=dict
            Constructor for feature mappings. Must conform to the
            collections.Mapping API.

        Returns
        -------
        D : list of dict_type objects of shape (n_samples,)
            Feature mappings for the samples in X.
        """</span>
        <span class="comment"># COO matrix is not subscriptable</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="string-literal">'csr', 'csc'</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

        <span class="identifier">names</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">feature_names_</span>
        <span class="identifier">dicts</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">dict_type</span><span class="grouping">(</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">_</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="grouping">)</span><span class="grouping">]</span>

        <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">for</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">j</span> <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">nonzero</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">dicts</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">[</span><span class="identifier">names</span><span class="grouping">[</span><span class="identifier">j</span><span class="grouping">]</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">j</span><span class="grouping">]</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">for</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">d</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">dicts</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">for</span> <span class="identifier">j</span><span class="punctuation">,</span> <span class="identifier">v</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">[</span><span class="identifier">i</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="keyword">if</span> <span class="identifier">v</span> <span class="relational-operator">!=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
                        <span class="identifier">d</span><span class="grouping">[</span><span class="identifier">names</span><span class="grouping">[</span><span class="identifier">j</span><span class="grouping">]</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">j</span><span class="grouping">]</span>

        <span class="keyword">return</span> <span class="identifier">dicts</span>

    <span class="keyword">def</span> <span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Transform feature-&gt;value dicts to array or sparse matrix.

        Named features not encountered during fit or fit_transform will be
        silently ignored.

        Parameters
        ----------
        X : Mapping or iterable over Mappings of shape (n_samples,)
            Dict(s) or Mapping(s) from feature names (arbitrary Python
            objects) to feature values (strings or convertible to dtype).

        Returns
        -------
        Xa : {array, sparse matrix}
            Feature vectors; always 2-d.
        """</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">fitting</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">get_feature_names</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Returns a list of feature names, ordered by their indices.

        If one-of-K coding is applied to categorical features, this will
        include the constructed feature names but not the original ones.
        """</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">feature_names_</span>

    <span class="keyword">def</span> <span class="identifier">restrict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">support</span><span class="punctuation">,</span> <span class="identifier">indices</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Restrict the features to those in support using feature selection.

        This function modifies the estimator in-place.

        Parameters
        ----------
        support : array-like
            Boolean mask or list of indices (as returned by the get_support
            member of feature selectors).
        indices : bool, default=False
            Whether support is a list of indices.

        Returns
        -------
        self

        Examples
        --------
        &gt;&gt;&gt; from sklearn.feature_extraction import DictVectorizer
        &gt;&gt;&gt; from sklearn.feature_selection import SelectKBest, chi2
        &gt;&gt;&gt; v = DictVectorizer()
        &gt;&gt;&gt; D = [{'foo': 1, 'bar': 2}, {'foo': 3, 'baz': 1}]
        &gt;&gt;&gt; X = v.fit_transform(D)
        &gt;&gt;&gt; support = SelectKBest(chi2, k=2).fit(X, [0, 1])
        &gt;&gt;&gt; v.get_feature_names()
        ['bar', 'baz', 'foo']
        &gt;&gt;&gt; v.restrict(support.get_support())
        DictVectorizer()
        &gt;&gt;&gt; v.get_feature_names()
        ['bar', 'foo']
        """</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">indices</span><span class="punctuation">:</span>
            <span class="identifier">support</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">where</span><span class="grouping">(</span><span class="identifier">support</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

        <span class="identifier">names</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">feature_names_</span>
        <span class="identifier">new_vocab</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="grouping">}</span>
        <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">support</span><span class="punctuation">:</span>
            <span class="identifier">new_vocab</span><span class="grouping">[</span><span class="identifier">names</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">new_vocab</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">vocabulary_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">new_vocab</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">feature_names_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">f</span> <span class="keyword">for</span> <span class="identifier">f</span><span class="punctuation">,</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">sorted</span><span class="grouping">(</span><span class="identifier">new_vocab</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">,</span>
                                                    <span class="identifier">key</span><span class="arithmetic-assignment">=</span><span class="identifier">itemgetter</span><span class="grouping">(</span><span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">]</span>

        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'X_types'</span><span class="punctuation">:</span> <span class="grouping">[</span><span class="string-literal">"dict"</span><span class="grouping">]</span><span class="grouping">}</span>

    </pre>
  </body>
</html>