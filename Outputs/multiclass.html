<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""
Multiclass classification strategies
====================================

This module implements multiclass learning algorithms:
    - one-vs-the-rest / one-vs-all
    - one-vs-one
    - error correcting output codes

The estimators provided in this module are meta-estimators: they require a base
estimator to be provided in their constructor. For example, it is possible to
use these estimators to turn a binary classifier or a regressor into a
multiclass classifier. It is also possible to use these estimators with
multiclass estimators in the hope that their accuracy or runtime performance
improves.

All classifiers in scikit-learn implement multiclass classification; you
only need to use this module if you want to experiment with custom multiclass
strategies.

The one-vs-the-rest meta-classifier also implements a `predict_proba` method,
so long as such a method is implemented by the base classifier. This method
returns probabilities of class membership in both the single label and
multilabel case.  Note that in the multilabel case, probabilities are the
marginal probability that a given sample falls in the given class. As such, in
the multilabel case the sum of these probabilities over all possible labels
for a given sample *will not* sum to unity, as they do in the single label
case.
"""</span>

<span class="comment"># Author: Mathieu Blondel &lt;mathieu@mblondel.org&gt;</span>
<span class="comment"># Author: Hamzeh Alsalhi &lt;93hamsal@gmail.com&gt;</span>
<span class="comment">#</span>
<span class="comment"># License: BSD 3 clause</span>

<span class="keyword">import</span> <span class="identifier">array</span>
<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">import</span> <span class="identifier">warnings</span>
<span class="keyword">import</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">sparse</span> <span class="keyword">as</span> <span class="identifier">sp</span>
<span class="keyword">import</span> <span class="identifier">itertools</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">BaseEstimator</span><span class="punctuation">,</span> <span class="invalid">C</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">M</span><span class="invalid">i</span><span class="invalid">x</span><span class="invalid">i</span><span class="invalid">n</span><span class="punctuation">,</span> <span class="identifier">clone</span><span class="punctuation">,</span> <span class="identifier">is_classifier</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">MultiOutputMixin</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">MetaEstimatorMixin</span><span class="punctuation">,</span> <span class="identifier">is_regressor</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">_is_pairwise</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">preprocessing</span> <span class="keyword">import</span> <span class="identifier">LabelBinarizer</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">metrics</span><span class="punctuation">.</span><span class="identifier">pairwise</span> <span class="keyword">import</span> <span class="identifier">euclidean_distances</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">check_random_state</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">deprecation</span> <span class="keyword">import</span> <span class="identifier">deprecated</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">_tags</span> <span class="keyword">import</span> <span class="identifier">_safe_tags</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">_num_samples</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_is_fitted</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_X_y</span><span class="punctuation">,</span> <span class="identifier">check_array</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">multiclass</span> <span class="keyword">import</span> <span class="grouping">(</span><span class="identifier">_check_partial_fit_first_call</span><span class="punctuation">,</span>
                               <span class="identifier">check_classification_targets</span><span class="punctuation">,</span>
                               <span class="identifier">_ovr_decision_function</span><span class="grouping">)</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">metaestimators</span> <span class="keyword">import</span> <span class="identifier">_safe_split</span><span class="punctuation">,</span> <span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">fixes</span> <span class="keyword">import</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="invalid">e</span><span class="invalid">x</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="invalid">i</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">s</span> <span class="keyword">import</span> <span class="identifier">NotFittedError</span>

<span class="keyword">from</span> <span class="identifier">joblib</span> <span class="keyword">import</span> <span class="identifier">Parallel</span>

<span class="identifier">__all__</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span>
    <span class="string-literal">"OneVsRestClassifier"</span><span class="punctuation">,</span>
    <span class="string-literal">"OneVsOneClassifier"</span><span class="punctuation">,</span>
    <span class="string-literal">"OutputCodeClassifier"</span><span class="punctuation">,</span>
<span class="grouping">]</span>


<span class="keyword">def</span> <span class="identifier">_fit_binary</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Fit a single binary estimator."""</span>
    <span class="identifier">unique_y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">unique_y</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">y</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">==</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="identifier">c</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">c</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">"Label %s is present in all training examples."</span> <span class="arithmetic-operator">%</span>
                          <span class="identifier">str</span><span class="grouping">(</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">[</span><span class="identifier">c</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_ConstantPredictor</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">unique_y</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="grouping">)</span>
        <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">estimator</span>


<span class="keyword">def</span> <span class="identifier">_partial_fit_binary</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Partially fit a single binary estimator."""</span>
    <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">partial_fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">estimator</span>


<span class="keyword">def</span> <span class="identifier">_predict_binary</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Make predictions using a single binary estimator."""</span>
    <span class="keyword">if</span> <span class="identifier">is_regressor</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="keyword">try</span><span class="punctuation">:</span>
        <span class="identifier">score</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">decision_function</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">except</span> <span class="grouping">(</span><span class="identifier">AttributeError</span><span class="punctuation">,</span> <span class="identifier">NotImplementedError</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># probabilities of the positive class</span>
        <span class="identifier">score</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">]</span>
    <span class="keyword">return</span> <span class="identifier">score</span>


<span class="keyword">def</span> <span class="identifier">_check_estimator</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Make sure that an estimator implements the necessary methods."""</span>
    <span class="keyword">if</span> <span class="grouping">(</span><span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="string-literal">"decision_function"</span><span class="grouping">)</span> <span class="logical-operator">and</span>
            <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="string-literal">"predict_proba"</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"The base estimator should implement "</span>
                         <span class="string-literal">"decision_function or predict_proba!"</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">_ConstantPredictor</span><span class="grouping">(</span><span class="identifier">BaseEstimator</span><span class="grouping">)</span><span class="punctuation">:</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">y_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">repeat</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">y_</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">decision_function</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">repeat</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">y_</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">repeat</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">hstack</span><span class="grouping">(</span><span class="grouping">[</span><span class="int-literal">1</span> <span class="arithmetic-operator">-</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">y_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">y_</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">]</span><span class="punctuation">,</span>
                         <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">OneVsRestClassifier</span><span class="grouping">(</span><span class="identifier">MultiOutputMixin</span><span class="punctuation">,</span> <span class="invalid">C</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">M</span><span class="invalid">i</span><span class="invalid">x</span><span class="invalid">i</span><span class="invalid">n</span><span class="punctuation">,</span>
                          <span class="identifier">MetaEstimatorMixin</span><span class="punctuation">,</span> <span class="identifier">BaseEstimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""One-vs-the-rest (OvR) multiclass strategy.

    Also known as one-vs-all, this strategy consists in fitting one classifier
    per class. For each classifier, the class is fitted against all the other
    classes. In addition to its computational efficiency (only `n_classes`
    classifiers are needed), one advantage of this approach is its
    interpretability. Since each class is represented by one and one classifier
    only, it is possible to gain knowledge about the class by inspecting its
    corresponding classifier. This is the most commonly used strategy for
    multiclass classification and is a fair default choice.

    OneVsRestClassifier can also be used for multilabel classification. To use
    this feature, provide an indicator matrix for the target `y` when calling
    `.fit`. In other words, the target labels should be formatted as a 2D
    binary (0/1) matrix, where [i, j] == 1 indicates the presence of label j
    in sample i. This estimator uses the binary relevance method to perform
    multilabel classification, which involves training one binary classifier
    independently for each label.

    Read more in the :ref:`User Guide &lt;ovr_classification&gt;`.

    Parameters
    ----------
    estimator : estimator object
        An estimator object implementing :term:`fit` and one of
        :term:`decision_function` or :term:`predict_proba`.

    n_jobs : int, default=None
        The number of jobs to use for the computation: the `n_classes`
        one-vs-rest problems are computed in parallel.

        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

        .. versionchanged:: v0.20
           `n_jobs` default changed from 1 to None

    Attributes
    ----------
    estimators_ : list of `n_classes` estimators
        Estimators used for predictions.

    coef_ : ndarray of shape (1, n_features) or (n_classes, n_features)
        Coefficient of the features in the decision function. This attribute
        exists only if the ``estimators_`` defines ``coef_``.

        .. deprecated:: 0.24
            This attribute is deprecated in 0.24 and will
            be removed in 1.1 (renaming of 0.26). If you use this attribute
            in :class:`~sklearn.feature_selection.RFE` or
            :class:`~sklearn.feature_selection.SelectFromModel`,
            you may pass a callable to the `importance_getter`
            parameter that extracts feature the importances
            from `estimators_`.

    intercept_ : ndarray of shape (1, 1) or (n_classes, 1)
        If ``y`` is binary, the shape is ``(1, 1)`` else ``(n_classes, 1)``
        This attribute exists only if the ``estimators_`` defines
        ``intercept_``.

        .. deprecated:: 0.24
            This attribute is deprecated in 0.24 and will
            be removed in 1.1 (renaming of 0.26). If you use this attribute
            in :class:`~sklearn.feature_selection.RFE` or
            :class:`~sklearn.feature_selection.SelectFromModel`,
            you may pass a callable to the `importance_getter`
            parameter that extracts feature the importances
            from `estimators_`.

    classes_ : array, shape = [`n_classes`]
        Class labels.

    n_classes_ : int
        Number of classes.

    label_binarizer_ : LabelBinarizer object
        Object used to transform multiclass labels to binary labels and
        vice-versa.

    multilabel_ : boolean
        Whether a OneVsRestClassifier is a multilabel classifier.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.multiclass import OneVsRestClassifier
    &gt;&gt;&gt; from sklearn.svm import SVC
    &gt;&gt;&gt; X = np.array([
    ...     [10, 10],
    ...     [8, 10],
    ...     [-5, 5.5],
    ...     [-5.4, 5.5],
    ...     [-20, -20],
    ...     [-15, -20]
    ... ])
    &gt;&gt;&gt; y = np.array([0, 0, 1, 1, 2, 2])
    &gt;&gt;&gt; clf = OneVsRestClassifier(SVC()).fit(X, y)
    &gt;&gt;&gt; clf.predict([[-19, -20], [9, 9], [-5, 5]])
    array([2, 0, 1])

    See Also
    --------
    sklearn.multioutput.MultiOutputClassifier : Alternate way of extending an
        estimator for multilabel classification.
    sklearn.preprocessing.MultiLabelBinarizer : Transform iterable of iterables
        to binary indicator matrix.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">estimator</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimator</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_jobs</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit underlying estimators.

        Parameters
        ----------
        X : (sparse) array-like of shape (n_samples, n_features)
            Data.

        y : (sparse) array-like of shape (n_samples,) or (n_samples, n_classes)
            Multi-class targets. An indicator matrix turns on multilabel
            classification.

        Returns
        -------
        self
        """</span>
        <span class="comment"># A sparse LabelBinarizer, with sparse_output=True, has been shown to</span>
        <span class="comment"># outperform or match a dense label binarizer in all cases and has also</span>
        <span class="comment"># resulted in less or equal memory consumption in the fit_ovr function</span>
        <span class="comment"># overall.</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">label_binarizer_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">LabelBinarizer</span><span class="grouping">(</span><span class="identifier">sparse_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">label_binarizer_</span><span class="punctuation">.</span><span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Y</span><span class="punctuation">.</span><span class="identifier">tocsc</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">label_binarizer_</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span>
        <span class="identifier">columns</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">col</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">col</span> <span class="relational-operator">in</span> <span class="identifier">Y</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span>
        <span class="comment"># In cases where individual estimators are very fast to train setting</span>
        <span class="comment"># n_jobs &gt; 1 in can results in slower performance due to the overhead</span>
        <span class="comment"># of spawning threads.  See joblib issue #112.</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Parallel</span><span class="grouping">(</span><span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span><span class="grouping">)</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">(</span><span class="identifier">_fit_binary</span><span class="grouping">)</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">column</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span>
                <span class="string-literal">"not %s"</span> <span class="arithmetic-operator">%</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">label_binarizer_</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">label_binarizer_</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="keyword">for</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">column</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">columns</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="string-literal">'estimator'</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">partial_fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Partially fit underlying estimators

        Should be used when memory is inefficient to train all data.
        Chunks of data can be passed in several iteration.

        Parameters
        ----------
        X : (sparse) array-like of shape (n_samples, n_features)
            Data.

        y : (sparse) array-like of shape (n_samples,) or (n_samples, n_classes)
            Multi-class targets. An indicator matrix turns on multilabel
            classification.

        classes : array, shape (n_classes, )
            Classes across all calls to partial_fit.
            Can be obtained via `np.unique(y_all)`, where y_all is the
            target vector of the entire dataset.
            This argument is only required in the first call of partial_fit
            and can be omitted in the subsequent calls.

        Returns
        -------
        self
        """</span>
        <span class="keyword">if</span> <span class="identifier">_check_partial_fit_first_call</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="string-literal">"partial_fit"</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="grouping">(</span><span class="string-literal">"Base estimator {0}, doesn't have "</span>
                                  <span class="string-literal">"partial_fit method"</span><span class="grouping">)</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">_</span> <span class="relational-operator">in</span> <span class="identifier">range</span>
                                <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_classes_</span><span class="grouping">)</span><span class="grouping">]</span>

            <span class="comment"># A sparse LabelBinarizer, with sparse_output=True, has been</span>
            <span class="comment"># shown to outperform or match a dense label binarizer in all</span>
            <span class="comment"># cases and has also resulted in less or equal memory consumption</span>
            <span class="comment"># in the fit_ovr function overall.</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">label_binarizer_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">LabelBinarizer</span><span class="grouping">(</span><span class="identifier">sparse_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">label_binarizer_</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">setdiff1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="grouping">(</span><span class="string-literal">"Mini-batch contains {0} while classes "</span> <span class="arithmetic-operator">+</span>
                              <span class="string-literal">"must be subset of {1}"</span><span class="grouping">)</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">,</span>
                                                              <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">label_binarizer_</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Y</span><span class="punctuation">.</span><span class="identifier">tocsc</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">columns</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">col</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">col</span> <span class="relational-operator">in</span> <span class="identifier">Y</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Parallel</span><span class="grouping">(</span><span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span><span class="grouping">)</span><span class="grouping">(</span>
            <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">(</span><span class="identifier">_partial_fit_binary</span><span class="grouping">)</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">column</span><span class="grouping">)</span>
            <span class="keyword">for</span> <span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">column</span> <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="punctuation">,</span> <span class="identifier">columns</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Predict multi-class targets using underlying estimators.

        Parameters
        ----------
        X : (sparse) array-like of shape (n_samples, n_features)
            Data.

        Returns
        -------
        y : (sparse) array-like of shape (n_samples,) or (n_samples, n_classes)
            Predicted multi-class targets.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_num_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">label_binarizer_</span><span class="punctuation">.</span><span class="identifier">y_type_</span> <span class="relational-operator">==</span> <span class="string-literal">"multiclass"</span><span class="punctuation">:</span>
            <span class="identifier">maxima</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">float</span><span class="grouping">)</span>
            <span class="identifier">maxima</span><span class="punctuation">.</span><span class="identifier">fill</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">inf</span><span class="grouping">)</span>
            <span class="identifier">argmaxima</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">int</span><span class="grouping">)</span>
            <span class="keyword">for</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">e</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">pred</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_predict_binary</span><span class="grouping">(</span><span class="identifier">e</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span>
                <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">maximum</span><span class="grouping">(</span><span class="identifier">maxima</span><span class="punctuation">,</span> <span class="identifier">pred</span><span class="punctuation">,</span> <span class="identifier">out</span><span class="arithmetic-assignment">=</span><span class="identifier">maxima</span><span class="grouping">)</span>
                <span class="identifier">argmaxima</span><span class="grouping">[</span><span class="identifier">maxima</span> <span class="relational-operator">==</span> <span class="identifier">pred</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">i</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="identifier">argmaxima</span><span class="grouping">]</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="string-literal">"decision_function"</span><span class="grouping">)</span> <span class="logical-operator">and</span>
                    <span class="identifier">is_classifier</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">thresh</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">thresh</span> <span class="arithmetic-assignment">=</span> <span class="float-literal">.5</span>
            <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">array</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="string-literal">'i'</span><span class="grouping">)</span>
            <span class="identifier">indptr</span> <span class="arithmetic-assignment">=</span> <span class="identifier">array</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="string-literal">'i'</span><span class="punctuation">,</span> <span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="keyword">for</span> <span class="identifier">e</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="punctuation">:</span>
                <span class="identifier">indices</span><span class="punctuation">.</span><span class="identifier">extend</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">where</span><span class="grouping">(</span><span class="identifier">_predict_binary</span><span class="grouping">(</span><span class="identifier">e</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="identifier">thresh</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>
                <span class="identifier">indptr</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">indices</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ones</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">indices</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">int</span><span class="grouping">)</span>
            <span class="identifier">indicator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">csc_matrix</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">data</span><span class="punctuation">,</span> <span class="identifier">indices</span><span class="punctuation">,</span> <span class="identifier">indptr</span><span class="grouping">)</span><span class="punctuation">,</span>
                                      <span class="identifier">shape</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">label_binarizer_</span><span class="punctuation">.</span><span class="identifier">inverse_transform</span><span class="grouping">(</span><span class="identifier">indicator</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="grouping">[</span><span class="string-literal">'_first_estimator', 'estimator'</span><span class="grouping">]</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Probability estimates.

        The returned estimates for all classes are ordered by label of classes.

        Note that in the multilabel case, each sample can have any number of
        labels. This returns the marginal probability that the given sample has
        the label in question. For example, it is entirely consistent that two
        labels both have a 90% probability of applying to a given sample.

        In the single label multiclass case, the rows of the returned matrix
        sum to 1.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)

        Returns
        -------
        T : (sparse) array-like of shape (n_samples, n_classes)
            Returns the probability of the sample for each class in the model,
            where classes are ordered as they are in `self.classes_`.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="comment"># Y[i, j] gives the probability that sample i has the label j.</span>
        <span class="comment"># In the multi-label case, these are not disjoint.</span>
        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">e</span><span class="punctuation">.</span><span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="keyword">for</span> <span class="identifier">e</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">T</span>

        <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="comment"># Only one estimator, but we still want to return probabilities</span>
            <span class="comment"># for two classes.</span>
            <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">concatenate</span><span class="grouping">(</span><span class="grouping">(</span><span class="grouping">(</span><span class="int-literal">1</span> <span class="arithmetic-operator">-</span> <span class="identifier">Y</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">Y</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">multilabel_</span><span class="punctuation">:</span>
            <span class="comment"># Then, probabilities should be normalized to 1.</span>
            <span class="identifier">Y</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">Y</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="identifier">Y</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="grouping">[</span><span class="string-literal">'_first_estimator', 'estimator'</span><span class="grouping">]</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">decision_function</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Returns the distance of each sample from the decision boundary for
        each class. This can only be used with estimators which implement the
        decision_function method.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)

        Returns
        -------
        T : array-like of shape (n_samples, n_classes) or (n_samples,) for \
            binary classification.

            .. versionchanged:: 0.19
                output shape changed to ``(n_samples,)`` to conform to
                scikit-learn conventions for binary classification.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">decision_function</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">est</span><span class="punctuation">.</span><span class="identifier">decision_function</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>
                         <span class="keyword">for</span> <span class="identifier">est</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">T</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">multilabel_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Whether this is a multilabel classifier"""</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">label_binarizer_</span><span class="punctuation">.</span><span class="identifier">y_type_</span><span class="punctuation">.</span><span class="identifier">startswith</span><span class="grouping">(</span><span class="string-literal">'multilabel'</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">n_classes_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span>

    <span class="comment"># TODO: Remove coef_ attribute in 1.1</span>
    <span class="comment"># mypy error: Decorated property not supported</span>
    <span class="punctuation">@</span><span class="identifier">deprecated</span><span class="grouping">(</span><span class="string-literal">"Attribute coef_ was deprecated in "</span>  <span class="comment"># type: ignore</span>
                <span class="string-literal">"version 0.24 and will be removed in 1.1 (renaming of 0.26). "</span>
                <span class="string-literal">"If you observe this warning while using RFE "</span>
                <span class="string-literal">"or SelectFromModel, use the importance_getter "</span>
                <span class="string-literal">"parameter instead."</span><span class="grouping">)</span>
    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">coef_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="string-literal">"coef_"</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">AttributeError</span><span class="grouping">(</span>
                <span class="string-literal">"Base estimator doesn't have a coef_ attribute."</span><span class="grouping">)</span>
        <span class="identifier">coefs</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">e</span><span class="punctuation">.</span><span class="identifier">coef_</span> <span class="keyword">for</span> <span class="identifier">e</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">]</span>
        <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">coefs</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">vstack</span><span class="grouping">(</span><span class="identifier">coefs</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">vstack</span><span class="grouping">(</span><span class="identifier">coefs</span><span class="grouping">)</span>

    <span class="comment"># TODO: Remove intercept_ attribute in 1.1</span>
    <span class="comment"># mypy error: Decorated property not supported</span>
    <span class="punctuation">@</span><span class="identifier">deprecated</span><span class="grouping">(</span><span class="string-literal">"Attribute intercept_ was deprecated in "</span>  <span class="comment"># type: ignore</span>
                <span class="string-literal">"version 0.24 and will be removed in 1.1 (renaming of 0.26). "</span>
                <span class="string-literal">"If you observe this warning while using RFE "</span>
                <span class="string-literal">"or SelectFromModel, use the importance_getter "</span>
                <span class="string-literal">"parameter instead."</span><span class="grouping">)</span>
    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">intercept_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="string-literal">"intercept_"</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">AttributeError</span><span class="grouping">(</span>
                <span class="string-literal">"Base estimator doesn't have an intercept_ attribute."</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">e</span><span class="punctuation">.</span><span class="identifier">intercept_</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">e</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">]</span><span class="grouping">)</span>

    <span class="comment"># TODO: Remove in 1.1</span>
    <span class="comment"># mypy error: Decorated property not supported</span>
    <span class="punctuation">@</span><span class="identifier">deprecated</span><span class="grouping">(</span><span class="string-literal">"Attribute _pairwise was deprecated in "</span>  <span class="comment"># type: ignore</span>
                <span class="string-literal">"version 0.24 and will be removed in 1.1 (renaming of 0.26)."</span><span class="grouping">)</span>
    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">_pairwise</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Indicate if wrapped estimator is using a precomputed Gram matrix"""</span>
        <span class="keyword">return</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="string-literal">"_pairwise"</span><span class="punctuation">,</span> <span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Indicate if wrapped estimator is using a precomputed Gram matrix"""</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'pairwise'</span><span class="punctuation">:</span> <span class="identifier">_safe_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">key</span><span class="arithmetic-assignment">=</span><span class="string-literal">"pairwise"</span><span class="grouping">)</span><span class="grouping">}</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">_first_estimator</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">n_features_in_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># For consistency with other estimators we raise a AttributeError so</span>
        <span class="comment"># that hasattr() fails if the OVR estimator isn't fitted.</span>
        <span class="keyword">try</span><span class="punctuation">:</span>
            <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="keyword">except</span> <span class="identifier">NotFittedError</span> <span class="keyword">as</span> <span class="identifier">nfe</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">AttributeError</span><span class="grouping">(</span>
                <span class="string-literal">"{} object has no n_features_in_ attribute."</span>
                <span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__class__</span><span class="punctuation">.</span><span class="identifier">__name__</span><span class="grouping">)</span>
            <span class="grouping">)</span> <span class="keyword">from</span> <span class="identifier">nfe</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">n_features_in_</span>


<span class="keyword">def</span> <span class="identifier">_fit_ovo_binary</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">j</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Fit a single binary estimator (one-vs-one)."""</span>
    <span class="identifier">cond</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">logical_or</span><span class="grouping">(</span><span class="identifier">y</span> <span class="relational-operator">==</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="relational-operator">==</span> <span class="identifier">j</span><span class="grouping">)</span>
    <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="grouping">[</span><span class="identifier">cond</span><span class="grouping">]</span>
    <span class="identifier">y_binary</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="punctuation">,</span> <span class="identifier">int</span><span class="grouping">)</span>
    <span class="identifier">y_binary</span><span class="grouping">[</span><span class="identifier">y</span> <span class="relational-operator">==</span> <span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
    <span class="identifier">y_binary</span><span class="grouping">[</span><span class="identifier">y</span> <span class="relational-operator">==</span> <span class="identifier">j</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>
    <span class="identifier">indcond</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">[</span><span class="identifier">cond</span><span class="grouping">]</span>
    <span class="keyword">return</span> <span class="identifier">_fit_binary</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span>
                       <span class="identifier">_safe_split</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">indices</span><span class="arithmetic-assignment">=</span><span class="identifier">indcond</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span>
                       <span class="identifier">y_binary</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">j</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">indcond</span>


<span class="keyword">def</span> <span class="identifier">_partial_fit_ovo_binary</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">j</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Partially fit a single binary estimator(one-vs-one)."""</span>

    <span class="identifier">cond</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">logical_or</span><span class="grouping">(</span><span class="identifier">y</span> <span class="relational-operator">==</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="relational-operator">==</span> <span class="identifier">j</span><span class="grouping">)</span>
    <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="grouping">[</span><span class="identifier">cond</span><span class="grouping">]</span>
    <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span> <span class="relational-operator">!=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
        <span class="identifier">y_binary</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros_like</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="identifier">y_binary</span><span class="grouping">[</span><span class="identifier">y</span> <span class="relational-operator">==</span> <span class="identifier">j</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>
        <span class="keyword">return</span> <span class="identifier">_partial_fit_binary</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">cond</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">y_binary</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">estimator</span>


<span class="keyword">class</span> <span class="identifier">OneVsOneClassifier</span><span class="grouping">(</span><span class="identifier">MetaEstimatorMixin</span><span class="punctuation">,</span> <span class="invalid">C</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">M</span><span class="invalid">i</span><span class="invalid">x</span><span class="invalid">i</span><span class="invalid">n</span><span class="punctuation">,</span> <span class="identifier">BaseEstimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""One-vs-one multiclass strategy

    This strategy consists in fitting one classifier per class pair.
    At prediction time, the class which received the most votes is selected.
    Since it requires to fit `n_classes * (n_classes - 1) / 2` classifiers,
    this method is usually slower than one-vs-the-rest, due to its
    O(n_classes^2) complexity. However, this method may be advantageous for
    algorithms such as kernel algorithms which don't scale well with
    `n_samples`. This is because each individual learning problem only involves
    a small subset of the data whereas, with one-vs-the-rest, the complete
    dataset is used `n_classes` times.

    Read more in the :ref:`User Guide &lt;ovo_classification&gt;`.

    Parameters
    ----------
    estimator : estimator object
        An estimator object implementing :term:`fit` and one of
        :term:`decision_function` or :term:`predict_proba`.

    n_jobs : int, default=None
        The number of jobs to use for the computation: the `n_classes * (
        n_classes - 1) / 2` OVO problems are computed in parallel.

        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

    Attributes
    ----------
    estimators_ : list of ``n_classes * (n_classes - 1) / 2`` estimators
        Estimators used for predictions.

    classes_ : numpy array of shape [n_classes]
        Array containing labels.

    n_classes_ : int
        Number of classes

    pairwise_indices_ : list, length = ``len(estimators_)``, or ``None``
        Indices of samples used when training the estimators.
        ``None`` when ``estimator``'s `pairwise` tag is False.

        .. deprecated:: 0.24

            The _pairwise attribute is deprecated in 0.24. From 1.1
            (renaming of 0.25) and onward, `pairwise_indices_` will use the
            pairwise estimator tag instead.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.datasets import load_iris
    &gt;&gt;&gt; from sklearn.model_selection import train_test_split
    &gt;&gt;&gt; from sklearn.multiclass import OneVsOneClassifier
    &gt;&gt;&gt; from sklearn.svm import LinearSVC
    &gt;&gt;&gt; X, y = load_iris(return_X_y=True)
    &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(
    ...     X, y, test_size=0.33, shuffle=True, random_state=0)
    &gt;&gt;&gt; clf = OneVsOneClassifier(
    ...     LinearSVC(random_state=0)).fit(X_train, y_train)
    &gt;&gt;&gt; clf.predict(X_test[:10])
    array([2, 1, 0, 2, 0, 2, 0, 1, 1, 1])
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">estimator</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimator</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_jobs</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit underlying estimators.

        Parameters
        ----------
        X : (sparse) array-like of shape (n_samples, n_features)
            Data.

        y : array-like of shape (n_samples,)
            Multi-class targets.

        Returns
        -------
        self
        """</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="string-literal">'csr', 'csc'</span><span class="grouping">]</span><span class="punctuation">,</span>
                                   <span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">a</span><span class="invalid">l</span><span class="invalid">l</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">check_classification_targets</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"OneVsOneClassifier can not be fit when only one"</span>
                             <span class="string-literal">" class is present."</span><span class="grouping">)</span>
        <span class="identifier">n_classes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">estimators_indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">list</span><span class="grouping">(</span><span class="identifier">zip</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="grouping">(</span><span class="identifier">Parallel</span><span class="grouping">(</span><span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span><span class="grouping">)</span><span class="grouping">(</span>
            <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">(</span><span class="identifier">_fit_ovo_binary</span><span class="grouping">)</span>
            <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="identifier">j</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_classes</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">j</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">n_classes</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimators_indices</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

        <span class="identifier">pairwise</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_is_pairwise</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">pairwise_indices_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span>
            <span class="identifier">estimators_indices</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="keyword">if</span> <span class="identifier">pairwise</span> <span class="keyword">else</span> <span class="none-literal">None</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="string-literal">'estimator'</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">partial_fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Partially fit underlying estimators

        Should be used when memory is inefficient to train all data. Chunks
        of data can be passed in several iteration, where the first call
        should have an array of all target variables.


        Parameters
        ----------
        X : (sparse) array-like of shape (n_samples, n_features)
            Data.

        y : array-like of shape (n_samples,)
            Multi-class targets.

        classes : array, shape (n_classes, )
            Classes across all calls to partial_fit.
            Can be obtained via `np.unique(y_all)`, where y_all is the
            target vector of the entire dataset.
            This argument is only required in the first call of partial_fit
            and can be omitted in the subsequent calls.

        Returns
        -------
        self
        """</span>
        <span class="keyword">if</span> <span class="identifier">_check_partial_fit_first_call</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">_</span> <span class="relational-operator">in</span>
                                <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_classes_</span> <span class="arithmetic-operator">*</span>
                                      <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_classes_</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">)</span> <span class="arithmetic-operator">//</span> <span class="int-literal">2</span><span class="grouping">)</span><span class="grouping">]</span>

        <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">setdiff1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Mini-batch contains {0} while it "</span>
                             <span class="string-literal">"must be subset of {1}"</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">,</span>
                                                            <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_X_y</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="string-literal">'csr', 'csc'</span><span class="grouping">]</span><span class="punctuation">,</span>
                         <span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">a</span><span class="invalid">l</span><span class="invalid">l</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">check_classification_targets</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="identifier">combinations</span> <span class="arithmetic-assignment">=</span> <span class="identifier">itertools</span><span class="punctuation">.</span><span class="identifier">combinations</span><span class="grouping">(</span><span class="identifier">range</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_classes_</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="int-literal">2</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Parallel</span><span class="grouping">(</span>
            <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span><span class="grouping">)</span><span class="grouping">(</span>
                <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">(</span><span class="identifier">_partial_fit_ovo_binary</span><span class="grouping">)</span><span class="grouping">(</span>
                    <span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="identifier">j</span><span class="grouping">]</span><span class="grouping">)</span>
                <span class="keyword">for</span> <span class="identifier">estimator</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">j</span><span class="grouping">)</span> <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="punctuation">,</span>
                                             <span class="grouping">(</span><span class="identifier">combinations</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">pairwise_indices_</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>

        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Estimate the best class label for each sample in X.

        This is implemented as ``argmax(decision_function(X), axis=1)`` which
        will return the label of the class with most votes by estimators
        predicting the outcome of a decision for each possible class pair.

        Parameters
        ----------
        X : (sparse) array-like of shape (n_samples, n_features)
            Data.

        Returns
        -------
        y : numpy array of shape [n_samples]
            Predicted multi-class targets.
        """</span>
        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">decision_function</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_classes_</span> <span class="relational-operator">==</span> <span class="int-literal">2</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="grouping">(</span><span class="identifier">Y</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">int</span><span class="grouping">)</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="identifier">Y</span><span class="punctuation">.</span><span class="identifier">argmax</span><span class="grouping">(</span><span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">decision_function</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Decision function for the OneVsOneClassifier.

        The decision values for the samples are computed by adding the
        normalized sum of pair-wise classification confidence levels to the
        votes in order to disambiguate between the decision values when the
        votes for all the classes are equal leading to a tie.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)

        Returns
        -------
        Y : array-like of shape (n_samples, n_classes) or (n_samples,) for \
            binary classification.

            .. versionchanged:: 0.19
                output shape changed to ``(n_samples,)`` to conform to
                scikit-learn conventions for binary classification.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">pairwise_indices_</span>
        <span class="keyword">if</span> <span class="identifier">indices</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">Xs</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">X</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">Xs</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">X</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">idx</span><span class="grouping">]</span> <span class="keyword">for</span> <span class="identifier">idx</span> <span class="relational-operator">in</span> <span class="identifier">indices</span><span class="grouping">]</span>

        <span class="identifier">predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">vstack</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">est</span><span class="punctuation">.</span><span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">Xi</span><span class="grouping">)</span>
                                 <span class="keyword">for</span> <span class="identifier">est</span><span class="punctuation">,</span> <span class="identifier">Xi</span> <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="punctuation">,</span> <span class="identifier">Xs</span><span class="grouping">)</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">T</span>
        <span class="identifier">confidences</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">vstack</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">_predict_binary</span><span class="grouping">(</span><span class="identifier">est</span><span class="punctuation">,</span> <span class="identifier">Xi</span><span class="grouping">)</span>
                                 <span class="keyword">for</span> <span class="identifier">est</span><span class="punctuation">,</span> <span class="identifier">Xi</span> <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="punctuation">,</span> <span class="identifier">Xs</span><span class="grouping">)</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">T</span>
        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_ovr_decision_function</span><span class="grouping">(</span><span class="identifier">predictions</span><span class="punctuation">,</span>
                                   <span class="identifier">confidences</span><span class="punctuation">,</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_classes_</span> <span class="relational-operator">==</span> <span class="int-literal">2</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">Y</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="identifier">Y</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">n_classes_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span>

    <span class="comment"># TODO: Remove in 1.1</span>
    <span class="comment"># mypy error: Decorated property not supported</span>
    <span class="punctuation">@</span><span class="identifier">deprecated</span><span class="grouping">(</span><span class="string-literal">"Attribute _pairwise was deprecated in "</span>  <span class="comment"># type: ignore</span>
                <span class="string-literal">"version 0.24 and will be removed in 1.1 (renaming of 0.26)."</span><span class="grouping">)</span>
    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">_pairwise</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Indicate if wrapped estimator is using a precomputed Gram matrix"""</span>
        <span class="keyword">return</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="string-literal">"_pairwise"</span><span class="punctuation">,</span> <span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Indicate if wrapped estimator is using a precomputed Gram matrix"""</span>
        <span class="keyword">return</span> <span class="grouping">{</span>
            <span class="string-literal">'pairwise'</span><span class="punctuation">:</span> <span class="identifier">_safe_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">key</span><span class="arithmetic-assignment">=</span><span class="string-literal">"pairwise"</span><span class="grouping">)</span>
        <span class="grouping">}</span>


<span class="keyword">class</span> <span class="identifier">OutputCodeClassifier</span><span class="grouping">(</span><span class="identifier">MetaEstimatorMixin</span><span class="punctuation">,</span> <span class="invalid">C</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">M</span><span class="invalid">i</span><span class="invalid">x</span><span class="invalid">i</span><span class="invalid">n</span><span class="punctuation">,</span> <span class="identifier">BaseEstimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""(Error-Correcting) Output-Code multiclass strategy

    Output-code based strategies consist in representing each class with a
    binary code (an array of 0s and 1s). At fitting time, one binary
    classifier per bit in the code book is fitted.  At prediction time, the
    classifiers are used to project new points in the class space and the class
    closest to the points is chosen. The main advantage of these strategies is
    that the number of classifiers used can be controlled by the user, either
    for compressing the model (0 &lt; code_size &lt; 1) or for making the model more
    robust to errors (code_size &gt; 1). See the documentation for more details.

    Read more in the :ref:`User Guide &lt;ecoc&gt;`.

    Parameters
    ----------
    estimator : estimator object
        An estimator object implementing :term:`fit` and one of
        :term:`decision_function` or :term:`predict_proba`.

    code_size : float
        Percentage of the number of classes to be used to create the code book.
        A number between 0 and 1 will require fewer classifiers than
        one-vs-the-rest. A number greater than 1 will require more classifiers
        than one-vs-the-rest.

    random_state : int, RandomState instance, default=None
        The generator used to initialize the codebook.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    n_jobs : int, default=None
        The number of jobs to use for the computation: the multiclass problems
        are computed in parallel.

        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

    Attributes
    ----------
    estimators_ : list of `int(n_classes * code_size)` estimators
        Estimators used for predictions.

    classes_ : numpy array of shape [n_classes]
        Array containing labels.

    code_book_ : numpy array of shape [n_classes, code_size]
        Binary array containing the code of each class.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.multiclass import OutputCodeClassifier
    &gt;&gt;&gt; from sklearn.ensemble import RandomForestClassifier
    &gt;&gt;&gt; from sklearn.datasets import make_classification
    &gt;&gt;&gt; X, y = make_classification(n_samples=100, n_features=4,
    ...                            n_informative=2, n_redundant=0,
    ...                            random_state=0, shuffle=False)
    &gt;&gt;&gt; clf = OutputCodeClassifier(
    ...     estimator=RandomForestClassifier(random_state=0),
    ...     random_state=0).fit(X, y)
    &gt;&gt;&gt; clf.predict([[0, 0, 0, 0]])
    array([1])

    References
    ----------

    .. [1] "Solving multiclass learning problems via error-correcting output
       codes",
       Dietterich T., Bakiri G.,
       Journal of Artificial Intelligence Research 2,
       1995.

    .. [2] "The error coding method and PICTs",
       James G., Hastie T.,
       Journal of Computational and Graphical statistics 7,
       1998.

    .. [3] "The Elements of Statistical Learning",
       Hastie T., Tibshirani R., Friedman J., page 606 (second-edition)
       2008.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">estimator</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">code_size</span><span class="arithmetic-assignment">=</span><span class="float-literal">1.5</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimator</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">code_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">code_size</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_jobs</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit underlying estimators.

        Parameters
        ----------
        X : (sparse) array-like of shape (n_samples, n_features)
            Data.

        y : numpy array of shape [n_samples]
            Multi-class targets.

        Returns
        -------
        self
        """</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">code_size</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"code_size should be greater than 0, got {0}"</span>
                             <span class="string-literal">""</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">code_size</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">_check_estimator</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="grouping">)</span>
        <span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="identifier">check_classification_targets</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="identifier">n_classes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">code_size_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">int</span><span class="grouping">(</span><span class="identifier">n_classes</span> <span class="arithmetic-operator">*</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">code_size</span><span class="grouping">)</span>

        <span class="comment"># FIXME: there are more elaborate methods than generating the codebook</span>
        <span class="comment"># randomly.</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">code_book_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span><span class="punctuation">.</span><span class="identifier">random_sample</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">n_classes</span><span class="punctuation">,</span> <span class="identifier">code_size_</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">code_book_</span><span class="grouping">[</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">code_book_</span> <span class="relational-operator">&gt;</span> <span class="float-literal">0.5</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>

        <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="string-literal">"decision_function"</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">code_book_</span><span class="grouping">[</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">code_book_</span> <span class="relational-operator">!=</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">code_book_</span><span class="grouping">[</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">code_book_</span> <span class="relational-operator">!=</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>

        <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">x</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="identifier">c</span><span class="punctuation">:</span> <span class="identifier">i</span> <span class="keyword">for</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">c</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">)</span><span class="grouping">}</span>

        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">code_book_</span><span class="grouping">[</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">x</span><span class="grouping">[</span><span class="identifier">y</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">]</span><span class="grouping">]</span>
                      <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">int</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Parallel</span><span class="grouping">(</span><span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span><span class="grouping">)</span><span class="grouping">(</span>
            <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">(</span><span class="identifier">_fit_binary</span><span class="grouping">)</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">Y</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">Y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Predict multi-class targets using underlying estimators.

        Parameters
        ----------
        X : (sparse) array-like of shape (n_samples, n_features)
            Data.

        Returns
        -------
        y : numpy array of shape [n_samples]
            Predicted multi-class targets.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">Y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">_predict_binary</span><span class="grouping">(</span><span class="identifier">e</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">e</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimators_</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">T</span>
        <span class="identifier">pred</span> <span class="arithmetic-assignment">=</span> <span class="identifier">euclidean_distances</span><span class="grouping">(</span><span class="identifier">Y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">code_book_</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">argmin</span><span class="grouping">(</span><span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="identifier">pred</span><span class="grouping">]</span>

    </pre>
  </body>
</html>