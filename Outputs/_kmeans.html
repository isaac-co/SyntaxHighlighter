<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""K-means clustering."""</span>

<span class="comment"># Authors: Gael Varoquaux &lt;gael.varoquaux@normalesup.org&gt;</span>
<span class="comment">#          Thomas Rueckstiess &lt;ruecksti@in.tum.de&gt;</span>
<span class="comment">#          James Bergstra &lt;james.bergstra@umontreal.ca&gt;</span>
<span class="comment">#          Jan Schlueter &lt;scikit-learn@jan-schlueter.de&gt;</span>
<span class="comment">#          Nelle Varoquaux</span>
<span class="comment">#          Peter Prettenhofer &lt;peter.prettenhofer@gmail.com&gt;</span>
<span class="comment">#          Olivier Grisel &lt;olivier.grisel@ensta.org&gt;</span>
<span class="comment">#          Mathieu Blondel &lt;mathieu@mblondel.org&gt;</span>
<span class="comment">#          Robert Layton &lt;robertlayton@gmail.com&gt;</span>
<span class="comment"># License: BSD 3 clause</span>

<span class="keyword">import</span> <span class="identifier">warnings</span>

<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">import</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">sparse</span> <span class="keyword">as</span> <span class="identifier">sp</span>
<span class="keyword">from</span> <span class="identifier">threadpoolctl</span> <span class="keyword">import</span> <span class="identifier">threadpool_limits</span>
<span class="keyword">from</span> <span class="identifier">threadpoolctl</span> <span class="keyword">import</span> <span class="identifier">threadpool_info</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">BaseEstimator</span><span class="punctuation">,</span> <span class="identifier">ClusterMixin</span><span class="punctuation">,</span> <span class="identifier">TransformerMixin</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">metrics</span><span class="punctuation">.</span><span class="identifier">pairwise</span> <span class="keyword">import</span> <span class="identifier">euclidean_distances</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">metrics</span><span class="punctuation">.</span><span class="identifier">pairwise</span> <span class="keyword">import</span> <span class="identifier">_euclidean_distances</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">extmath</span> <span class="keyword">import</span> <span class="identifier">row_norms</span><span class="punctuation">,</span> <span class="identifier">stable_cumsum</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">sparsefuncs_fast</span> <span class="keyword">import</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">g</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">r</span><span class="invalid">o</span><span class="invalid">w</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">s</span><span class="invalid">r</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">sparsefuncs</span> <span class="keyword">import</span> <span class="identifier">mean_variance_axis</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">check_array</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">check_random_state</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">deprecated</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_is_fitted</span><span class="punctuation">,</span> <span class="identifier">_check_sample_weight</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">_openmp_helpers</span> <span class="keyword">import</span> <span class="identifier">_openmp_effective_n_threads</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="invalid">e</span><span class="invalid">x</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="invalid">i</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">s</span> <span class="keyword">import</span> <span class="identifier">ConvergenceWarning</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_k_means_common</span> <span class="keyword">import</span> <span class="identifier">CHUNK_SIZE</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_k_means_common</span> <span class="keyword">import</span> <span class="identifier">_inertia_dense</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_k_means_common</span> <span class="keyword">import</span> <span class="identifier">_inertia_sparse</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_k_means_minibatch</span> <span class="keyword">import</span> <span class="identifier">_minibatch_update_dense</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_k_means_minibatch</span> <span class="keyword">import</span> <span class="identifier">_minibatch_update_sparse</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_k_means_lloyd</span> <span class="keyword">import</span> <span class="identifier">lloyd_iter_chunked_dense</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_k_means_lloyd</span> <span class="keyword">import</span> <span class="identifier">lloyd_iter_chunked_sparse</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_k_means_elkan</span> <span class="keyword">import</span> <span class="identifier">init_bounds_dense</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_k_means_elkan</span> <span class="keyword">import</span> <span class="identifier">init_bounds_sparse</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_k_means_elkan</span> <span class="keyword">import</span> <span class="identifier">elkan_iter_chunked_dense</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_k_means_elkan</span> <span class="keyword">import</span> <span class="identifier">elkan_iter_chunked_sparse</span>


<span class="comment">###############################################################################</span>
<span class="comment"># Initialization heuristic</span>

<span class="keyword">def</span> <span class="identifier">kmeans_plusplus</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                    <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">n_local_trials</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Init n_clusters seeds according to k-means++

    .. versionadded:: 0.24

    Parameters
    ----------
    X : {array-like, sparse matrix} of shape (n_samples, n_features)
        The data to pick seeds from.

    n_clusters : int
        The number of centroids to initialize

    x_squared_norms : array-like of shape (n_samples,), default=None
        Squared Euclidean norm of each data point.

    random_state : int or RandomState instance, default=None
        Determines random number generation for centroid initialization. Pass
        an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    n_local_trials : int, default=None
        The number of seeding trials for each center (except the first),
        of which the one reducing inertia the most is greedily chosen.
        Set to None to make the number of trials depend logarithmically
        on the number of seeds (2+log(k)).

    Returns
    -------
    centers : ndarray of shape (n_clusters, n_features)
        The inital centers for k-means.

    indices : ndarray of shape (n_clusters,)
        The index location of the chosen centers in the data array X. For a
        given index and center, X[index] = center.

    Notes
    -----
    Selects initial cluster centers for k-mean clustering in a smart way
    to speed up convergence. see: Arthur, D. and Vassilvitskii, S.
    "k-means++: the advantages of careful seeding". ACM-SIAM symposium
    on Discrete algorithms. 2007

    Examples
    --------

    &gt;&gt;&gt; from sklearn.cluster import kmeans_plusplus
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; X = np.array([[1, 2], [1, 4], [1, 0],
    ...               [10, 2], [10, 4], [10, 0]])
    &gt;&gt;&gt; centers, indices = kmeans_plusplus(X, n_clusters=2, random_state=0)
    &gt;&gt;&gt; centers
    array([[10,  4],
           [ 1,  0]])
    &gt;&gt;&gt; indices
    array([4, 2])
    """</span>

    <span class="comment"># Check data</span>
    <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csr'</span><span class="punctuation">,</span>
                <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">&lt;</span> <span class="identifier">n_clusters</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"n_samples={X.shape[0]} should be &gt;= "</span>
                         <span class="identifier">f</span><span class="string-literal">"n_clusters={n_clusters}."</span><span class="grouping">)</span>

    <span class="comment"># Check parameters</span>
    <span class="keyword">if</span> <span class="identifier">x_squared_norms</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">x_squared_norms</span> <span class="arithmetic-assignment">=</span> <span class="identifier">row_norms</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">squared</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">x_squared_norms</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">x_squared_norms</span><span class="punctuation">,</span>
                                      <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span>
                                      <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">x_squared_norms</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">!=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
            <span class="identifier">f</span><span class="string-literal">"The length of x_squared_norms {x_squared_norms.shape[0]} should "</span>
            <span class="identifier">f</span><span class="string-literal">"be equal to the length of n_samples {X.shape[0]}."</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">n_local_trials</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">n_local_trials</span> <span class="relational-operator">&lt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
            <span class="identifier">f</span><span class="string-literal">"n_local_trials is set to {n_local_trials} but should be an "</span>
            <span class="identifier">f</span><span class="string-literal">"integer value greater than zero."</span><span class="grouping">)</span>

    <span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">random_state</span><span class="grouping">)</span>

    <span class="comment"># Call private k-means++</span>
    <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_kmeans_plusplus</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="punctuation">,</span>
                                        <span class="identifier">random_state</span><span class="punctuation">,</span> <span class="identifier">n_local_trials</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">indices</span>


<span class="keyword">def</span> <span class="identifier">_kmeans_plusplus</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="punctuation">,</span>
                     <span class="identifier">random_state</span><span class="punctuation">,</span> <span class="identifier">n_local_trials</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Computational component for initialization of n_clusters by
    k-means++. Prior validation of data is assumed.

    Parameters
    ----------
    X : {ndarray, sparse matrix} of shape (n_samples, n_features)
        The data to pick seeds for.

    n_clusters : int
        The number of seeds to choose.

    x_squared_norms : ndarray of shape (n_samples,)
        Squared Euclidean norm of each data point.

    random_state : RandomState instance
        The generator used to initialize the centers.
        See :term:`Glossary &lt;random_state&gt;`.

    n_local_trials : int, default=None
        The number of seeding trials for each center (except the first),
        of which the one reducing inertia the most is greedily chosen.
        Set to None to make the number of trials depend logarithmically
        on the number of seeds (2+log(k)); this is the default.

    Returns
    -------
    centers : ndarray of shape (n_clusters, n_features)
        The inital centers for k-means.

    indices : ndarray of shape (n_clusters,)
        The index location of the chosen centers in the data array X. For a
        given index and center, X[index] = center.
    """</span>
    <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>

    <span class="identifier">centers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

    <span class="comment"># Set the number of local seeding trials if none is given</span>
    <span class="keyword">if</span> <span class="identifier">n_local_trials</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="comment"># This is what Arthur/Vassilvitskii tried, but did not report</span>
        <span class="comment"># specific results for other than mentioning in the conclusion</span>
        <span class="comment"># that it helped.</span>
        <span class="identifier">n_local_trials</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">2</span> <span class="arithmetic-operator">+</span> <span class="identifier">int</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">log</span><span class="grouping">(</span><span class="identifier">n_clusters</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="comment"># Pick first center randomly and track index of point</span>
    <span class="identifier">center_id</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span><span class="punctuation">.</span><span class="identifier">randint</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="grouping">)</span>
    <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">full</span><span class="grouping">(</span><span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">int</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">centers</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">center_id</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">centers</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">center_id</span><span class="grouping">]</span>
    <span class="identifier">indices</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">center_id</span>

    <span class="comment"># Initialize list of closest distances and calculate current potential</span>
    <span class="identifier">closest_dist_sq</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_euclidean_distances</span><span class="grouping">(</span>
        <span class="identifier">centers</span><span class="grouping">[</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">Y_norm_squared</span><span class="arithmetic-assignment">=</span><span class="identifier">x_squared_norms</span><span class="punctuation">,</span>
        <span class="identifier">squared</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
    <span class="identifier">current_pot</span> <span class="arithmetic-assignment">=</span> <span class="identifier">closest_dist_sq</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="comment"># Pick the remaining n_clusters-1 points</span>
    <span class="keyword">for</span> <span class="identifier">c</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">n_clusters</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># Choose center candidates by sampling with probability proportional</span>
        <span class="comment"># to the squared distance to the closest existing center</span>
        <span class="identifier">rand_vals</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span><span class="punctuation">.</span><span class="identifier">random_sample</span><span class="grouping">(</span><span class="identifier">n_local_trials</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">current_pot</span>
        <span class="identifier">candidate_ids</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">searchsorted</span><span class="grouping">(</span><span class="identifier">stable_cumsum</span><span class="grouping">(</span><span class="identifier">closest_dist_sq</span><span class="grouping">)</span><span class="punctuation">,</span>
                                        <span class="identifier">rand_vals</span><span class="grouping">)</span>
        <span class="comment"># XXX: numerical imprecision can result in a candidate_id out of range</span>
        <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">clip</span><span class="grouping">(</span><span class="identifier">candidate_ids</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">closest_dist_sq</span><span class="punctuation">.</span><span class="identifier">size</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="punctuation">,</span>
                <span class="identifier">out</span><span class="arithmetic-assignment">=</span><span class="identifier">candidate_ids</span><span class="grouping">)</span>

        <span class="comment"># Compute distances to center candidates</span>
        <span class="identifier">distance_to_candidates</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_euclidean_distances</span><span class="grouping">(</span>
            <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">candidate_ids</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">Y_norm_squared</span><span class="arithmetic-assignment">=</span><span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">squared</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

        <span class="comment"># update closest distances squared and potential for each candidate</span>
        <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">minimum</span><span class="grouping">(</span><span class="identifier">closest_dist_sq</span><span class="punctuation">,</span> <span class="identifier">distance_to_candidates</span><span class="punctuation">,</span>
                   <span class="identifier">out</span><span class="arithmetic-assignment">=</span><span class="identifier">distance_to_candidates</span><span class="grouping">)</span>
        <span class="identifier">candidates_pot</span> <span class="arithmetic-assignment">=</span> <span class="identifier">distance_to_candidates</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span>

        <span class="comment"># Decide which candidate is the best</span>
        <span class="identifier">best_candidate</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argmin</span><span class="grouping">(</span><span class="identifier">candidates_pot</span><span class="grouping">)</span>
        <span class="identifier">current_pot</span> <span class="arithmetic-assignment">=</span> <span class="identifier">candidates_pot</span><span class="grouping">[</span><span class="identifier">best_candidate</span><span class="grouping">]</span>
        <span class="identifier">closest_dist_sq</span> <span class="arithmetic-assignment">=</span> <span class="identifier">distance_to_candidates</span><span class="grouping">[</span><span class="identifier">best_candidate</span><span class="grouping">]</span>
        <span class="identifier">best_candidate</span> <span class="arithmetic-assignment">=</span> <span class="identifier">candidate_ids</span><span class="grouping">[</span><span class="identifier">best_candidate</span><span class="grouping">]</span>

        <span class="comment"># Permanently add best center candidate found in local tries</span>
        <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">centers</span><span class="grouping">[</span><span class="identifier">c</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">best_candidate</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">centers</span><span class="grouping">[</span><span class="identifier">c</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">best_candidate</span><span class="grouping">]</span>
        <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">c</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">best_candidate</span>

    <span class="keyword">return</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">indices</span>


<span class="comment">###############################################################################</span>
<span class="comment"># K-means batch estimation by EM (expectation maximization)</span>

<span class="keyword">def</span> <span class="identifier">_tolerance</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Return a tolerance which is dependent on the dataset."""</span>
    <span class="keyword">if</span> <span class="identifier">tol</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="int-literal">0</span>
    <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">variances</span> <span class="arithmetic-assignment">=</span> <span class="identifier">mean_variance_axis</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">variances</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">var</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="identifier">variances</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">tol</span>


<span class="keyword">def</span> <span class="identifier">k_means</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="arithmetic-assignment">=</span><span class="string-literal">'k-means++'</span><span class="punctuation">,</span>
            <span class="identifier">n_init</span><span class="arithmetic-assignment">=</span><span class="int-literal">10</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">300</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span>
            <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">copy_x</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">algorithm</span><span class="arithmetic-assignment">=</span><span class="string-literal">"auto"</span><span class="punctuation">,</span>
            <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""K-means clustering algorithm.

    Read more in the :ref:`User Guide &lt;k_means&gt;`.

    Parameters
    ----------
    X : {array-like, sparse matrix} of shape (n_samples, n_features)
        The observations to cluster. It must be noted that the data
        will be converted to C ordering, which will cause a memory copy
        if the given data is not C-contiguous.

    n_clusters : int
        The number of clusters to form as well as the number of
        centroids to generate.

    sample_weight : array-like of shape (n_samples,), default=None
        The weights for each observation in X. If None, all observations
        are assigned equal weight.

    init : {'k-means++', 'random'}, callable or array-like of shape \
            (n_clusters, n_features), default='k-means++'
        Method for initialization:

        'k-means++' : selects initial cluster centers for k-mean
        clustering in a smart way to speed up convergence. See section
        Notes in k_init for more details.

        'random': choose `n_clusters` observations (rows) at random from data
        for the initial centroids.

        If an array is passed, it should be of shape (n_clusters, n_features)
        and gives the initial centers.

        If a callable is passed, it should take arguments X, n_clusters and a
        random state and return an initialization.

    n_init : int, default=10
        Number of time the k-means algorithm will be run with different
        centroid seeds. The final results will be the best output of
        n_init consecutive runs in terms of inertia.

    max_iter : int, default=300
        Maximum number of iterations of the k-means algorithm to run.

    verbose : bool, default=False
        Verbosity mode.

    tol : float, default=1e-4
        Relative tolerance with regards to Frobenius norm of the difference
        in the cluster centers of two consecutive iterations to declare
        convergence.

    random_state : int, RandomState instance or None, default=None
        Determines random number generation for centroid initialization. Use
        an int to make the randomness deterministic.
        See :term:`Glossary &lt;random_state&gt;`.

    copy_x : bool, default=True
        When pre-computing distances it is more numerically accurate to center
        the data first. If copy_x is True (default), then the original data is
        not modified. If False, the original data is modified, and put back
        before the function returns, but small numerical differences may be
        introduced by subtracting and then adding the data mean. Note that if
        the original data is not C-contiguous, a copy will be made even if
        copy_x is False. If the original data is sparse, but not in CSR format,
        a copy will be made even if copy_x is False.

    algorithm : {"auto", "full", "elkan"}, default="auto"
        K-means algorithm to use. The classical EM-style algorithm is "full".
        The "elkan" variation is more efficient on data with well-defined
        clusters, by using the triangle inequality. However it's more memory
        intensive due to the allocation of an extra array of shape
        (n_samples, n_clusters).

        For now "auto" (kept for backward compatibility) chooses "elkan" but it
        might change in the future for a better heuristic.

    return_n_iter : bool, default=False
        Whether or not to return the number of iterations.

    Returns
    -------
    centroid : ndarray of shape (n_clusters, n_features)
        Centroids found at the last iteration of k-means.

    label : ndarray of shape (n_samples,)
        label[i] is the code or index of the centroid the
        i'th observation is closest to.

    inertia : float
        The final value of the inertia criterion (sum of squared distances to
        the closest centroid for all observations in the training set).

    best_n_iter : int
        Number of iterations corresponding to the best results.
        Returned only if `return_n_iter` is set to True.
    """</span>
    <span class="identifier">est</span> <span class="arithmetic-assignment">=</span> <span class="identifier">KMeans</span><span class="grouping">(</span>
        <span class="identifier">n_clusters</span><span class="arithmetic-assignment">=</span><span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="arithmetic-assignment">=</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="identifier">n_init</span><span class="arithmetic-assignment">=</span><span class="identifier">n_init</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
        <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="punctuation">,</span> <span class="identifier">copy_x</span><span class="arithmetic-assignment">=</span><span class="identifier">copy_x</span><span class="punctuation">,</span>
        <span class="identifier">algorithm</span><span class="arithmetic-assignment">=</span><span class="identifier">algorithm</span>
    <span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">est</span><span class="punctuation">.</span><span class="identifier">cluster_centers_</span><span class="punctuation">,</span> <span class="identifier">est</span><span class="punctuation">.</span><span class="identifier">labels_</span><span class="punctuation">,</span> <span class="identifier">est</span><span class="punctuation">.</span><span class="identifier">inertia_</span><span class="punctuation">,</span> <span class="identifier">est</span><span class="punctuation">.</span><span class="identifier">n_iter_</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">est</span><span class="punctuation">.</span><span class="identifier">cluster_centers_</span><span class="punctuation">,</span> <span class="identifier">est</span><span class="punctuation">.</span><span class="identifier">labels_</span><span class="punctuation">,</span> <span class="identifier">est</span><span class="punctuation">.</span><span class="identifier">inertia_</span>


<span class="keyword">def</span> <span class="identifier">_kmeans_single_elkan</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">centers_init</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">300</span><span class="punctuation">,</span>
                         <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span>
                         <span class="identifier">n_threads</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""A single run of k-means elkan, assumes preparation completed prior.

    Parameters
    ----------
    X : {ndarray, sparse matrix} of shape (n_samples, n_features)
        The observations to cluster. If sparse matrix, must be in CSR format.

    sample_weight : array-like of shape (n_samples,)
        The weights for each observation in X.

    centers_init : ndarray of shape (n_clusters, n_features)
        The initial centers.

    max_iter : int, default=300
        Maximum number of iterations of the k-means algorithm to run.

    verbose : bool, default=False
        Verbosity mode.

    x_squared_norms : array-like, default=None
        Precomputed x_squared_norms.

    tol : float, default=1e-4
        Relative tolerance with regards to Frobenius norm of the difference
        in the cluster centers of two consecutive iterations to declare
        convergence.
        It's not advised to set `tol=0` since convergence might never be
        declared due to rounding errors. Use a very small number instead.

    n_threads : int, default=1
        The number of OpenMP threads to use for the computation. Parallelism is
        sample-wise on the main cython loop which assigns each sample to its
        closest center.

    Returns
    -------
    centroid : ndarray of shape (n_clusters, n_features)
        Centroids found at the last iteration of k-means.

    label : ndarray of shape (n_samples,)
        label[i] is the code or index of the centroid the
        i'th observation is closest to.

    inertia : float
        The final value of the inertia criterion (sum of squared distances to
        the closest centroid for all observations in the training set).

    n_iter : int
        Number of iterations run.
    """</span>
    <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
    <span class="identifier">n_clusters</span> <span class="arithmetic-assignment">=</span> <span class="identifier">centers_init</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

    <span class="comment"># Buffers to avoid new allocations at each iteration.</span>
    <span class="identifier">centers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">centers_init</span>
    <span class="identifier">centers_new</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros_like</span><span class="grouping">(</span><span class="identifier">centers</span><span class="grouping">)</span>
    <span class="identifier">weight_in_clusters</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
    <span class="identifier">labels</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">full</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">int32</span><span class="grouping">)</span>
    <span class="identifier">labels_old</span> <span class="arithmetic-assignment">=</span> <span class="identifier">labels</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="identifier">center_half_distances</span> <span class="arithmetic-assignment">=</span> <span class="identifier">euclidean_distances</span><span class="grouping">(</span><span class="identifier">centers</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="int-literal">2</span>
    <span class="identifier">distance_next_center</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">partition</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">center_half_distances</span><span class="grouping">)</span><span class="punctuation">,</span>
                                        <span class="identifier">kth</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>
    <span class="identifier">upper_bounds</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
    <span class="identifier">lower_bounds</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_clusters</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
    <span class="identifier">center_shift</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">init_bounds</span> <span class="arithmetic-assignment">=</span> <span class="identifier">init_bounds_sparse</span>
        <span class="identifier">elkan_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">elkan_iter_chunked_sparse</span>
        <span class="identifier">_inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_inertia_sparse</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">init_bounds</span> <span class="arithmetic-assignment">=</span> <span class="identifier">init_bounds_dense</span>
        <span class="identifier">elkan_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">elkan_iter_chunked_dense</span>
        <span class="identifier">_inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_inertia_dense</span>

    <span class="identifier">init_bounds</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">center_half_distances</span><span class="punctuation">,</span>
                <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">upper_bounds</span><span class="punctuation">,</span> <span class="identifier">lower_bounds</span><span class="grouping">)</span>

    <span class="identifier">strict_convergence</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>

    <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">max_iter</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">elkan_iter</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">centers_new</span><span class="punctuation">,</span>
                   <span class="identifier">weight_in_clusters</span><span class="punctuation">,</span> <span class="identifier">center_half_distances</span><span class="punctuation">,</span>
                   <span class="identifier">distance_next_center</span><span class="punctuation">,</span> <span class="identifier">upper_bounds</span><span class="punctuation">,</span> <span class="identifier">lower_bounds</span><span class="punctuation">,</span>
                   <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">center_shift</span><span class="punctuation">,</span> <span class="identifier">n_threads</span><span class="grouping">)</span>

        <span class="comment"># compute new pairwise distances between centers and closest other</span>
        <span class="comment"># center of each center for next iterations</span>
        <span class="identifier">center_half_distances</span> <span class="arithmetic-assignment">=</span> <span class="identifier">euclidean_distances</span><span class="grouping">(</span><span class="identifier">centers_new</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="int-literal">2</span>
        <span class="identifier">distance_next_center</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">partition</span><span class="grouping">(</span>
            <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">center_half_distances</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">kth</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>

        <span class="keyword">if</span> <span class="identifier">verbose</span><span class="punctuation">:</span>
            <span class="identifier">inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_inertia</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">n_threads</span><span class="grouping">)</span>
            <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Iteration {i}, inertia {inertia}"</span><span class="grouping">)</span>

        <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">centers_new</span> <span class="arithmetic-assignment">=</span> <span class="identifier">centers_new</span><span class="punctuation">,</span> <span class="identifier">centers</span>

        <span class="keyword">if</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array_equal</span><span class="grouping">(</span><span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">labels_old</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># First check the labels for strict convergence.</span>
            <span class="keyword">if</span> <span class="identifier">verbose</span><span class="punctuation">:</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Converged at iteration {i}: strict convergence."</span><span class="grouping">)</span>
            <span class="identifier">strict_convergence</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>
            <span class="keyword">break</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># No strict convergence, check for tol based convergence.</span>
            <span class="identifier">center_shift_tot</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">center_shift</span><span class="arithmetic-operator">**</span><span class="int-literal">2</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">center_shift_tot</span> <span class="relational-operator">&lt;=</span> <span class="identifier">tol</span><span class="punctuation">:</span>
                <span class="keyword">if</span> <span class="identifier">verbose</span><span class="punctuation">:</span>
                    <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Converged at iteration {i}: center shift "</span>
                          <span class="identifier">f</span><span class="string-literal">"{center_shift_tot} within tolerance {tol}."</span><span class="grouping">)</span>
                <span class="keyword">break</span>

        <span class="identifier">labels_old</span><span class="grouping">[</span><span class="punctuation">:</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">labels</span>

    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">strict_convergence</span><span class="punctuation">:</span>
        <span class="comment"># rerun E-step so that predicted labels match cluster centers</span>
        <span class="identifier">elkan_iter</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">weight_in_clusters</span><span class="punctuation">,</span>
                   <span class="identifier">center_half_distances</span><span class="punctuation">,</span> <span class="identifier">distance_next_center</span><span class="punctuation">,</span>
                   <span class="identifier">upper_bounds</span><span class="punctuation">,</span> <span class="identifier">lower_bounds</span><span class="punctuation">,</span> <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">center_shift</span><span class="punctuation">,</span>
                   <span class="identifier">n_threads</span><span class="punctuation">,</span> <span class="identifier">update_centers</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="identifier">inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_inertia</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">n_threads</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">inertia</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span>


<span class="keyword">def</span> <span class="identifier">_kmeans_single_lloyd</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">centers_init</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">300</span><span class="punctuation">,</span>
                         <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span>
                         <span class="identifier">n_threads</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""A single run of k-means lloyd, assumes preparation completed prior.

    Parameters
    ----------
    X : {ndarray, sparse matrix} of shape (n_samples, n_features)
        The observations to cluster. If sparse matrix, must be in CSR format.

    sample_weight : ndarray of shape (n_samples,)
        The weights for each observation in X.

    centers_init : ndarray of shape (n_clusters, n_features)
        The initial centers.

    max_iter : int, default=300
        Maximum number of iterations of the k-means algorithm to run.

    verbose : bool, default=False
        Verbosity mode

    x_squared_norms : ndarray of shape (n_samples,), default=None
        Precomputed x_squared_norms.

    tol : float, default=1e-4
        Relative tolerance with regards to Frobenius norm of the difference
        in the cluster centers of two consecutive iterations to declare
        convergence.
        It's not advised to set `tol=0` since convergence might never be
        declared due to rounding errors. Use a very small number instead.

    n_threads : int, default=1
        The number of OpenMP threads to use for the computation. Parallelism is
        sample-wise on the main cython loop which assigns each sample to its
        closest center.

    Returns
    -------
    centroid : ndarray of shape (n_clusters, n_features)
        Centroids found at the last iteration of k-means.

    label : ndarray of shape (n_samples,)
        label[i] is the code or index of the centroid the
        i'th observation is closest to.

    inertia : float
        The final value of the inertia criterion (sum of squared distances to
        the closest centroid for all observations in the training set).

    n_iter : int
        Number of iterations run.
    """</span>
    <span class="identifier">n_clusters</span> <span class="arithmetic-assignment">=</span> <span class="identifier">centers_init</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

    <span class="comment"># Buffers to avoid new allocations at each iteration.</span>
    <span class="identifier">centers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">centers_init</span>
    <span class="identifier">centers_new</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros_like</span><span class="grouping">(</span><span class="identifier">centers</span><span class="grouping">)</span>
    <span class="identifier">labels</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">full</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">int32</span><span class="grouping">)</span>
    <span class="identifier">labels_old</span> <span class="arithmetic-assignment">=</span> <span class="identifier">labels</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="identifier">weight_in_clusters</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
    <span class="identifier">center_shift</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">lloyd_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">lloyd_iter_chunked_sparse</span>
        <span class="identifier">_inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_inertia_sparse</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">lloyd_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">lloyd_iter_chunked_dense</span>
        <span class="identifier">_inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_inertia_dense</span>

    <span class="identifier">strict_convergence</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>

    <span class="comment"># Threadpoolctl context to limit the number of threads in second level of</span>
    <span class="comment"># nested parallelism (i.e. BLAS) to avoid oversubsciption.</span>
    <span class="keyword">with</span> <span class="identifier">threadpool_limits</span><span class="grouping">(</span><span class="identifier">limits</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">user_api</span><span class="arithmetic-assignment">=</span><span class="string-literal">"blas"</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">max_iter</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">lloyd_iter</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">centers_new</span><span class="punctuation">,</span>
                       <span class="identifier">weight_in_clusters</span><span class="punctuation">,</span> <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">center_shift</span><span class="punctuation">,</span> <span class="identifier">n_threads</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="identifier">verbose</span><span class="punctuation">:</span>
                <span class="identifier">inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_inertia</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">labels</span><span class="punctuation">,</span>
                                   <span class="identifier">n_threads</span><span class="grouping">)</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Iteration {i}, inertia {inertia}."</span><span class="grouping">)</span>

            <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">centers_new</span> <span class="arithmetic-assignment">=</span> <span class="identifier">centers_new</span><span class="punctuation">,</span> <span class="identifier">centers</span>

            <span class="keyword">if</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array_equal</span><span class="grouping">(</span><span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">labels_old</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="comment"># First check the labels for strict convergence.</span>
                <span class="keyword">if</span> <span class="identifier">verbose</span><span class="punctuation">:</span>
                    <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Converged at iteration {i}: strict convergence."</span><span class="grouping">)</span>
                <span class="identifier">strict_convergence</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>
                <span class="keyword">break</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="comment"># No strict convergence, check for tol based convergence.</span>
                <span class="identifier">center_shift_tot</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">center_shift</span><span class="arithmetic-operator">**</span><span class="int-literal">2</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span>
                <span class="keyword">if</span> <span class="identifier">center_shift_tot</span> <span class="relational-operator">&lt;=</span> <span class="identifier">tol</span><span class="punctuation">:</span>
                    <span class="keyword">if</span> <span class="identifier">verbose</span><span class="punctuation">:</span>
                        <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Converged at iteration {i}: center shift "</span>
                              <span class="identifier">f</span><span class="string-literal">"{center_shift_tot} within tolerance {tol}."</span><span class="grouping">)</span>
                    <span class="keyword">break</span>

            <span class="identifier">labels_old</span><span class="grouping">[</span><span class="punctuation">:</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">labels</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">strict_convergence</span><span class="punctuation">:</span>
            <span class="comment"># rerun E-step so that predicted labels match cluster centers</span>
            <span class="identifier">lloyd_iter</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span>
                       <span class="identifier">weight_in_clusters</span><span class="punctuation">,</span> <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">center_shift</span><span class="punctuation">,</span> <span class="identifier">n_threads</span><span class="punctuation">,</span>
                       <span class="identifier">update_centers</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="identifier">inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_inertia</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">n_threads</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">inertia</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span>


<span class="keyword">def</span> <span class="identifier">_labels_inertia</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span>
                    <span class="identifier">n_threads</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""E step of the K-means EM algorithm.

    Compute the labels and the inertia of the given samples and centers.

    Parameters
    ----------
    X : {ndarray, sparse matrix} of shape (n_samples, n_features)
        The input samples to assign to the labels. If sparse matrix, must
        be in CSR format.

    sample_weight : ndarray of shape (n_samples,)
        The weights for each observation in X.

    x_squared_norms : ndarray of shape (n_samples,)
        Precomputed squared euclidean norm of each data point, to speed up
        computations.

    centers : ndarray of shape (n_clusters, n_features)
        The cluster centers.

    n_threads : int, default=1
        The number of OpenMP threads to use for the computation. Parallelism is
        sample-wise on the main cython loop which assigns each sample to its
        closest center.

    Returns
    -------
    labels : ndarray of shape (n_samples,)
        The resulting assignment.

    inertia : float
        Sum of squared distances of samples to their closest cluster center.
    """</span>
    <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
    <span class="identifier">n_clusters</span> <span class="arithmetic-assignment">=</span> <span class="identifier">centers</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

    <span class="identifier">labels</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">full</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">int32</span><span class="grouping">)</span>
    <span class="identifier">weight_in_clusters</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">centers</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
    <span class="identifier">center_shift</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros_like</span><span class="grouping">(</span><span class="identifier">weight_in_clusters</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">_labels</span> <span class="arithmetic-assignment">=</span> <span class="identifier">lloyd_iter_chunked_sparse</span>
        <span class="identifier">_inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_inertia_sparse</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">_labels</span> <span class="arithmetic-assignment">=</span> <span class="identifier">lloyd_iter_chunked_dense</span>
        <span class="identifier">_inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_inertia_dense</span>

    <span class="identifier">_labels</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span>
            <span class="identifier">weight_in_clusters</span><span class="punctuation">,</span> <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">center_shift</span><span class="punctuation">,</span> <span class="identifier">n_threads</span><span class="punctuation">,</span>
            <span class="identifier">update_centers</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="identifier">inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_inertia</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">n_threads</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">inertia</span>


<span class="keyword">def</span> <span class="identifier">_labels_inertia_threadpool_limit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="punctuation">,</span>
                                     <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">n_threads</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Same as _labels_inertia but in a threadpool_limits context."""</span>
    <span class="keyword">with</span> <span class="identifier">threadpool_limits</span><span class="grouping">(</span><span class="identifier">limits</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">user_api</span><span class="arithmetic-assignment">=</span><span class="string-literal">"blas"</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_labels_inertia</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="punctuation">,</span>
                                          <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">n_threads</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">inertia</span>


<span class="keyword">class</span> <span class="identifier">KMeans</span><span class="grouping">(</span><span class="identifier">TransformerMixin</span><span class="punctuation">,</span> <span class="identifier">ClusterMixin</span><span class="punctuation">,</span> <span class="identifier">BaseEstimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""K-Means clustering.

    Read more in the :ref:`User Guide &lt;k_means&gt;`.

    Parameters
    ----------

    n_clusters : int, default=8
        The number of clusters to form as well as the number of
        centroids to generate.

    init : {'k-means++', 'random'}, callable or array-like of shape \
            (n_clusters, n_features), default='k-means++'
        Method for initialization:

        'k-means++' : selects initial cluster centers for k-mean
        clustering in a smart way to speed up convergence. See section
        Notes in k_init for more details.

        'random': choose `n_clusters` observations (rows) at random from data
        for the initial centroids.

        If an array is passed, it should be of shape (n_clusters, n_features)
        and gives the initial centers.

        If a callable is passed, it should take arguments X, n_clusters and a
        random state and return an initialization.

    n_init : int, default=10
        Number of time the k-means algorithm will be run with different
        centroid seeds. The final results will be the best output of
        n_init consecutive runs in terms of inertia.

    max_iter : int, default=300
        Maximum number of iterations of the k-means algorithm for a
        single run.

    tol : float, default=1e-4
        Relative tolerance with regards to Frobenius norm of the difference
        in the cluster centers of two consecutive iterations to declare
        convergence.

    verbose : int, default=0
        Verbosity mode.

    random_state : int, RandomState instance or None, default=None
        Determines random number generation for centroid initialization. Use
        an int to make the randomness deterministic.
        See :term:`Glossary &lt;random_state&gt;`.

    copy_x : bool, default=True
        When pre-computing distances it is more numerically accurate to center
        the data first. If copy_x is True (default), then the original data is
        not modified. If False, the original data is modified, and put back
        before the function returns, but small numerical differences may be
        introduced by subtracting and then adding the data mean. Note that if
        the original data is not C-contiguous, a copy will be made even if
        copy_x is False. If the original data is sparse, but not in CSR format,
        a copy will be made even if copy_x is False.

    algorithm : {"auto", "full", "elkan"}, default="auto"
        K-means algorithm to use. The classical EM-style algorithm is "full".
        The "elkan" variation is more efficient on data with well-defined
        clusters, by using the triangle inequality. However it's more memory
        intensive due to the allocation of an extra array of shape
        (n_samples, n_clusters).

        For now "auto" (kept for backward compatibiliy) chooses "elkan" but it
        might change in the future for a better heuristic.

        .. versionchanged:: 0.18
            Added Elkan algorithm

    Attributes
    ----------
    cluster_centers_ : ndarray of shape (n_clusters, n_features)
        Coordinates of cluster centers. If the algorithm stops before fully
        converging (see ``tol`` and ``max_iter``), these will not be
        consistent with ``labels_``.

    labels_ : ndarray of shape (n_samples,)
        Labels of each point

    inertia_ : float
        Sum of squared distances of samples to their closest cluster center,
        weighted by the sample weights if provided.

    n_iter_ : int
        Number of iterations run.

    See Also
    --------
    MiniBatchKMeans : Alternative online implementation that does incremental
        updates of the centers positions using mini-batches.
        For large scale learning (say n_samples &gt; 10k) MiniBatchKMeans is
        probably much faster than the default batch implementation.

    Notes
    -----
    The k-means problem is solved using either Lloyd's or Elkan's algorithm.

    The average complexity is given by O(k n T), where n is the number of
    samples and T is the number of iteration.

    The worst case complexity is given by O(n^(k+2/p)) with
    n = n_samples, p = n_features. (D. Arthur and S. Vassilvitskii,
    'How slow is the k-means method?' SoCG2006)

    In practice, the k-means algorithm is very fast (one of the fastest
    clustering algorithms available), but it falls in local minima. That's why
    it can be useful to restart it several times.

    If the algorithm stops before fully converging (because of ``tol`` or
    ``max_iter``), ``labels_`` and ``cluster_centers_`` will not be consistent,
    i.e. the ``cluster_centers_`` will not be the means of the points in each
    cluster. Also, the estimator will reassign ``labels_`` after the last
    iteration to make ``labels_`` consistent with ``predict`` on the training
    set.

    Examples
    --------

    &gt;&gt;&gt; from sklearn.cluster import KMeans
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; X = np.array([[1, 2], [1, 4], [1, 0],
    ...               [10, 2], [10, 4], [10, 0]])
    &gt;&gt;&gt; kmeans = KMeans(n_clusters=2, random_state=0).fit(X)
    &gt;&gt;&gt; kmeans.labels_
    array([1, 1, 1, 0, 0, 0], dtype=int32)
    &gt;&gt;&gt; kmeans.predict([[0, 0], [12, 3]])
    array([1, 0], dtype=int32)
    &gt;&gt;&gt; kmeans.cluster_centers_
    array([[10.,  2.],
           [ 1.,  2.]])
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">n_clusters</span><span class="arithmetic-assignment">=</span><span class="int-literal">8</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="arithmetic-assignment">=</span><span class="string-literal">'k-means++'</span><span class="punctuation">,</span> <span class="identifier">n_init</span><span class="arithmetic-assignment">=</span><span class="int-literal">10</span><span class="punctuation">,</span>
                 <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">300</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">copy_x</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">algorithm</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="grouping">)</span><span class="punctuation">:</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_clusters</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init</span> <span class="arithmetic-assignment">=</span> <span class="identifier">init</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span> <span class="arithmetic-assignment">=</span> <span class="identifier">tol</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_init</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_init</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">verbose</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_x</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy_x</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">algorithm</span> <span class="arithmetic-assignment">=</span> <span class="identifier">algorithm</span>

    <span class="keyword">def</span> <span class="identifier">_check_params</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># n_init</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_init</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="identifier">f</span><span class="string-literal">"n_init should be &gt; 0, got {self.n_init} instead."</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_init</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_init</span>

        <span class="comment"># max_iter</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="identifier">f</span><span class="string-literal">"max_iter should be &gt; 0, got {self.max_iter} instead."</span><span class="grouping">)</span>

        <span class="comment"># n_clusters</span>
        <span class="keyword">if</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">&lt;</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"n_samples={X.shape[0]} should be &gt;= "</span>
                             <span class="identifier">f</span><span class="string-literal">"n_clusters={self.n_clusters}."</span><span class="grouping">)</span>

        <span class="comment"># tol</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_tol</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_tolerance</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span><span class="grouping">)</span>

        <span class="comment"># algorithm</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">algorithm</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="string-literal">"auto", "full", "elkan"</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Algorithm must be 'auto', 'full' or 'elkan', "</span>
                             <span class="identifier">f</span><span class="string-literal">"got {self.algorithm} instead."</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_algorithm</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">algorithm</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_algorithm</span> <span class="relational-operator">==</span> <span class="string-literal">"auto"</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_algorithm</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"full" if self.n_clusters == 1 else "elkan"</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_algorithm</span> <span class="relational-operator">==</span> <span class="string-literal">"elkan"</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">"algorithm='elkan' doesn't make sense for a single "</span>
                          <span class="string-literal">"cluster. Using 'full' instead."</span><span class="punctuation">,</span> <span class="identifier">RuntimeWarning</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_algorithm</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"full"</span>

        <span class="comment"># init</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="grouping">(</span><span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="string-literal">'__array__'</span><span class="grouping">)</span> <span class="logical-operator">or</span> <span class="identifier">callable</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init</span><span class="grouping">)</span>
                <span class="logical-operator">or</span> <span class="grouping">(</span><span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span>
                    <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="string-literal">"k-means++", "random"</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="identifier">f</span><span class="string-literal">"init should be either 'k-means++', 'random', a ndarray or a "</span>
                <span class="identifier">f</span><span class="string-literal">"callable, got '{self.init}' instead."</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="string-literal">'__array__'</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_init</span> <span class="relational-operator">!=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span>
                <span class="identifier">f</span><span class="string-literal">"Explicit initial center position passed: performing only"</span>
                <span class="identifier">f</span><span class="string-literal">" one init in {self.__class__.__name__} instead of "</span>
                <span class="identifier">f</span><span class="string-literal">"n_init={self._n_init}."</span><span class="punctuation">,</span> <span class="identifier">RuntimeWarning</span><span class="punctuation">,</span> <span class="identifier">stacklevel</span><span class="arithmetic-assignment">=</span><span class="int-literal">2</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_init</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>

    <span class="keyword">def</span> <span class="identifier">_validate_center_shape</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Check if centers is compatible with X and n_clusters."""</span>
        <span class="keyword">if</span> <span class="identifier">centers</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">!=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="identifier">f</span><span class="string-literal">"The shape of the initial centers {centers.shape} does not "</span>
                <span class="identifier">f</span><span class="string-literal">"match the number of clusters {self.n_clusters}."</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">centers</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="relational-operator">!=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="identifier">f</span><span class="string-literal">"The shape of the initial centers {centers.shape} does not "</span>
                <span class="identifier">f</span><span class="string-literal">"match the number of features of the data {X.shape[1]}."</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_check_test_data</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csr'</span><span class="punctuation">,</span> <span class="identifier">reset</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                                <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="punctuation">,</span>
                                <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'C'</span><span class="punctuation">,</span> <span class="identifier">accept_large_sparse</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">X</span>

    <span class="keyword">def</span> <span class="identifier">_check_mkl_vcomp</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Warns when vcomp and mkl are both present"""</span>
        <span class="comment"># The BLAS call inside a prange in lloyd_iter_chunked_dense is known to</span>
        <span class="comment"># cause a small memory leak when there are less chunks than the number</span>
        <span class="comment"># of available threads. It only happens when the OpenMP library is</span>
        <span class="comment"># vcomp (microsoft OpenMP) and the BLAS library is MKL. see #18653</span>
        <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">return</span>

        <span class="identifier">active_threads</span> <span class="arithmetic-assignment">=</span> <span class="identifier">int</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ceil</span><span class="grouping">(</span><span class="identifier">n_samples</span> <span class="arithmetic-operator">/</span> <span class="identifier">CHUNK_SIZE</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">active_threads</span> <span class="relational-operator">&lt;</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_threads</span><span class="punctuation">:</span>
            <span class="identifier">modules</span> <span class="arithmetic-assignment">=</span> <span class="identifier">threadpool_info</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="identifier">has_vcomp</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"vcomp" in [module["prefix"</span><span class="grouping">]</span> <span class="keyword">for</span> <span class="identifier">module</span> <span class="relational-operator">in</span> <span class="identifier">modules</span><span class="grouping">]</span>
            <span class="identifier">has_mkl</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="string-literal">"mkl", "intel"</span><span class="grouping">)</span> <span class="relational-operator">in</span> <span class="grouping">[</span>
                <span class="grouping">(</span><span class="identifier">module</span><span class="grouping">[</span><span class="string-literal">"internal_api"], module.get("threading_layer"</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">)</span><span class="grouping">)</span>
                <span class="keyword">for</span> <span class="identifier">module</span> <span class="relational-operator">in</span> <span class="identifier">modules</span><span class="grouping">]</span>
            <span class="keyword">if</span> <span class="identifier">has_vcomp</span> <span class="logical-operator">and</span> <span class="identifier">has_mkl</span><span class="punctuation">:</span>
                <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">"batch_size"</span><span class="grouping">)</span><span class="punctuation">:</span>  <span class="comment"># KMeans</span>
                    <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span>
                        <span class="identifier">f</span><span class="string-literal">"KMeans is known to have a memory leak on Windows "</span>
                        <span class="identifier">f</span><span class="string-literal">"with MKL, when there are less chunks than available "</span>
                        <span class="identifier">f</span><span class="string-literal">"threads. You can avoid it by setting the environment"</span>
                        <span class="identifier">f</span><span class="string-literal">" variable OMP_NUM_THREADS={active_threads}."</span><span class="grouping">)</span>
                <span class="keyword">else</span><span class="punctuation">:</span>  <span class="comment"># MiniBatchKMeans</span>
                    <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span>
                        <span class="identifier">f</span><span class="string-literal">"MiniBatchKMeans is known to have a memory leak on "</span>
                        <span class="identifier">f</span><span class="string-literal">"Windows with MKL, when there are less chunks than "</span>
                        <span class="identifier">f</span><span class="string-literal">"available threads. You can prevent it by setting "</span>
                        <span class="identifier">f</span><span class="string-literal">"batch_size &gt;= {self._n_threads * CHUNK_SIZE} or by "</span>
                        <span class="identifier">f</span><span class="string-literal">"setting the environment variable "</span>
                        <span class="identifier">f</span><span class="string-literal">"OMP_NUM_THREADS={active_threads}"</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_init_centroids</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="punctuation">,</span>
                        <span class="identifier">init_size</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute the initial centroids.

        Parameters
        ----------
        X : {ndarray, sparse matrix} of shape (n_samples, n_features)
            The input samples.

        x_squared_norms : ndarray of shape (n_samples,)
            Squared euclidean norm of each data point. Pass it if you have it
            at hands already to avoid it being recomputed here.

        init : {'k-means++', 'random'}, callable or ndarray of shape \
                (n_clusters, n_features)
            Method for initialization.

        random_state : RandomState instance
            Determines random number generation for centroid initialization.
            See :term:`Glossary &lt;random_state&gt;`.

        init_size : int, default=None
            Number of samples to randomly sample for speeding up the
            initialization (sometimes at the expense of accuracy).

        Returns
        -------
        centers : ndarray of shape (n_clusters, n_features)
        """</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">n_clusters</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span>

        <span class="keyword">if</span> <span class="identifier">init_size</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">init_size</span> <span class="relational-operator">&lt;</span> <span class="identifier">n_samples</span><span class="punctuation">:</span>
            <span class="identifier">init_indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span><span class="punctuation">.</span><span class="identifier">randint</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">init_size</span><span class="grouping">)</span>
            <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">init_indices</span><span class="grouping">]</span>
            <span class="identifier">x_squared_norms</span> <span class="arithmetic-assignment">=</span> <span class="identifier">x_squared_norms</span><span class="grouping">[</span><span class="identifier">init_indices</span><span class="grouping">]</span>
            <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">init</span> <span class="relational-operator">==</span> <span class="string-literal">'k-means++'</span><span class="punctuation">:</span>
            <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_kmeans_plusplus</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">n_clusters</span><span class="punctuation">,</span>
                                          <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="punctuation">,</span>
                                          <span class="identifier">x_squared_norms</span><span class="arithmetic-assignment">=</span><span class="identifier">x_squared_norms</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">init</span> <span class="relational-operator">==</span> <span class="string-literal">'random'</span><span class="punctuation">:</span>
            <span class="identifier">seeds</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span><span class="punctuation">.</span><span class="identifier">permutation</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="grouping">)</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_clusters</span><span class="grouping">]</span>
            <span class="identifier">centers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">seeds</span><span class="grouping">]</span>
        <span class="keyword">elif</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="string-literal">'__array__'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">centers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">init</span>
        <span class="keyword">elif</span> <span class="identifier">callable</span><span class="grouping">(</span><span class="identifier">init</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">centers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">init</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>
            <span class="identifier">centers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span>
                <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'C'</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_center_shape</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">centers</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">centers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">centers</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">centers</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute k-means clustering.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            Training instances to cluster. It must be noted that the data
            will be converted to C ordering, which will cause a memory
            copy if the given data is not C-contiguous.
            If a sparse matrix is passed, a copy will be made if it's not in
            CSR format.

        y : Ignored
            Not used, present here for API consistency by convention.

        sample_weight : array-like of shape (n_samples,), default=None
            The weights for each observation in X. If None, all observations
            are assigned equal weight.

            .. versionadded:: 0.20

        Returns
        -------
        self
            Fitted estimator.
        """</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csr'</span><span class="punctuation">,</span>
                                <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="punctuation">,</span>
                                <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'C'</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_x</span><span class="punctuation">,</span>
                                <span class="identifier">accept_large_sparse</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_params</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_sample_weight</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_threads</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_openmp_effective_n_threads</span><span class="grouping">(</span><span class="grouping">)</span>

        <span class="comment"># Validate init array</span>
        <span class="identifier">init</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init</span>
        <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="string-literal">'__array__'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">init</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'C'</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_center_shape</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="grouping">)</span>

        <span class="comment"># subtract of mean of x for more accurate distance computations</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">X_mean</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
            <span class="comment"># The copy was already done above</span>
            <span class="identifier">X</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">X_mean</span>

            <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="string-literal">'__array__'</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">init</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">X_mean</span>

        <span class="comment"># precompute squared norms of data points</span>
        <span class="identifier">x_squared_norms</span> <span class="arithmetic-assignment">=</span> <span class="identifier">row_norms</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">squared</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_algorithm</span> <span class="relational-operator">==</span> <span class="string-literal">"full"</span><span class="punctuation">:</span>
            <span class="identifier">kmeans_single</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_kmeans_single_lloyd</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_mkl_vcomp</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">kmeans_single</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_kmeans_single_elkan</span>

        <span class="identifier">best_inertia</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>

        <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_init</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># Initialize centers</span>
            <span class="identifier">centers_init</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_centroids</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="arithmetic-assignment">=</span><span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="arithmetic-assignment">=</span><span class="identifier">init</span><span class="punctuation">,</span>
                <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"Initialization complete"</span><span class="grouping">)</span>

            <span class="comment"># run a k-means once</span>
            <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">inertia</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">kmeans_single</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">centers_init</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
                <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_tol</span><span class="punctuation">,</span>
                <span class="identifier">x_squared_norms</span><span class="arithmetic-assignment">=</span><span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">n_threads</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_threads</span><span class="grouping">)</span>

            <span class="comment"># determine if these results are the best so far</span>
            <span class="keyword">if</span> <span class="identifier">best_inertia</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="logical-operator">or</span> <span class="identifier">inertia</span> <span class="relational-operator">&lt;</span> <span class="identifier">best_inertia</span><span class="punctuation">:</span>
                <span class="identifier">best_labels</span> <span class="arithmetic-assignment">=</span> <span class="identifier">labels</span>
                <span class="identifier">best_centers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">centers</span>
                <span class="identifier">best_inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">inertia</span>
                <span class="identifier">best_n_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_iter_</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_x</span><span class="punctuation">:</span>
                <span class="identifier">X</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">X_mean</span>
            <span class="identifier">best_centers</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">X_mean</span>

        <span class="identifier">distinct_clusters</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">set</span><span class="grouping">(</span><span class="identifier">best_labels</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">distinct_clusters</span> <span class="relational-operator">&lt;</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span>
                <span class="string-literal">"Number of distinct clusters ({}) found smaller than "</span>
                <span class="string-literal">"n_clusters ({}). Possibly due to duplicate points "</span>
                <span class="string-literal">"in X."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">distinct_clusters</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span><span class="grouping">)</span><span class="punctuation">,</span>
                <span class="identifier">ConvergenceWarning</span><span class="punctuation">,</span> <span class="identifier">stacklevel</span><span class="arithmetic-assignment">=</span><span class="int-literal">2</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cluster_centers_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">best_centers</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">labels_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">best_labels</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">inertia_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">best_inertia</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">best_n_iter</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">fit_predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute cluster centers and predict cluster index for each sample.

        Convenience method; equivalent to calling fit(X) followed by
        predict(X).

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            New data to transform.

        y : Ignored
            Not used, present here for API consistency by convention.

        sample_weight : array-like of shape (n_samples,), default=None
            The weights for each observation in X. If None, all observations
            are assigned equal weight.

        Returns
        -------
        labels : ndarray of shape (n_samples,)
            Index of the cluster each sample belongs to.
        """</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">labels_</span>

    <span class="keyword">def</span> <span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute clustering and transform X to cluster-distance space.

        Equivalent to fit(X).transform(X), but more efficiently implemented.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            New data to transform.

        y : Ignored
            Not used, present here for API consistency by convention.

        sample_weight : array-like of shape (n_samples,), default=None
            The weights for each observation in X. If None, all observations
            are assigned equal weight.

        Returns
        -------
        X_new : ndarray of shape (n_samples, n_clusters)
            X transformed in the new space.
        """</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">_transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Transform X to a cluster-distance space.

        In the new space, each dimension is the distance to the cluster
        centers. Note that even if X is sparse, the array returned by
        `transform` will typically be dense.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            New data to transform.

        Returns
        -------
        X_new : ndarray of shape (n_samples, n_clusters)
            X transformed in the new space.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_test_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Guts of transform method; no input validation."""</span>
        <span class="keyword">return</span> <span class="identifier">euclidean_distances</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cluster_centers_</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Predict the closest cluster each sample in X belongs to.

        In the vector quantization literature, `cluster_centers_` is called
        the code book and each value returned by `predict` is the index of
        the closest code in the code book.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            New data to predict.

        sample_weight : array-like of shape (n_samples,), default=None
            The weights for each observation in X. If None, all observations
            are assigned equal weight.

        Returns
        -------
        labels : ndarray of shape (n_samples,)
            Index of the cluster each sample belongs to.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_test_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">x_squared_norms</span> <span class="arithmetic-assignment">=</span> <span class="identifier">row_norms</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">squared</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_sample_weight</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">_labels_inertia_threadpool_limit</span><span class="grouping">(</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cluster_centers_</span><span class="punctuation">,</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_threads</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">score</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Opposite of the value of X on the K-means objective.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            New data.

        y : Ignored
            Not used, present here for API consistency by convention.

        sample_weight : array-like of shape (n_samples,), default=None
            The weights for each observation in X. If None, all observations
            are assigned equal weight.

        Returns
        -------
        score : float
            Opposite of the value of X on the K-means objective.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_test_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">x_squared_norms</span> <span class="arithmetic-assignment">=</span> <span class="identifier">row_norms</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">squared</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_sample_weight</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="arithmetic-operator">-</span><span class="identifier">_labels_inertia_threadpool_limit</span><span class="grouping">(</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cluster_centers_</span><span class="punctuation">,</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_threads</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span>
            <span class="string-literal">'_xfail_checks'</span><span class="punctuation">:</span> <span class="grouping">{</span>
                <span class="string-literal">'check_sample_weights_invariance'</span><span class="punctuation">:</span>
                <span class="string-literal">'zero sample_weight is not equivalent to removing samples'</span><span class="punctuation">,</span>
            <span class="grouping">}</span><span class="punctuation">,</span>
        <span class="grouping">}</span>


<span class="keyword">def</span> <span class="identifier">_mini_batch_step</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">centers_new</span><span class="punctuation">,</span>
                     <span class="identifier">weight_sums</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="punctuation">,</span> <span class="identifier">random_reassign</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                     <span class="identifier">reassignment_ratio</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.01</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">n_threads</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Incremental update of the centers for the Minibatch K-Means algorithm.

    Parameters
    ----------

    X : {ndarray, sparse matrix} of shape (n_samples, n_features)
        The original data array. If sparse, must be in CSR format.

    x_squared_norms : ndarray of shape (n_samples,)
        Squared euclidean norm of each data point.

    sample_weight : ndarray of shape (n_samples,)
        The weights for each observation in X.

    centers : ndarray of shape (n_clusters, n_features)
        The cluster centers before the current iteration

    centers_new : ndarray of shape (n_clusters, n_features)
        The cluster centers after the current iteration. Modified in-place.

    weight_sums : ndarray of shape (n_clusters,)
        The vector in which we keep track of the numbers of points in a
        cluster. This array is modified in place.

    random_state : RandomState instance
        Determines random number generation for low count centers reassignment.
        See :term:`Glossary &lt;random_state&gt;`.

    random_reassign : boolean, default=False
        If True, centers with very low counts are randomly reassigned
        to observations.

    reassignment_ratio : float, default=0.01
        Control the fraction of the maximum number of counts for a
        center to be reassigned. A higher value means that low count
        centers are more likely to be reassigned, which means that the
        model will take longer to converge, but should converge in a
        better clustering.

    verbose : bool, default=False
        Controls the verbosity.

    n_threads : int, default=1
        The number of OpenMP threads to use for the computation.

    Returns
    -------
    inertia : float
        Sum of squared distances of samples to their closest cluster center.
        The inertia is computed after finding the labels and before updating
        the centers.
    """</span>
    <span class="comment"># Perform label assignment to nearest centers</span>
    <span class="comment"># For better efficiency, it's better to run _mini_batch_step in a</span>
    <span class="comment"># threadpool_limit context than using _labels_inertia_threadpool_limit here</span>
    <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_labels_inertia</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span>
                                      <span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span>
                                      <span class="identifier">n_threads</span><span class="arithmetic-assignment">=</span><span class="identifier">n_threads</span><span class="grouping">)</span>

    <span class="comment"># Update centers according to the labels</span>
    <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">_minibatch_update_sparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">centers_new</span><span class="punctuation">,</span>
                                 <span class="identifier">weight_sums</span><span class="punctuation">,</span> <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">n_threads</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">_minibatch_update_dense</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">centers_new</span><span class="punctuation">,</span>
                                <span class="identifier">weight_sums</span><span class="punctuation">,</span> <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">n_threads</span><span class="grouping">)</span>

    <span class="comment"># Reassign clusters that have very low weight</span>
    <span class="keyword">if</span> <span class="identifier">random_reassign</span> <span class="logical-operator">and</span> <span class="identifier">reassignment_ratio</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
        <span class="identifier">to_reassign</span> <span class="arithmetic-assignment">=</span> <span class="identifier">weight_sums</span> <span class="relational-operator">&lt;</span> <span class="identifier">reassignment_ratio</span> <span class="arithmetic-operator">*</span> <span class="identifier">weight_sums</span><span class="punctuation">.</span><span class="identifier">max</span><span class="grouping">(</span><span class="grouping">)</span>

        <span class="comment"># pick at most .5 * batch_size samples as new centers</span>
        <span class="keyword">if</span> <span class="identifier">to_reassign</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="float-literal">.5</span> <span class="arithmetic-operator">*</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">:</span>
            <span class="identifier">indices_dont_reassign</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
                    <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argsort</span><span class="grouping">(</span><span class="identifier">weight_sums</span><span class="grouping">)</span><span class="grouping">[</span><span class="identifier">int</span><span class="grouping">(</span><span class="float-literal">.5</span> <span class="arithmetic-operator">*</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">:</span><span class="grouping">]</span>
            <span class="identifier">to_reassign</span><span class="grouping">[</span><span class="identifier">indices_dont_reassign</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
        <span class="identifier">n_reassigns</span> <span class="arithmetic-assignment">=</span> <span class="identifier">to_reassign</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">n_reassigns</span><span class="punctuation">:</span>
            <span class="comment"># Pick new clusters amongst observations with uniform probability</span>
            <span class="identifier">new_centers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span><span class="punctuation">.</span><span class="identifier">choice</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">replace</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                                              <span class="identifier">size</span><span class="arithmetic-assignment">=</span><span class="identifier">n_reassigns</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">verbose</span><span class="punctuation">:</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"[MiniBatchKMeans] Reassigning {n_reassigns} "</span>
                      <span class="identifier">f</span><span class="string-literal">"cluster centers."</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="identifier">sp</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">g</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">r</span><span class="invalid">o</span><span class="invalid">w</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">s</span><span class="invalid">r</span><span class="grouping">(</span>
                        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">new_centers</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">intp</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">,</span>
                        <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">where</span><span class="grouping">(</span><span class="identifier">to_reassign</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">intp</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">,</span>
                        <span class="identifier">centers_new</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">centers_new</span><span class="grouping">[</span><span class="identifier">to_reassign</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">new_centers</span><span class="grouping">]</span>

        <span class="comment"># reset counts of reassigned centers, but don't reset them too small</span>
        <span class="comment"># to avoid instant reassignment. This is a pretty dirty hack as it</span>
        <span class="comment"># also modifies the learning rates.</span>
        <span class="identifier">weight_sums</span><span class="grouping">[</span><span class="identifier">to_reassign</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">min</span><span class="grouping">(</span><span class="identifier">weight_sums</span><span class="grouping">[</span><span class="bitwise-operator">~</span><span class="identifier">to_reassign</span><span class="grouping">]</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">inertia</span>


<span class="keyword">class</span> <span class="identifier">MiniBatchKMeans</span><span class="grouping">(</span><span class="identifier">KMeans</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""
    Mini-Batch K-Means clustering.

    Read more in the :ref:`User Guide &lt;mini_batch_kmeans&gt;`.

    Parameters
    ----------

    n_clusters : int, default=8
        The number of clusters to form as well as the number of
        centroids to generate.

    init : {'k-means++', 'random'}, callable or array-like of shape \
            (n_clusters, n_features), default='k-means++'
        Method for initialization:

        'k-means++' : selects initial cluster centers for k-mean
        clustering in a smart way to speed up convergence. See section
        Notes in k_init for more details.

        'random': choose `n_clusters` observations (rows) at random from data
        for the initial centroids.

        If an array is passed, it should be of shape (n_clusters, n_features)
        and gives the initial centers.

        If a callable is passed, it should take arguments X, n_clusters and a
        random state and return an initialization.

    max_iter : int, default=100
        Maximum number of iterations over the complete dataset before
        stopping independently of any early stopping criterion heuristics.

    batch_size : int, default=1024
        Size of the mini batches.
        For faster compuations, you can set the ``batch_size`` greater than
        256 * number of cores to enable parallelism on all cores.

        .. versionchanged:: 1.0
           `batch_size` default changed from 100 to 1024.

    verbose : int, default=0
        Verbosity mode.

    compute_labels : bool, default=True
        Compute label assignment and inertia for the complete dataset
        once the minibatch optimization has converged in fit.

    random_state : int, RandomState instance or None, default=None
        Determines random number generation for centroid initialization and
        random reassignment. Use an int to make the randomness deterministic.
        See :term:`Glossary &lt;random_state&gt;`.

    tol : float, default=0.0
        Control early stopping based on the relative center changes as
        measured by a smoothed, variance-normalized of the mean center
        squared position changes. This early stopping heuristics is
        closer to the one used for the batch variant of the algorithms
        but induces a slight computational and memory overhead over the
        inertia heuristic.

        To disable convergence detection based on normalized center
        change, set tol to 0.0 (default).

    max_no_improvement : int, default=10
        Control early stopping based on the consecutive number of mini
        batches that does not yield an improvement on the smoothed inertia.

        To disable convergence detection based on inertia, set
        max_no_improvement to None.

    init_size : int, default=None
        Number of samples to randomly sample for speeding up the
        initialization (sometimes at the expense of accuracy): the
        only algorithm is initialized by running a batch KMeans on a
        random subset of the data. This needs to be larger than n_clusters.

        If `None`, the heuristic is `init_size = 3 * batch_size` if
        `3 * batch_size &lt; n_clusters`, else `init_size = 3 * n_clusters`.

    n_init : int, default=3
        Number of random initializations that are tried.
        In contrast to KMeans, the algorithm is only run once, using the
        best of the ``n_init`` initializations as measured by inertia.

    reassignment_ratio : float, default=0.01
        Control the fraction of the maximum number of counts for a center to
        be reassigned. A higher value means that low count centers are more
        easily reassigned, which means that the model will take longer to
        converge, but should converge in a better clustering. However, too high
        a value may cause convergence issues, especially with a small batch
        size.

    Attributes
    ----------

    cluster_centers_ : ndarray of shape (n_clusters, n_features)
        Coordinates of cluster centers.

    labels_ : ndarray of shape (n_samples,)
        Labels of each point (if compute_labels is set to True).

    inertia_ : float
        The value of the inertia criterion associated with the chosen
        partition if compute_labels is set to True. If compute_labels is set to
        False, it's an approximation of the inertia based on an exponentially
        weighted average of the batch inertiae.
        The inertia is defined as the sum of square distances of samples to
        their cluster center, weighted by the sample weights if provided.

    n_iter_ : int
        Number of iterations over the full dataset.

    n_steps_ : int
        Number of minibatches processed.

        .. versionadded:: 1.0

    counts_ : ndarray of shape (n_clusters,)
        Weigth sum of each cluster.

        .. deprecated:: 0.24
           This attribute is deprecated in 0.24 and will be removed in
           1.1 (renaming of 0.26).

    init_size_ : int
        The effective number of samples used for the initialization.

        .. deprecated:: 0.24
           This attribute is deprecated in 0.24 and will be removed in
           1.1 (renaming of 0.26).

    See Also
    --------
    KMeans : The classic implementation of the clustering method based on the
        Lloyd's algorithm. It consumes the whole set of input data at each
        iteration.

    Notes
    -----
    See https://www.eecs.tufts.edu/~dsculley/papers/fastkmeans.pdf

    Examples
    --------
    &gt;&gt;&gt; from sklearn.cluster import MiniBatchKMeans
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; X = np.array([[1, 2], [1, 4], [1, 0],
    ...               [4, 2], [4, 0], [4, 4],
    ...               [4, 5], [0, 1], [2, 2],
    ...               [3, 2], [5, 5], [1, -1]])
    &gt;&gt;&gt; # manually fit on batches
    &gt;&gt;&gt; kmeans = MiniBatchKMeans(n_clusters=2,
    ...                          random_state=0,
    ...                          batch_size=6)
    &gt;&gt;&gt; kmeans = kmeans.partial_fit(X[0:6,:])
    &gt;&gt;&gt; kmeans = kmeans.partial_fit(X[6:12,:])
    &gt;&gt;&gt; kmeans.cluster_centers_
    array([[2. , 1. ],
           [3.5, 4.5]])
    &gt;&gt;&gt; kmeans.predict([[0, 0], [4, 4]])
    array([0, 1], dtype=int32)
    &gt;&gt;&gt; # fit on the whole data
    &gt;&gt;&gt; kmeans = MiniBatchKMeans(n_clusters=2,
    ...                          random_state=0,
    ...                          batch_size=6,
    ...                          max_iter=10).fit(X)
    &gt;&gt;&gt; kmeans.cluster_centers_
    array([[1.19..., 1.22...],
           [4.03..., 2.46...]])
    &gt;&gt;&gt; kmeans.predict([[0, 0], [4, 4]])
    array([0, 1], dtype=int32)
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">n_clusters</span><span class="arithmetic-assignment">=</span><span class="int-literal">8</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="arithmetic-assignment">=</span><span class="string-literal">'k-means++'</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">100</span><span class="punctuation">,</span>
                 <span class="identifier">batch_size</span><span class="arithmetic-assignment">=</span><span class="int-literal">1024</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">compute_labels</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.0</span><span class="punctuation">,</span> <span class="identifier">max_no_improvement</span><span class="arithmetic-assignment">=</span><span class="int-literal">10</span><span class="punctuation">,</span>
                 <span class="identifier">init_size</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">n_init</span><span class="arithmetic-assignment">=</span><span class="int-literal">3</span><span class="punctuation">,</span> <span class="identifier">reassignment_ratio</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.01</span><span class="grouping">)</span><span class="punctuation">:</span>

        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">n_clusters</span><span class="arithmetic-assignment">=</span><span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="arithmetic-assignment">=</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
            <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">n_init</span><span class="arithmetic-assignment">=</span><span class="identifier">n_init</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_no_improvement</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_no_improvement</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">batch_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">batch_size</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">compute_labels</span> <span class="arithmetic-assignment">=</span> <span class="identifier">compute_labels</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">init_size</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">reassignment_ratio</span> <span class="arithmetic-assignment">=</span> <span class="identifier">reassignment_ratio</span>

    <span class="punctuation">@</span><span class="identifier">deprecated</span><span class="grouping">(</span><span class="string-literal">"The attribute 'counts_' is deprecated in 0.24"</span>  <span class="comment"># type: ignore</span>
                <span class="string-literal">" and will be removed in 1.1 (renaming of 0.26)."</span><span class="grouping">)</span>
    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">counts_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_counts</span>

    <span class="punctuation">@</span><span class="identifier">deprecated</span><span class="grouping">(</span><span class="string-literal">"The attribute 'init_size_' is deprecated in "</span>  <span class="comment"># type: ignore</span>
                <span class="string-literal">"0.24 and will be removed in 1.1 (renaming of 0.26)."</span><span class="grouping">)</span>
    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">init_size_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_size</span>

    <span class="punctuation">@</span><span class="identifier">deprecated</span><span class="grouping">(</span><span class="string-literal">"The attribute 'random_state_' is deprecated "</span>  <span class="comment"># type: ignore</span>
                <span class="string-literal">"in 0.24 and will be removed in 1.1 (renaming of 0.26)."</span><span class="grouping">)</span>
    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">random_state_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">"_random_state"</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_check_params</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">_check_params</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

        <span class="comment"># max_no_improvement</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_no_improvement</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_no_improvement</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="identifier">f</span><span class="string-literal">"max_no_improvement should be &gt;= 0, got "</span>
                <span class="identifier">f</span><span class="string-literal">"{self.max_no_improvement} instead."</span><span class="grouping">)</span>

        <span class="comment"># batch_size</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">batch_size</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="identifier">f</span><span class="string-literal">"batch_size should be &gt; 0, got {self.batch_size} instead."</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_batch_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">min</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">batch_size</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="comment"># init_size</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_size</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_size</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="identifier">f</span><span class="string-literal">"init_size should be &gt; 0, got {self.init_size} instead."</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init_size</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_size</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_size</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">3</span> <span class="arithmetic-operator">*</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_batch_size</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_size</span> <span class="relational-operator">&lt;</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_size</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">3</span> <span class="arithmetic-operator">*</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span>
        <span class="keyword">elif</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_size</span> <span class="relational-operator">&lt;</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span>
                <span class="identifier">f</span><span class="string-literal">"init_size={self._init_size} should be larger than "</span>
                <span class="identifier">f</span><span class="string-literal">"n_clusters={self.n_clusters}. Setting it to "</span>
                <span class="identifier">f</span><span class="string-literal">"min(3*n_clusters, n_samples)"</span><span class="punctuation">,</span>
                <span class="identifier">RuntimeWarning</span><span class="punctuation">,</span> <span class="identifier">stacklevel</span><span class="arithmetic-assignment">=</span><span class="int-literal">2</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_size</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">3</span> <span class="arithmetic-operator">*</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">min</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_size</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="comment"># reassignment_ratio</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">reassignment_ratio</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="identifier">f</span><span class="string-literal">"reassignment_ratio should be &gt;= 0, got "</span>
                <span class="identifier">f</span><span class="string-literal">"{self.reassignment_ratio} instead."</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_mini_batch_convergence</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">step</span><span class="punctuation">,</span> <span class="identifier">n_steps</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="punctuation">,</span>
                                <span class="identifier">centers_squared_diff</span><span class="punctuation">,</span> <span class="identifier">batch_inertia</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Helper function to encapsulate the early stopping logic"""</span>
        <span class="comment"># Normalize inertia to be able to compare values when</span>
        <span class="comment"># batch_size changes</span>
        <span class="identifier">batch_inertia</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_batch_size</span>

        <span class="comment"># count steps starting from 1 for user friendly verbose mode.</span>
        <span class="identifier">step</span> <span class="arithmetic-assignment">=</span> <span class="identifier">step</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span>

        <span class="comment"># Ignore first iteration because it's inertia from initialization.</span>
        <span class="keyword">if</span> <span class="identifier">step</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Minibatch step {step}/{n_steps}: mean batch "</span>
                      <span class="identifier">f</span><span class="string-literal">"inertia: {batch_inertia}"</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="bool-literal">False</span>

        <span class="comment"># Compute an Exponentially Weighted Average of the inertia to</span>
        <span class="comment"># monitor the convergence while discarding minibatch-local stochastic</span>
        <span class="comment"># variability: https://en.wikipedia.org/wiki/Moving_average</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_ewa_inertia</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_ewa_inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">batch_inertia</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_batch_size</span> <span class="arithmetic-operator">*</span> <span class="float-literal">2.0</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">n_samples</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span>
            <span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">min</span><span class="grouping">(</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_ewa_inertia</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_ewa_inertia</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="int-literal">1</span> <span class="arithmetic-operator">-</span> <span class="identifier">alpha</span><span class="grouping">)</span> <span class="arithmetic-operator">+</span> <span class="identifier">batch_inertia</span> <span class="arithmetic-operator">*</span> <span class="identifier">alpha</span><span class="grouping">)</span>

        <span class="comment"># Log progress to be able to monitor convergence</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
            <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Minibatch step {step}/{n_steps}: mean batch inertia: "</span>
                  <span class="identifier">f</span><span class="string-literal">"{batch_inertia}, ewa inertia: {self._ewa_inertia}"</span><span class="grouping">)</span>

        <span class="comment"># Early stopping based on absolute tolerance on squared change of</span>
        <span class="comment"># centers position</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_tol</span> <span class="relational-operator">&gt;</span> <span class="float-literal">0.0</span> <span class="logical-operator">and</span> <span class="identifier">centers_squared_diff</span> <span class="relational-operator">&lt;=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_tol</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Converged (small centers change) at step "</span>
                      <span class="identifier">f</span><span class="string-literal">"{step}/{n_steps}"</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="bool-literal">True</span>

        <span class="comment"># Early stopping heuristic due to lack of improvement on smoothed</span>
        <span class="comment"># inertia</span>
        <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_ewa_inertia_min</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="logical-operator">or</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_ewa_inertia</span> <span class="relational-operator">&lt;</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_ewa_inertia_min</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_no_improvement</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_ewa_inertia_min</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_ewa_inertia</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_no_improvement</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">1</span>

        <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_no_improvement</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span>
                <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_no_improvement</span> <span class="relational-operator">&gt;=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_no_improvement</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Converged (lack of improvement in inertia) at step "</span>
                      <span class="identifier">f</span><span class="string-literal">"{step}/{n_steps}"</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="bool-literal">True</span>

        <span class="keyword">return</span> <span class="bool-literal">False</span>

    <span class="keyword">def</span> <span class="identifier">_random_reassign</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Check if a random reassignment needs to be done.

        Do random reassignments each time 10 * n_clusters samples have been
        processed.

        If there are empty clusters we always want to reassign.
        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_since_last_reassign</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_batch_size</span>
        <span class="keyword">if</span> <span class="grouping">(</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_counts</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">any</span><span class="grouping">(</span><span class="grouping">)</span> <span class="logical-operator">or</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_since_last_reassign</span> <span class="relational-operator">&gt;=</span> <span class="grouping">(</span><span class="int-literal">10</span> <span class="arithmetic-operator">*</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_since_last_reassign</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
            <span class="keyword">return</span> <span class="bool-literal">True</span>
        <span class="keyword">return</span> <span class="bool-literal">False</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute the centroids on X by chunking it into mini-batches.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            Training instances to cluster. It must be noted that the data
            will be converted to C ordering, which will cause a memory copy
            if the given data is not C-contiguous.
            If a sparse matrix is passed, a copy will be made if it's not in
            CSR format.

        y : Ignored
            Not used, present here for API consistency by convention.

        sample_weight : array-like of shape (n_samples,), default=None
            The weights for each observation in X. If None, all observations
            are assigned equal weight.

            .. versionadded:: 0.20

        Returns
        -------
        self
        """</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csr'</span><span class="punctuation">,</span>
                                <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="punctuation">,</span>
                                <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'C'</span><span class="punctuation">,</span> <span class="identifier">accept_large_sparse</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_params</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_sample_weight</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_threads</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_openmp_effective_n_threads</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>

        <span class="comment"># Validate init array</span>
        <span class="identifier">init</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init</span>
        <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="string-literal">'__array__'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">init</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'C'</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_center_shape</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_mkl_vcomp</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_batch_size</span><span class="grouping">)</span>

        <span class="comment"># precompute squared norms of data points</span>
        <span class="identifier">x_squared_norms</span> <span class="arithmetic-assignment">=</span> <span class="identifier">row_norms</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">squared</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

        <span class="comment"># Validation set for the init</span>
        <span class="identifier">validation_indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span><span class="punctuation">.</span><span class="identifier">randint</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="punctuation">,</span>
                                                  <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_size</span><span class="grouping">)</span>
        <span class="identifier">X_valid</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">validation_indices</span><span class="grouping">]</span>
        <span class="identifier">sample_weight_valid</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sample_weight</span><span class="grouping">[</span><span class="identifier">validation_indices</span><span class="grouping">]</span>
        <span class="identifier">x_squared_norms_valid</span> <span class="arithmetic-assignment">=</span> <span class="identifier">x_squared_norms</span><span class="grouping">[</span><span class="identifier">validation_indices</span><span class="grouping">]</span>

        <span class="comment"># perform several inits with random subsets</span>
        <span class="identifier">best_inertia</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
        <span class="keyword">for</span> <span class="identifier">init_idx</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_init</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Init {init_idx + 1}/{self._n_init} with method {init}"</span><span class="grouping">)</span>

            <span class="comment"># Initialize the centers using only a fraction of the data as we</span>
            <span class="comment"># expect n_samples to be very large when using MiniBatchKMeans.</span>
            <span class="identifier">cluster_centers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_centroids</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="arithmetic-assignment">=</span><span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="arithmetic-assignment">=</span><span class="identifier">init</span><span class="punctuation">,</span>
                <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="punctuation">,</span> <span class="identifier">init_size</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_size</span><span class="grouping">)</span>

            <span class="comment"># Compute inertia on a validation set.</span>
            <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_labels_inertia_threadpool_limit</span><span class="grouping">(</span>
                <span class="identifier">X_valid</span><span class="punctuation">,</span> <span class="identifier">sample_weight_valid</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms_valid</span><span class="punctuation">,</span>
                <span class="identifier">cluster_centers</span><span class="punctuation">,</span> <span class="identifier">n_threads</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_threads</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Inertia for init {init_idx + 1}/{self._n_init}: "</span>
                      <span class="identifier">f</span><span class="string-literal">"{inertia}"</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">best_inertia</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="logical-operator">or</span> <span class="identifier">inertia</span> <span class="relational-operator">&lt;</span> <span class="identifier">best_inertia</span><span class="punctuation">:</span>
                <span class="identifier">init_centers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cluster_centers</span>
                <span class="identifier">best_inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">inertia</span>

        <span class="identifier">centers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">init_centers</span>
        <span class="identifier">centers_new</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty_like</span><span class="grouping">(</span><span class="identifier">centers</span><span class="grouping">)</span>

        <span class="comment"># Initialize counts</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_counts</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="comment"># Attributes to monitor the convergence</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_ewa_inertia</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_ewa_inertia_min</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_no_improvement</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>

        <span class="comment"># Initialize number of samples seen since last reassignment</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_since_last_reassign</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>

        <span class="identifier">n_steps</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_samples</span><span class="grouping">)</span> <span class="arithmetic-operator">//</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_batch_size</span>

        <span class="keyword">with</span> <span class="identifier">threadpool_limits</span><span class="grouping">(</span><span class="identifier">limits</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">user_api</span><span class="arithmetic-assignment">=</span><span class="string-literal">"blas"</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># Perform the iterative optimization until convergence</span>
            <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_steps</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="comment"># Sample a minibatch from the full dataset</span>
                <span class="identifier">minibatch_indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span><span class="punctuation">.</span><span class="identifier">randint</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="punctuation">,</span>
                                                         <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_batch_size</span><span class="grouping">)</span>

                <span class="comment"># Perform the actual update step on the minibatch data</span>
                <span class="identifier">batch_inertia</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_mini_batch_step</span><span class="grouping">(</span>
                    <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="grouping">[</span><span class="identifier">minibatch_indices</span><span class="grouping">]</span><span class="punctuation">,</span>
                    <span class="identifier">x_squared_norms</span><span class="arithmetic-assignment">=</span><span class="identifier">x_squared_norms</span><span class="grouping">[</span><span class="identifier">minibatch_indices</span><span class="grouping">]</span><span class="punctuation">,</span>
                    <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">[</span><span class="identifier">minibatch_indices</span><span class="grouping">]</span><span class="punctuation">,</span>
                    <span class="identifier">centers</span><span class="arithmetic-assignment">=</span><span class="identifier">centers</span><span class="punctuation">,</span>
                    <span class="identifier">centers_new</span><span class="arithmetic-assignment">=</span><span class="identifier">centers_new</span><span class="punctuation">,</span>
                    <span class="identifier">weight_sums</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_counts</span><span class="punctuation">,</span>
                    <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="punctuation">,</span>
                    <span class="identifier">random_reassign</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_random_reassign</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">,</span>
                    <span class="identifier">reassignment_ratio</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">reassignment_ratio</span><span class="punctuation">,</span>
                    <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">,</span>
                    <span class="identifier">n_threads</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_threads</span><span class="grouping">)</span>

                <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_tol</span> <span class="relational-operator">&gt;</span> <span class="float-literal">0.0</span><span class="punctuation">:</span>
                    <span class="identifier">centers_squared_diff</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">centers_new</span> <span class="arithmetic-operator">-</span> <span class="identifier">centers</span><span class="grouping">)</span><span class="arithmetic-operator">**</span><span class="int-literal">2</span><span class="grouping">)</span>
                <span class="keyword">else</span><span class="punctuation">:</span>
                    <span class="identifier">centers_squared_diff</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>

                <span class="identifier">centers</span><span class="punctuation">,</span> <span class="identifier">centers_new</span> <span class="arithmetic-assignment">=</span> <span class="identifier">centers_new</span><span class="punctuation">,</span> <span class="identifier">centers</span>

                <span class="comment"># Monitor convergence and do early stopping if necessary</span>
                <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_mini_batch_convergence</span><span class="grouping">(</span>
                        <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">n_steps</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">centers_squared_diff</span><span class="punctuation">,</span>
                        <span class="identifier">batch_inertia</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="keyword">break</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cluster_centers_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">centers</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_steps_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">int</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ceil</span><span class="grouping">(</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_batch_size</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">n_samples</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">compute_labels</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">labels_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">inertia_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_labels_inertia_threadpool_limit</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cluster_centers_</span><span class="punctuation">,</span>
                <span class="identifier">n_threads</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_threads</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">inertia_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_ewa_inertia</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_samples</span>

        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">partial_fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Update k means estimate on a single mini-batch X.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            Training instances to cluster. It must be noted that the data
            will be converted to C ordering, which will cause a memory copy
            if the given data is not C-contiguous.
            If a sparse matrix is passed, a copy will be made if it's not in
            CSR format.

        y : Ignored
            Not used, present here for API consistency by convention.

        sample_weight : array-like of shape (n_samples,), default=None
            The weights for each observation in X. If None, all observations
            are assigned equal weight.

        Returns
        -------
        self
        """</span>
        <span class="identifier">has_centers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">'cluster_centers_'</span><span class="grouping">)</span>

        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csr'</span><span class="punctuation">,</span>
                                <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="punctuation">,</span>
                                <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'C'</span><span class="punctuation">,</span> <span class="identifier">accept_large_sparse</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                                <span class="identifier">reset</span><span class="arithmetic-assignment">=</span><span class="logical-operator">not</span> <span class="identifier">has_centers</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">"_random_state"</span><span class="punctuation">,</span>
                                     <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_sample_weight</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_steps_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">"n_steps_"</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span>

        <span class="comment"># precompute squared norms of data points</span>
        <span class="identifier">x_squared_norms</span> <span class="arithmetic-assignment">=</span> <span class="identifier">row_norms</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">squared</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">has_centers</span><span class="punctuation">:</span>
            <span class="comment"># this instance has not been fitted yet (fit or partial_fit)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_params</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_threads</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_openmp_effective_n_threads</span><span class="grouping">(</span><span class="grouping">)</span>

            <span class="comment"># Validate init array</span>
            <span class="identifier">init</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">init</span>
            <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="string-literal">'__array__'</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">init</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">init</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'C'</span><span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_center_shape</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="grouping">)</span>

            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_mkl_vcomp</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>

            <span class="comment"># initialize the cluster centers</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cluster_centers_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_centroids</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="arithmetic-assignment">=</span><span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">init</span><span class="arithmetic-assignment">=</span><span class="identifier">init</span><span class="punctuation">,</span>
                <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_random_state</span><span class="punctuation">,</span> <span class="identifier">init_size</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_init_size</span><span class="grouping">)</span>

            <span class="comment"># Initialize counts</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_counts</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_clusters</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

            <span class="comment"># Initialize number of samples seen since last reassignment</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_since_last_reassign</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>

        <span class="keyword">with</span> <span class="identifier">threadpool_limits</span><span class="grouping">(</span><span class="identifier">limits</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">user_api</span><span class="arithmetic-assignment">=</span><span class="string-literal">"blas"</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">_mini_batch_step</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span>
                             <span class="identifier">x_squared_norms</span><span class="arithmetic-assignment">=</span><span class="identifier">x_squared_norms</span><span class="punctuation">,</span>
                             <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="punctuation">,</span>
                             <span class="identifier">centers</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cluster_centers_</span><span class="punctuation">,</span>
                             <span class="identifier">centers_new</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cluster_centers_</span><span class="punctuation">,</span>
                             <span class="identifier">weight_sums</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_counts</span><span class="punctuation">,</span>
                             <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_random_state</span><span class="punctuation">,</span>
                             <span class="identifier">random_reassign</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_random_reassign</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">,</span>
                             <span class="identifier">reassignment_ratio</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">reassignment_ratio</span><span class="punctuation">,</span>
                             <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">,</span>
                             <span class="identifier">n_threads</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_threads</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">compute_labels</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">labels_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">inertia_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_labels_inertia_threadpool_limit</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cluster_centers_</span><span class="punctuation">,</span>
                <span class="identifier">n_threads</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_threads</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_steps_</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">1</span>

        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Predict the closest cluster each sample in X belongs to.

        In the vector quantization literature, `cluster_centers_` is called
        the code book and each value returned by `predict` is the index of
        the closest code in the code book.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            New data to predict.

        sample_weight : array-like of shape (n_samples,), default=None
            The weights for each observation in X. If None, all observations
            are assigned equal weight.

        Returns
        -------
        labels : ndarray of shape (n_samples,)
            Index of the cluster each sample belongs to.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_test_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">x_squared_norms</span> <span class="arithmetic-assignment">=</span> <span class="identifier">row_norms</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">squared</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_sample_weight</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="identifier">labels</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_labels_inertia_threadpool_limit</span><span class="grouping">(</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">x_squared_norms</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cluster_centers_</span><span class="punctuation">,</span>
            <span class="identifier">n_threads</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_threads</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">labels</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span>
            <span class="string-literal">'_xfail_checks'</span><span class="punctuation">:</span> <span class="grouping">{</span>
                <span class="string-literal">'check_sample_weights_invariance'</span><span class="punctuation">:</span>
                <span class="string-literal">'zero sample_weight is not equivalent to removing samples'</span><span class="punctuation">,</span>
            <span class="grouping">}</span>
        <span class="grouping">}</span>

    </pre>
  </body>
</html>