<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""
The convex hull problem is problem of finding all the vertices of convex polygon, P of
a set of points in a plane such that all the points are either on the vertices of P or
inside P. TH convex hull problem has several applications in geometrical problems,
computer graphics and game development.

Two algorithms have been implemented for the convex hull problem here.
1. A brute-force algorithm which runs in O(n^3)
2. A divide-and-conquer algorithm which runs in O(n log(n))

There are other several other algorithms for the convex hull problem
which have not been implemented here, yet.

"""</span>

<span class="keyword">from</span> <span class="identifier">typing</span> <span class="keyword">import</span> <span class="identifier">Iterable</span><span class="punctuation">,</span> <span class="identifier">List</span><span class="punctuation">,</span> <span class="identifier">Set</span><span class="punctuation">,</span> <span class="identifier">Union</span>


<span class="keyword">class</span> <span class="identifier">Point</span><span class="punctuation">:</span>
    <span class="comment">"""
    Defines a 2-d point for use by all convex-hull algorithms.

    Parameters
    ----------
    x: an int or a float, the x-coordinate of the 2-d point
    y: an int or a float, the y-coordinate of the 2-d point

    Examples
    --------
    &gt;&gt;&gt; Point(1, 2)
    (1.0, 2.0)
    &gt;&gt;&gt; Point("1", "2")
    (1.0, 2.0)
    &gt;&gt;&gt; Point(1, 2) &gt; Point(0, 1)
    True
    &gt;&gt;&gt; Point(1, 1) == Point(1, 1)
    True
    &gt;&gt;&gt; Point(-0.5, 1) == Point(0.5, 1)
    False
    &gt;&gt;&gt; Point("pi", "e")
    Traceback (most recent call last):
        ...
    ValueError: could not convert string to float: 'pi'
    """</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">x</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">x</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">float</span><span class="grouping">(</span><span class="identifier">x</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">float</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">__eq__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">other</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">x</span> <span class="relational-operator">==</span> <span class="identifier">other</span><span class="punctuation">.</span><span class="identifier">x</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">y</span> <span class="relational-operator">==</span> <span class="identifier">other</span><span class="punctuation">.</span><span class="identifier">y</span>

    <span class="keyword">def</span> <span class="identifier">__ne__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">other</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="logical-operator">not</span> <span class="identifier">self</span> <span class="relational-operator">==</span> <span class="identifier">other</span>

    <span class="keyword">def</span> <span class="identifier">__gt__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">other</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">x</span> <span class="relational-operator">&gt;</span> <span class="identifier">other</span><span class="punctuation">.</span><span class="identifier">x</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="bool-literal">True</span>
        <span class="keyword">elif</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">x</span> <span class="relational-operator">==</span> <span class="identifier">other</span><span class="punctuation">.</span><span class="identifier">x</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">y</span> <span class="relational-operator">&gt;</span> <span class="identifier">other</span><span class="punctuation">.</span><span class="identifier">y</span>
        <span class="keyword">return</span> <span class="bool-literal">False</span>

    <span class="keyword">def</span> <span class="identifier">__lt__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">other</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="logical-operator">not</span> <span class="identifier">self</span> <span class="relational-operator">&gt;</span> <span class="identifier">other</span>

    <span class="keyword">def</span> <span class="identifier">__ge__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">other</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">x</span> <span class="relational-operator">&gt;</span> <span class="identifier">other</span><span class="punctuation">.</span><span class="identifier">x</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="bool-literal">True</span>
        <span class="keyword">elif</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">x</span> <span class="relational-operator">==</span> <span class="identifier">other</span><span class="punctuation">.</span><span class="identifier">x</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">y</span> <span class="relational-operator">&gt;=</span> <span class="identifier">other</span><span class="punctuation">.</span><span class="identifier">y</span>
        <span class="keyword">return</span> <span class="bool-literal">False</span>

    <span class="keyword">def</span> <span class="identifier">__le__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">other</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">x</span> <span class="relational-operator">&lt;</span> <span class="identifier">other</span><span class="punctuation">.</span><span class="identifier">x</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="bool-literal">True</span>
        <span class="keyword">elif</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">x</span> <span class="relational-operator">==</span> <span class="identifier">other</span><span class="punctuation">.</span><span class="identifier">x</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">y</span> <span class="relational-operator">&lt;=</span> <span class="identifier">other</span><span class="punctuation">.</span><span class="identifier">y</span>
        <span class="keyword">return</span> <span class="bool-literal">False</span>

    <span class="keyword">def</span> <span class="identifier">__repr__</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">f</span><span class="string-literal">"({self.x}, {self.y})"</span>

    <span class="keyword">def</span> <span class="identifier">__hash__</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">hash</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">x</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_construct_points</span><span class="grouping">(</span>
    <span class="identifier">list_of_tuples</span><span class="punctuation">:</span> <span class="identifier">Union</span><span class="grouping">[</span><span class="identifier">List</span><span class="grouping">[</span><span class="identifier">Point</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">List</span><span class="grouping">[</span><span class="identifier">List</span><span class="grouping">[</span><span class="identifier">float</span><span class="grouping">]</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Iterable</span><span class="grouping">[</span><span class="identifier">List</span><span class="grouping">[</span><span class="identifier">float</span><span class="grouping">]</span><span class="grouping">]</span><span class="grouping">]</span>
<span class="grouping">)</span> <span class="misc">-&gt;</span> <span class="identifier">List</span><span class="grouping">[</span><span class="identifier">Point</span><span class="grouping">]</span><span class="punctuation">:</span>
    <span class="comment">"""
    constructs a list of points from an array-like object of numbers

    Arguments
    ---------

    list_of_tuples: array-like object of type numbers. Acceptable types so far
    are lists, tuples and sets.

    Returns
    --------
    points: a list where each item is of type Point. This contains only objects
    which can be converted into a Point.

    Examples
    -------
    &gt;&gt;&gt; _construct_points([[1, 1], [2, -1], [0.3, 4]])
    [(1.0, 1.0), (2.0, -1.0), (0.3, 4.0)]
    &gt;&gt;&gt; _construct_points([1, 2])
    Ignoring deformed point 1. All points must have at least 2 coordinates.
    Ignoring deformed point 2. All points must have at least 2 coordinates.
    []
    &gt;&gt;&gt; _construct_points([])
    []
    &gt;&gt;&gt; _construct_points(None)
    []
    """</span>

    <span class="identifier">points</span><span class="punctuation">:</span> <span class="identifier">List</span><span class="grouping">[</span><span class="identifier">Point</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
    <span class="keyword">if</span> <span class="identifier">list_of_tuples</span><span class="punctuation">:</span>
        <span class="keyword">for</span> <span class="identifier">p</span> <span class="relational-operator">in</span> <span class="identifier">list_of_tuples</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">p</span><span class="punctuation">,</span> <span class="identifier">Point</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">points</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">p</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="keyword">try</span><span class="punctuation">:</span>
                    <span class="identifier">points</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">Point</span><span class="grouping">(</span><span class="identifier">p</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">p</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>
                <span class="keyword">except</span> <span class="grouping">(</span><span class="identifier">IndexError</span><span class="punctuation">,</span> <span class="identifier">TypeError</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">print</span><span class="grouping">(</span>
                        <span class="identifier">f</span><span class="string-literal">"Ignoring deformed point {p}. All points"</span>
                        <span class="string-literal">" must have at least 2 coordinates."</span>
                    <span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">points</span>


<span class="keyword">def</span> <span class="identifier">_validate_input</span><span class="grouping">(</span><span class="identifier">points</span><span class="punctuation">:</span> <span class="identifier">Union</span><span class="grouping">[</span><span class="identifier">List</span><span class="grouping">[</span><span class="identifier">Point</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">List</span><span class="grouping">[</span><span class="identifier">List</span><span class="grouping">[</span><span class="identifier">float</span><span class="grouping">]</span><span class="grouping">]</span><span class="grouping">]</span><span class="grouping">)</span> <span class="misc">-&gt;</span> <span class="identifier">List</span><span class="grouping">[</span><span class="identifier">Point</span><span class="grouping">]</span><span class="punctuation">:</span>
    <span class="comment">"""
    validates an input instance before a convex-hull algorithms uses it

    Parameters
    ---------
    points: array-like, the 2d points to validate before using with
    a convex-hull algorithm. The elements of points must be either lists, tuples or
    Points.

    Returns
    -------
    points: array_like, an iterable of all well-defined Points constructed passed in.


    Exception
    ---------
    ValueError: if points is empty or None, or if a wrong data structure like a scalar
                 is passed

    TypeError: if an iterable but non-indexable object (eg. dictionary) is passed.
                The exception to this a set which we'll convert to a list before using


    Examples
    -------
    &gt;&gt;&gt; _validate_input([[1, 2]])
    [(1.0, 2.0)]
    &gt;&gt;&gt; _validate_input([(1, 2)])
    [(1.0, 2.0)]
    &gt;&gt;&gt; _validate_input([Point(2, 1), Point(-1, 2)])
    [(2.0, 1.0), (-1.0, 2.0)]
    &gt;&gt;&gt; _validate_input([])
    Traceback (most recent call last):
        ...
    ValueError: Expecting a list of points but got []
    &gt;&gt;&gt; _validate_input(1)
    Traceback (most recent call last):
        ...
    ValueError: Expecting an iterable object but got an non-iterable type 1
    """</span>

    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">points</span><span class="punctuation">,</span> <span class="string-literal">"__iter__"</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
            <span class="identifier">f</span><span class="string-literal">"Expecting an iterable object but got an non-iterable type {points}"</span>
        <span class="grouping">)</span>

    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">points</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="identifier">f</span><span class="string-literal">"Expecting a list of points but got {points}"</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">_construct_points</span><span class="grouping">(</span><span class="identifier">points</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_det</span><span class="grouping">(</span><span class="identifier">a</span><span class="punctuation">:</span> <span class="identifier">Point</span><span class="punctuation">,</span> <span class="identifier">b</span><span class="punctuation">:</span> <span class="identifier">Point</span><span class="punctuation">,</span> <span class="identifier">c</span><span class="punctuation">:</span> <span class="identifier">Point</span><span class="grouping">)</span> <span class="misc">-&gt;</span> <span class="identifier">float</span><span class="punctuation">:</span>
    <span class="comment">"""
    Computes the sign perpendicular distance of a 2d point c from a line segment
    ab. The sign indicates the direction of c relative to ab.
    A Positive value means c is above ab (to the left), while a negative value
    means c is below ab (to the right). 0 means all three points are on a straight line.

    As a side note, 0.5 * abs|det| is the area of triangle abc

    Parameters
    ----------
    a: point, the point on the left end of line segment ab
    b: point, the point on the right end of line segment ab
    c: point, the point for which the direction and location is desired.

    Returns
    --------
    det: float, abs(det) is the distance of c from ab. The sign
    indicates which side of line segment ab c is. det is computed as
    (a_xb_y + c_xa_y + b_xc_y) - (a_yb_x + c_ya_x + b_yc_x)

    Examples
    ----------
    &gt;&gt;&gt; _det(Point(1, 1), Point(1, 2), Point(1, 5))
    0.0
    &gt;&gt;&gt; _det(Point(0, 0), Point(10, 0), Point(0, 10))
    100.0
    &gt;&gt;&gt; _det(Point(0, 0), Point(10, 0), Point(0, -10))
    -100.0
    """</span>

    <span class="identifier">det</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">a</span><span class="punctuation">.</span><span class="identifier">x</span> <span class="arithmetic-operator">*</span> <span class="identifier">b</span><span class="punctuation">.</span><span class="identifier">y</span> <span class="arithmetic-operator">+</span> <span class="identifier">b</span><span class="punctuation">.</span><span class="identifier">x</span> <span class="arithmetic-operator">*</span> <span class="identifier">c</span><span class="punctuation">.</span><span class="identifier">y</span> <span class="arithmetic-operator">+</span> <span class="identifier">c</span><span class="punctuation">.</span><span class="identifier">x</span> <span class="arithmetic-operator">*</span> <span class="identifier">a</span><span class="punctuation">.</span><span class="identifier">y</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="grouping">(</span><span class="identifier">a</span><span class="punctuation">.</span><span class="identifier">y</span> <span class="arithmetic-operator">*</span> <span class="identifier">b</span><span class="punctuation">.</span><span class="identifier">x</span> <span class="arithmetic-operator">+</span> <span class="identifier">b</span><span class="punctuation">.</span><span class="identifier">y</span> <span class="arithmetic-operator">*</span> <span class="identifier">c</span><span class="punctuation">.</span><span class="identifier">x</span> <span class="arithmetic-operator">+</span> <span class="identifier">c</span><span class="punctuation">.</span><span class="identifier">y</span> <span class="arithmetic-operator">*</span> <span class="identifier">a</span><span class="punctuation">.</span><span class="identifier">x</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">det</span>


<span class="keyword">def</span> <span class="identifier">convex_hull_bf</span><span class="grouping">(</span><span class="identifier">points</span><span class="punctuation">:</span> <span class="identifier">List</span><span class="grouping">[</span><span class="identifier">Point</span><span class="grouping">]</span><span class="grouping">)</span> <span class="misc">-&gt;</span> <span class="identifier">List</span><span class="grouping">[</span><span class="identifier">Point</span><span class="grouping">]</span><span class="punctuation">:</span>
    <span class="comment">"""
    Constructs the convex hull of a set of 2D points using a brute force algorithm.
    The algorithm basically considers all combinations of points (i, j) and uses the
    definition of convexity to determine whether (i, j) is part of the convex hull or
    not.  (i, j) is part of the convex hull if and only iff there are no points on both
    sides of the line segment connecting the ij, and there is no point k such that k is
    on either end of the ij.

    Runtime: O(n^3) - definitely horrible

    Parameters
    ---------
    points: array-like of object of Points, lists or tuples.
    The set of  2d points for which the convex-hull is needed

    Returns
    ------
    convex_set: list, the convex-hull of points sorted in non-decreasing order.

    See Also
    --------
    convex_hull_recursive,

     Examples
     ---------
     &gt;&gt;&gt; convex_hull_bf([[0, 0], [1, 0], [10, 1]])
     [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]
     &gt;&gt;&gt; convex_hull_bf([[0, 0], [1, 0], [10, 0]])
     [(0.0, 0.0), (10.0, 0.0)]
     &gt;&gt;&gt; convex_hull_bf([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],
     ...                 [-0.75, 1]])
     [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]
     &gt;&gt;&gt; convex_hull_bf([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),
     ...                 (2, -1), (2, -4), (1, -3)])
     [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]
    """</span>

    <span class="identifier">points</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sorted</span><span class="grouping">(</span><span class="identifier">_validate_input</span><span class="grouping">(</span><span class="identifier">points</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="identifier">n</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">points</span><span class="grouping">)</span>
    <span class="identifier">convex_set</span> <span class="arithmetic-assignment">=</span> <span class="identifier">set</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">for</span> <span class="identifier">j</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">n</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">points_left_of_ij</span> <span class="arithmetic-assignment">=</span> <span class="identifier">points_right_of_ij</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
            <span class="identifier">ij_part_of_convex_hull</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>
            <span class="keyword">for</span> <span class="identifier">k</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">if</span> <span class="identifier">k</span> <span class="relational-operator">!=</span> <span class="identifier">i</span> <span class="logical-operator">and</span> <span class="identifier">k</span> <span class="relational-operator">!=</span> <span class="identifier">j</span><span class="punctuation">:</span>
                    <span class="identifier">det_k</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_det</span><span class="grouping">(</span><span class="identifier">points</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">points</span><span class="grouping">[</span><span class="identifier">j</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">points</span><span class="grouping">[</span><span class="identifier">k</span><span class="grouping">]</span><span class="grouping">)</span>

                    <span class="keyword">if</span> <span class="identifier">det_k</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
                        <span class="identifier">points_left_of_ij</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>
                    <span class="keyword">elif</span> <span class="identifier">det_k</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
                        <span class="identifier">points_right_of_ij</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>
                    <span class="keyword">else</span><span class="punctuation">:</span>
                        <span class="comment"># point[i], point[j], point[k] all lie on a straight line</span>
                        <span class="comment"># if point[k] is to the left of point[i] or it's to the</span>
                        <span class="comment"># right of point[j], then point[i], point[j] cannot be</span>
                        <span class="comment"># part of the convex hull of A</span>
                        <span class="keyword">if</span> <span class="identifier">points</span><span class="grouping">[</span><span class="identifier">k</span><span class="grouping">]</span> <span class="relational-operator">&lt;</span> <span class="identifier">points</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span> <span class="logical-operator">or</span> <span class="identifier">points</span><span class="grouping">[</span><span class="identifier">k</span><span class="grouping">]</span> <span class="relational-operator">&gt;</span> <span class="identifier">points</span><span class="grouping">[</span><span class="identifier">j</span><span class="grouping">]</span><span class="punctuation">:</span>
                            <span class="identifier">ij_part_of_convex_hull</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
                            <span class="keyword">break</span>

                <span class="keyword">if</span> <span class="identifier">points_left_of_ij</span> <span class="logical-operator">and</span> <span class="identifier">points_right_of_ij</span><span class="punctuation">:</span>
                    <span class="identifier">ij_part_of_convex_hull</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
                    <span class="keyword">break</span>

            <span class="keyword">if</span> <span class="identifier">ij_part_of_convex_hull</span><span class="punctuation">:</span>
                <span class="identifier">convex_set</span><span class="punctuation">.</span><span class="identifier">update</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">points</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">points</span><span class="grouping">[</span><span class="identifier">j</span><span class="grouping">]</span><span class="grouping">]</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">sorted</span><span class="grouping">(</span><span class="identifier">convex_set</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">convex_hull_recursive</span><span class="grouping">(</span><span class="identifier">points</span><span class="punctuation">:</span> <span class="identifier">List</span><span class="grouping">[</span><span class="identifier">Point</span><span class="grouping">]</span><span class="grouping">)</span> <span class="misc">-&gt;</span> <span class="identifier">List</span><span class="grouping">[</span><span class="identifier">Point</span><span class="grouping">]</span><span class="punctuation">:</span>
    <span class="comment">"""
    Constructs the convex hull of a set of 2D points using a divide-and-conquer strategy
    The algorithm exploits the geometric properties of the problem by repeatedly
    partitioning the set of points into smaller hulls, and finding the convex hull of
    these smaller hulls.  The union of the convex hull from smaller hulls is the
    solution to the convex hull of the larger problem.

    Parameter
    ---------
    points: array-like of object of Points, lists or tuples.
    The set of  2d points for which the convex-hull is needed

    Runtime: O(n log n)

    Returns
    -------
    convex_set: list, the convex-hull of points sorted in non-decreasing order.

    Examples
    ---------
    &gt;&gt;&gt; convex_hull_recursive([[0, 0], [1, 0], [10, 1]])
    [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]
    &gt;&gt;&gt; convex_hull_recursive([[0, 0], [1, 0], [10, 0]])
    [(0.0, 0.0), (10.0, 0.0)]
    &gt;&gt;&gt; convex_hull_recursive([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],
    ...                        [-0.75, 1]])
    [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]
    &gt;&gt;&gt; convex_hull_recursive([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),
    ...                        (2, -1), (2, -4), (1, -3)])
    [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]

    """</span>
    <span class="identifier">points</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sorted</span><span class="grouping">(</span><span class="identifier">_validate_input</span><span class="grouping">(</span><span class="identifier">points</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="identifier">n</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">points</span><span class="grouping">)</span>

    <span class="comment"># divide all the points into an upper hull and a lower hull</span>
    <span class="comment"># the left most point and the right most point are definitely</span>
    <span class="comment"># members of the convex hull by definition.</span>
    <span class="comment"># use these two anchors to divide all the points into two hulls,</span>
    <span class="comment"># an upper hull and a lower hull.</span>

    <span class="comment"># all points to the left (above) the line joining the extreme points belong to the</span>
    <span class="comment"># upper hull</span>
    <span class="comment"># all points to the right (below) the line joining the extreme points below to the</span>
    <span class="comment"># lower hull</span>
    <span class="comment"># ignore all points on the line joining the extreme points since they cannot be</span>
    <span class="comment"># part of the convex hull</span>

    <span class="identifier">left_most_point</span> <span class="arithmetic-assignment">=</span> <span class="identifier">points</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
    <span class="identifier">right_most_point</span> <span class="arithmetic-assignment">=</span> <span class="identifier">points</span><span class="grouping">[</span><span class="identifier">n</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">]</span>

    <span class="identifier">convex_set</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="identifier">left_most_point</span><span class="punctuation">,</span> <span class="identifier">right_most_point</span><span class="grouping">}</span>
    <span class="identifier">upper_hull</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
    <span class="identifier">lower_hull</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>

    <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">n</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">det</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_det</span><span class="grouping">(</span><span class="identifier">left_most_point</span><span class="punctuation">,</span> <span class="identifier">right_most_point</span><span class="punctuation">,</span> <span class="identifier">points</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">det</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="identifier">upper_hull</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">points</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">det</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="identifier">lower_hull</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">points</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">)</span>

    <span class="identifier">_construct_hull</span><span class="grouping">(</span><span class="identifier">upper_hull</span><span class="punctuation">,</span> <span class="identifier">left_most_point</span><span class="punctuation">,</span> <span class="identifier">right_most_point</span><span class="punctuation">,</span> <span class="identifier">convex_set</span><span class="grouping">)</span>
    <span class="identifier">_construct_hull</span><span class="grouping">(</span><span class="identifier">lower_hull</span><span class="punctuation">,</span> <span class="identifier">right_most_point</span><span class="punctuation">,</span> <span class="identifier">left_most_point</span><span class="punctuation">,</span> <span class="identifier">convex_set</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">sorted</span><span class="grouping">(</span><span class="identifier">convex_set</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_construct_hull</span><span class="grouping">(</span>
    <span class="identifier">points</span><span class="punctuation">:</span> <span class="identifier">List</span><span class="grouping">[</span><span class="identifier">Point</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">left</span><span class="punctuation">:</span> <span class="identifier">Point</span><span class="punctuation">,</span> <span class="identifier">right</span><span class="punctuation">:</span> <span class="identifier">Point</span><span class="punctuation">,</span> <span class="identifier">convex_set</span><span class="punctuation">:</span> <span class="identifier">Set</span><span class="grouping">[</span><span class="identifier">Point</span><span class="grouping">]</span>
<span class="grouping">)</span> <span class="misc">-&gt;</span> <span class="none-literal">None</span><span class="punctuation">:</span>
    <span class="comment">"""

    Parameters
    ---------
    points: list or None, the hull of points from which to choose the next convex-hull
        point
    left: Point, the point to the left  of line segment joining left and right
    right: The point to the right of the line segment joining left and right
    convex_set: set, the current convex-hull. The state of convex-set gets updated by
        this function

    Note
    ----
    For the line segment 'ab', 'a' is on the left and 'b' on the right.
    but the reverse is true for the line segment 'ba'.

    Returns
    -------
    Nothing, only updates the state of convex-set
    """</span>
    <span class="keyword">if</span> <span class="identifier">points</span><span class="punctuation">:</span>
        <span class="identifier">extreme_point</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
        <span class="identifier">extreme_point_distance</span> <span class="arithmetic-assignment">=</span> <span class="identifier">float</span><span class="grouping">(</span><span class="string-literal">"-inf"</span><span class="grouping">)</span>
        <span class="identifier">candidate_points</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>

        <span class="keyword">for</span> <span class="identifier">p</span> <span class="relational-operator">in</span> <span class="identifier">points</span><span class="punctuation">:</span>
            <span class="identifier">det</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_det</span><span class="grouping">(</span><span class="identifier">left</span><span class="punctuation">,</span> <span class="identifier">right</span><span class="punctuation">,</span> <span class="identifier">p</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="identifier">det</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
                <span class="identifier">candidate_points</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">p</span><span class="grouping">)</span>

                <span class="keyword">if</span> <span class="identifier">det</span> <span class="relational-operator">&gt;</span> <span class="identifier">extreme_point_distance</span><span class="punctuation">:</span>
                    <span class="identifier">extreme_point_distance</span> <span class="arithmetic-assignment">=</span> <span class="identifier">det</span>
                    <span class="identifier">extreme_point</span> <span class="arithmetic-assignment">=</span> <span class="identifier">p</span>

        <span class="keyword">if</span> <span class="identifier">extreme_point</span><span class="punctuation">:</span>
            <span class="identifier">_construct_hull</span><span class="grouping">(</span><span class="identifier">candidate_points</span><span class="punctuation">,</span> <span class="identifier">left</span><span class="punctuation">,</span> <span class="identifier">extreme_point</span><span class="punctuation">,</span> <span class="identifier">convex_set</span><span class="grouping">)</span>
            <span class="identifier">convex_set</span><span class="punctuation">.</span><span class="identifier">add</span><span class="grouping">(</span><span class="identifier">extreme_point</span><span class="grouping">)</span>
            <span class="identifier">_construct_hull</span><span class="grouping">(</span><span class="identifier">candidate_points</span><span class="punctuation">,</span> <span class="identifier">extreme_point</span><span class="punctuation">,</span> <span class="identifier">right</span><span class="punctuation">,</span> <span class="identifier">convex_set</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">convex_hull_melkman</span><span class="grouping">(</span><span class="identifier">points</span><span class="punctuation">:</span> <span class="identifier">List</span><span class="grouping">[</span><span class="identifier">Point</span><span class="grouping">]</span><span class="grouping">)</span> <span class="misc">-&gt;</span> <span class="identifier">List</span><span class="grouping">[</span><span class="identifier">Point</span><span class="grouping">]</span><span class="punctuation">:</span>
    <span class="comment">"""
    Constructs the convex hull of a set of 2D points using the melkman algorithm.
    The algorithm works by iteratively inserting points of a simple polygonal chain
    (meaning that no line segments between two consecutive points cross each other).
    Sorting the points yields such a polygonal chain.

    For a detailed description, see http://cgm.cs.mcgill.ca/~athens/cs601/Melkman.html

    Runtime: O(n log n) - O(n) if points are already sorted in the input

    Parameters
    ---------
    points: array-like of object of Points, lists or tuples.
    The set of 2d points for which the convex-hull is needed

    Returns
    ------
    convex_set: list, the convex-hull of points sorted in non-decreasing order.

    See Also
    --------

    Examples
    ---------
    &gt;&gt;&gt; convex_hull_melkman([[0, 0], [1, 0], [10, 1]])
    [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]
    &gt;&gt;&gt; convex_hull_melkman([[0, 0], [1, 0], [10, 0]])
    [(0.0, 0.0), (10.0, 0.0)]
    &gt;&gt;&gt; convex_hull_melkman([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],
    ...                 [-0.75, 1]])
    [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]
    &gt;&gt;&gt; convex_hull_melkman([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),
    ...                 (2, -1), (2, -4), (1, -3)])
    [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]
    """</span>
    <span class="identifier">points</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sorted</span><span class="grouping">(</span><span class="identifier">_validate_input</span><span class="grouping">(</span><span class="identifier">points</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="identifier">n</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">points</span><span class="grouping">)</span>

    <span class="identifier">convex_hull</span> <span class="arithmetic-assignment">=</span> <span class="identifier">points</span><span class="grouping">[</span><span class="punctuation">:</span><span class="int-literal">2</span><span class="grouping">]</span>
    <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="int-literal">2</span><span class="punctuation">,</span> <span class="identifier">n</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">det</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_det</span><span class="grouping">(</span><span class="identifier">convex_hull</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">convex_hull</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">points</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">det</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="identifier">convex_hull</span><span class="punctuation">.</span><span class="identifier">insert</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">points</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="keyword">break</span>
        <span class="keyword">elif</span> <span class="identifier">det</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="identifier">convex_hull</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">points</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="keyword">break</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">convex_hull</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">points</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span>
    <span class="identifier">i</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">1</span>

    <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">n</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="grouping">(</span>
            <span class="identifier">_det</span><span class="grouping">(</span><span class="identifier">convex_hull</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">convex_hull</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">points</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span>
            <span class="logical-operator">and</span> <span class="identifier">_det</span><span class="grouping">(</span><span class="identifier">convex_hull</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">convex_hull</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">points</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span>
        <span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># The point lies within the convex hull</span>
            <span class="keyword">continue</span>

        <span class="identifier">convex_hull</span><span class="punctuation">.</span><span class="identifier">insert</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">points</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="identifier">convex_hull</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">points</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="keyword">while</span> <span class="identifier">_det</span><span class="grouping">(</span><span class="identifier">convex_hull</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">convex_hull</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">convex_hull</span><span class="grouping">[</span><span class="int-literal">2</span><span class="grouping">]</span><span class="grouping">)</span> <span class="relational-operator">&gt;=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">del</span> <span class="identifier">convex_hull</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>
        <span class="keyword">while</span> <span class="identifier">_det</span><span class="grouping">(</span><span class="identifier">convex_hull</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">convex_hull</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">2</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">convex_hull</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">3</span><span class="grouping">]</span><span class="grouping">)</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">del</span> <span class="identifier">convex_hull</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">2</span><span class="grouping">]</span>

    <span class="comment"># `convex_hull` is contains the convex hull in circular order</span>
    <span class="keyword">return</span> <span class="identifier">sorted</span><span class="grouping">(</span><span class="identifier">convex_hull</span><span class="grouping">[</span><span class="int-literal">1</span><span class="punctuation">:</span><span class="grouping">]</span> <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">convex_hull</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="int-literal">3</span> <span class="keyword">else</span> <span class="identifier">convex_hull</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">main</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="identifier">points</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span>
        <span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="int-literal">3</span><span class="grouping">)</span><span class="punctuation">,</span>
        <span class="grouping">(</span><span class="int-literal">2</span><span class="punctuation">,</span> <span class="int-literal">2</span><span class="grouping">)</span><span class="punctuation">,</span>
        <span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">,</span>
        <span class="grouping">(</span><span class="int-literal">2</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">,</span>
        <span class="grouping">(</span><span class="int-literal">3</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">,</span>
        <span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">,</span>
        <span class="grouping">(</span><span class="int-literal">3</span><span class="punctuation">,</span> <span class="int-literal">3</span><span class="grouping">)</span><span class="punctuation">,</span>
        <span class="grouping">(</span><span class="int-literal">2</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">,</span>
        <span class="grouping">(</span><span class="int-literal">2</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">4</span><span class="grouping">)</span><span class="punctuation">,</span>
        <span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">3</span><span class="grouping">)</span><span class="punctuation">,</span>
    <span class="grouping">]</span>
    <span class="comment"># the convex set of points is</span>
    <span class="comment"># [(0, 0), (0, 3), (1, -3), (2, -4), (3, 0), (3, 3)]</span>
    <span class="identifier">results_bf</span> <span class="arithmetic-assignment">=</span> <span class="identifier">convex_hull_bf</span><span class="grouping">(</span><span class="identifier">points</span><span class="grouping">)</span>

    <span class="identifier">results_recursive</span> <span class="arithmetic-assignment">=</span> <span class="identifier">convex_hull_recursive</span><span class="grouping">(</span><span class="identifier">points</span><span class="grouping">)</span>
    <span class="keyword">assert</span> <span class="identifier">results_bf</span> <span class="relational-operator">==</span> <span class="identifier">results_recursive</span>

    <span class="identifier">results_melkman</span> <span class="arithmetic-assignment">=</span> <span class="identifier">convex_hull_melkman</span><span class="grouping">(</span><span class="identifier">points</span><span class="grouping">)</span>
    <span class="keyword">assert</span> <span class="identifier">results_bf</span> <span class="relational-operator">==</span> <span class="identifier">results_melkman</span>

    <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">results_bf</span><span class="grouping">)</span>


<span class="keyword">if</span> <span class="identifier">__name__</span> <span class="relational-operator">==</span> <span class="string-literal">"__main__"</span><span class="punctuation">:</span>
    <span class="identifier">main</span><span class="grouping">(</span><span class="grouping">)</span>

    </pre>
  </body>
</html>