<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""
The :mod:`sklearn.pipeline` module implements utilities to build a composite
estimator, as a chain of transforms and estimators.
"""</span>
<span class="comment"># Author: Edouard Duchesnay</span>
<span class="comment">#         Gael Varoquaux</span>
<span class="comment">#         Virgile Fritsch</span>
<span class="comment">#         Alexandre Gramfort</span>
<span class="comment">#         Lars Buitinck</span>
<span class="comment"># License: BSD</span>

<span class="keyword">from</span> <span class="identifier">collections</span> <span class="keyword">import</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">d</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">t</span>
<span class="keyword">from</span> <span class="identifier">itertools</span> <span class="keyword">import</span> <span class="identifier">islice</span>

<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">from</span> <span class="identifier">scipy</span> <span class="keyword">import</span> <span class="identifier">sparse</span>
<span class="keyword">from</span> <span class="identifier">joblib</span> <span class="keyword">import</span> <span class="identifier">Parallel</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">clone</span><span class="punctuation">,</span> <span class="identifier">TransformerMixin</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">_estimator_html_repr</span> <span class="keyword">import</span> <span class="identifier">_VisualBlock</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">metaestimators</span> <span class="keyword">import</span> <span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="grouping">(</span>
    <span class="identifier">Bunch</span><span class="punctuation">,</span>
    <span class="identifier">_print_elapsed_time</span><span class="punctuation">,</span>
<span class="grouping">)</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">deprecation</span> <span class="keyword">import</span> <span class="identifier">deprecated</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">_tags</span> <span class="keyword">import</span> <span class="identifier">_safe_tags</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_memory</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">fixes</span> <span class="keyword">import</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">metaestimators</span> <span class="keyword">import</span> <span class="identifier">_BaseComposition</span>

<span class="identifier">__all__</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="string-literal">'Pipeline', 'FeatureUnion', 'make_pipeline', 'make_union'</span><span class="grouping">]</span>


<span class="keyword">class</span> <span class="identifier">Pipeline</span><span class="grouping">(</span><span class="identifier">_BaseComposition</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""
    Pipeline of transforms with a final estimator.

    Sequentially apply a list of transforms and a final estimator.
    Intermediate steps of the pipeline must be 'transforms', that is, they
    must implement fit and transform methods.
    The final estimator only needs to implement fit.
    The transformers in the pipeline can be cached using ``memory`` argument.

    The purpose of the pipeline is to assemble several steps that can be
    cross-validated together while setting different parameters.
    For this, it enables setting parameters of the various steps using their
    names and the parameter name separated by a '__', as in the example below.
    A step's estimator may be replaced entirely by setting the parameter
    with its name to another estimator, or a transformer removed by setting
    it to 'passthrough' or ``None``.

    Read more in the :ref:`User Guide &lt;pipeline&gt;`.

    .. versionadded:: 0.5

    Parameters
    ----------
    steps : list
        List of (name, transform) tuples (implementing fit/transform) that are
        chained, in the order in which they are chained, with the last object
        an estimator.

    memory : str or object with the joblib.Memory interface, default=None
        Used to cache the fitted transformers of the pipeline. By default,
        no caching is performed. If a string is given, it is the path to
        the caching directory. Enabling caching triggers a clone of
        the transformers before fitting. Therefore, the transformer
        instance given to the pipeline cannot be inspected
        directly. Use the attribute ``named_steps`` or ``steps`` to
        inspect estimators within the pipeline. Caching the
        transformers is advantageous when fitting is time consuming.

    verbose : bool, default=False
        If True, the time elapsed while fitting each step will be printed as it
        is completed.

    Attributes
    ----------
    named_steps : :class:`~sklearn.utils.Bunch`
        Dictionary-like object, with the following attributes.
        Read-only attribute to access any step parameter by user given name.
        Keys are step names and values are steps parameters.

    See Also
    --------
    make_pipeline : Convenience function for simplified pipeline construction.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.svm import SVC
    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler
    &gt;&gt;&gt; from sklearn.datasets import make_classification
    &gt;&gt;&gt; from sklearn.model_selection import train_test_split
    &gt;&gt;&gt; from sklearn.pipeline import Pipeline
    &gt;&gt;&gt; X, y = make_classification(random_state=0)
    &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(X, y,
    ...                                                     random_state=0)
    &gt;&gt;&gt; pipe = Pipeline([('scaler', StandardScaler()), ('svc', SVC())])
    &gt;&gt;&gt; # The pipeline can be used as any other estimator
    &gt;&gt;&gt; # and avoids leaking the test set into the train set
    &gt;&gt;&gt; pipe.fit(X_train, y_train)
    Pipeline(steps=[('scaler', StandardScaler()), ('svc', SVC())])
    &gt;&gt;&gt; pipe.score(X_test, y_test)
    0.88
    """</span>

    <span class="comment"># BaseEstimator interface</span>
    <span class="identifier">_required_parameters</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="string-literal">'steps'</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">steps</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">memory</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span> <span class="arithmetic-assignment">=</span> <span class="identifier">steps</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">memory</span> <span class="arithmetic-assignment">=</span> <span class="identifier">memory</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">verbose</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_steps</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">get_params</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">deep</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Get parameters for this estimator.

        Returns the parameters given in the constructor as well as the
        estimators contained within the `steps` of the `Pipeline`.

        Parameters
        ----------
        deep : bool, default=True
            If True, will return the parameters for this estimator and
            contained subobjects that are estimators.

        Returns
        -------
        params : mapping of string to any
            Parameter names mapped to their values.
        """</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_get_params</span><span class="grouping">(</span><span class="string-literal">'steps'</span><span class="punctuation">,</span> <span class="identifier">deep</span><span class="arithmetic-assignment">=</span><span class="identifier">deep</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">set_params</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">kwargs</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Set the parameters of this estimator.

        Valid parameter keys can be listed with ``get_params()``. Note that
        you can directly set the parameters of the estimators contained in
        `steps`.

        Returns
        -------
        self
        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_set_params</span><span class="grouping">(</span><span class="string-literal">'steps'</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">kwargs</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">_validate_steps</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">names</span><span class="punctuation">,</span> <span class="identifier">estimators</span> <span class="arithmetic-assignment">=</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">)</span>

        <span class="comment"># validate names</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_names</span><span class="grouping">(</span><span class="identifier">names</span><span class="grouping">)</span>

        <span class="comment"># validate estimators</span>
        <span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimators</span><span class="grouping">[</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span>
        <span class="identifier">estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimators</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span>

        <span class="keyword">for</span> <span class="identifier">t</span> <span class="relational-operator">in</span> <span class="identifier">transformers</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">t</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="logical-operator">or</span> <span class="identifier">t</span> <span class="relational-operator">==</span> <span class="string-literal">'passthrough'</span><span class="punctuation">:</span>
                <span class="keyword">continue</span>
            <span class="keyword">if</span> <span class="grouping">(</span><span class="logical-operator">not</span> <span class="grouping">(</span><span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">t</span><span class="punctuation">,</span> <span class="string-literal">"fit") or hasattr(t, "fit_transform"</span><span class="grouping">)</span><span class="grouping">)</span> <span class="logical-operator">or</span> <span class="logical-operator">not</span>
                    <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">t</span><span class="punctuation">,</span> <span class="string-literal">"transform"</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">"All intermediate steps should be "</span>
                                <span class="string-literal">"transformers and implement fit and transform "</span>
                                <span class="string-literal">"or be the string 'passthrough' "</span>
                                <span class="string-literal">"'%s' (type %s) doesn't"</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">t</span><span class="punctuation">,</span> <span class="identifier">type</span><span class="grouping">(</span><span class="identifier">t</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="comment"># We allow last estimator to be None as an identity transformation</span>
        <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">estimator</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">estimator</span> <span class="relational-operator">!=</span> <span class="string-literal">'passthrough'</span>
                <span class="logical-operator">and</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="string-literal">"fit"</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span>
                <span class="string-literal">"Last step of Pipeline should implement fit "</span>
                <span class="string-literal">"or be the string 'passthrough'. "</span>
                <span class="string-literal">"'%s' (type %s) doesn't"</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">type</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_iter</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="invalid">w</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">a</span><span class="invalid">l</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">filter_passthrough</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Generate (idx, (name, trans)) tuples from self.steps

        When filter_passthrough is True, 'passthrough' and None transformers
        are filtered out.
        """</span>
        <span class="identifier">stop</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="invalid">w</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">a</span><span class="invalid">l</span><span class="punctuation">:</span>
            <span class="identifier">stop</span> <span class="arithmetic-assignment">-=</span> <span class="int-literal">1</span>

        <span class="keyword">for</span> <span class="identifier">idx</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="grouping">)</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">islice</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">stop</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">filter_passthrough</span><span class="punctuation">:</span>
                <span class="keyword">yield</span> <span class="identifier">idx</span><span class="punctuation">,</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span>
            <span class="keyword">elif</span> <span class="identifier">trans</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">trans</span> <span class="relational-operator">!=</span> <span class="string-literal">'passthrough'</span><span class="punctuation">:</span>
                <span class="keyword">yield</span> <span class="identifier">idx</span><span class="punctuation">,</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span>

    <span class="keyword">def</span> <span class="identifier">__len__</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Returns the length of the Pipeline
        """</span>
        <span class="keyword">return</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">__getitem__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">ind</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Returns a sub-pipeline or a single esimtator in the pipeline

        Indexing with an integer will return an estimator; using a slice
        returns another Pipeline instance which copies a slice of this
        Pipeline. This copy is shallow: modifying (or fitting) estimators in
        the sub-pipeline will affect the larger pipeline and vice-versa.
        However, replacing a value in `step` will not affect a copy.
        """</span>
        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">ind</span><span class="punctuation">,</span> <span class="identifier">slice</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">ind</span><span class="punctuation">.</span><span class="identifier">step</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Pipeline slicing only supports a step of 1"</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__class__</span><span class="grouping">(</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="identifier">ind</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">memory</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">memory</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span>
            <span class="grouping">)</span>
        <span class="keyword">try</span><span class="punctuation">:</span>
            <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">est</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="identifier">ind</span><span class="grouping">]</span>
        <span class="keyword">except</span> <span class="identifier">TypeError</span><span class="punctuation">:</span>
            <span class="comment"># Not an int, try get step by name</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">named_steps</span><span class="grouping">[</span><span class="identifier">ind</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="identifier">est</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">_estimator_type</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">_estimator_type</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">named_steps</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># Use Bunch object to improve autocomplete</span>
        <span class="keyword">return</span> <span class="identifier">Bunch</span><span class="grouping">(</span><span class="arithmetic-operator">**</span><span class="identifier">dict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">_final_estimator</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="string-literal">'passthrough'</span> <span class="keyword">if</span> <span class="identifier">estimator</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="keyword">else</span> <span class="identifier">estimator</span>

    <span class="keyword">def</span> <span class="identifier">_log_message</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">step_idx</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="none-literal">None</span>
        <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="identifier">step_idx</span><span class="grouping">]</span>

        <span class="keyword">return</span> <span class="string-literal">'(step %d of %d) Processing %s'</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">step_idx</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">,</span>
                                                  <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">)</span><span class="punctuation">,</span>
                                                  <span class="identifier">name</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_check_fit_params</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">fit_params_steps</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="identifier">name</span><span class="punctuation">:</span> <span class="grouping">{</span><span class="grouping">}</span> <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">step</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span>
                            <span class="keyword">if</span> <span class="identifier">step</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="grouping">}</span>
        <span class="keyword">for</span> <span class="identifier">pname</span><span class="punctuation">,</span> <span class="identifier">pval</span> <span class="relational-operator">in</span> <span class="identifier">fit_params</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="string-literal">'__'</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="identifier">pname</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                    <span class="string-literal">"Pipeline.fit does not accept the {} parameter. "</span>
                    <span class="string-literal">"You can pass parameters to specific steps of your "</span>
                    <span class="string-literal">"pipeline using the stepname__parameter format, e.g. "</span>
                    <span class="string-literal">"`Pipeline.fit(X, y, logisticregression__sample_weight"</span>
                    <span class="string-literal">"=sample_weight)`."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">pname</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">step</span><span class="punctuation">,</span> <span class="identifier">param</span> <span class="arithmetic-assignment">=</span> <span class="identifier">pname</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="string-literal">'__'</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span>
            <span class="identifier">fit_params_steps</span><span class="grouping">[</span><span class="identifier">step</span><span class="grouping">]</span><span class="grouping">[</span><span class="identifier">param</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">pval</span>
        <span class="keyword">return</span> <span class="identifier">fit_params_steps</span>

    <span class="comment"># Estimator interface</span>

    <span class="keyword">def</span> <span class="identifier">_fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params_steps</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># shallow copy of steps - this should really be steps_</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span> <span class="arithmetic-assignment">=</span> <span class="identifier">list</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_steps</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="comment"># Setup the memory</span>
        <span class="identifier">memory</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_memory</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">memory</span><span class="grouping">)</span>

        <span class="identifier">fit_transform_one_cached</span> <span class="arithmetic-assignment">=</span> <span class="identifier">memory</span><span class="punctuation">.</span><span class="identifier">cache</span><span class="grouping">(</span><span class="identifier">_fit_transform_one</span><span class="grouping">)</span>

        <span class="keyword">for</span> <span class="grouping">(</span><span class="identifier">step_idx</span><span class="punctuation">,</span>
             <span class="identifier">name</span><span class="punctuation">,</span>
             <span class="identifier">transformer</span><span class="grouping">)</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="invalid">w</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">a</span><span class="invalid">l</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                                        <span class="identifier">filter_passthrough</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">transformer</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="logical-operator">or</span> <span class="identifier">transformer</span> <span class="relational-operator">==</span> <span class="string-literal">'passthrough'</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">with</span> <span class="identifier">_print_elapsed_time</span><span class="grouping">(</span><span class="string-literal">'Pipeline'</span><span class="punctuation">,</span>
                                         <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_log_message</span><span class="grouping">(</span><span class="identifier">step_idx</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="keyword">continue</span>

            <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">memory</span><span class="punctuation">,</span> <span class="string-literal">'location'</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="comment"># joblib &gt;= 0.12</span>
                <span class="keyword">if</span> <span class="identifier">memory</span><span class="punctuation">.</span><span class="identifier">location</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                    <span class="comment"># we do not clone when caching is disabled to</span>
                    <span class="comment"># preserve backward compatibility</span>
                    <span class="identifier">cloned_transformer</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transformer</span>
                <span class="keyword">else</span><span class="punctuation">:</span>
                    <span class="identifier">cloned_transformer</span> <span class="arithmetic-assignment">=</span> <span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">transformer</span><span class="grouping">)</span>
            <span class="keyword">elif</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">memory</span><span class="punctuation">,</span> <span class="string-literal">'cachedir'</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="comment"># joblib &lt; 0.11</span>
                <span class="keyword">if</span> <span class="identifier">memory</span><span class="punctuation">.</span><span class="identifier">cachedir</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                    <span class="comment"># we do not clone when caching is disabled to</span>
                    <span class="comment"># preserve backward compatibility</span>
                    <span class="identifier">cloned_transformer</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transformer</span>
                <span class="keyword">else</span><span class="punctuation">:</span>
                    <span class="identifier">cloned_transformer</span> <span class="arithmetic-assignment">=</span> <span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">transformer</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">cloned_transformer</span> <span class="arithmetic-assignment">=</span> <span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">transformer</span><span class="grouping">)</span>
            <span class="comment"># Fit or load from cache the current transformer</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">fitted_transformer</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_transform_one_cached</span><span class="grouping">(</span>
                <span class="identifier">cloned_transformer</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="punctuation">,</span>
                <span class="identifier">message_clsname</span><span class="arithmetic-assignment">=</span><span class="string-literal">'Pipeline'</span><span class="punctuation">,</span>
                <span class="identifier">message</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_log_message</span><span class="grouping">(</span><span class="identifier">step_idx</span><span class="grouping">)</span><span class="punctuation">,</span>
                <span class="arithmetic-operator">**</span><span class="identifier">fit_params_steps</span><span class="grouping">[</span><span class="identifier">name</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="comment"># Replace the transformer of the step with the fitted</span>
            <span class="comment"># transformer. This is necessary when loading the transformer</span>
            <span class="comment"># from the cache.</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="identifier">step_idx</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">fitted_transformer</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">X</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the model

        Fit all the transforms one after the other and transform the
        data, then fit the transformed data using the final estimator.

        Parameters
        ----------
        X : iterable
            Training data. Must fulfill input requirements of first step of the
            pipeline.

        y : iterable, default=None
            Training targets. Must fulfill label requirements for all steps of
            the pipeline.

        **fit_params : dict of string -&gt; object
            Parameters passed to the ``fit`` method of each step, where
            each parameter name is prefixed such that parameter ``p`` for step
            ``s`` has key ``s__p``.

        Returns
        -------
        self : Pipeline
            This estimator
        """</span>
        <span class="identifier">fit_params_steps</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_fit_params</span><span class="grouping">(</span><span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span>
        <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params_steps</span><span class="grouping">)</span>
        <span class="keyword">with</span> <span class="identifier">_print_elapsed_time</span><span class="grouping">(</span><span class="string-literal">'Pipeline'</span><span class="punctuation">,</span>
                                 <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_log_message</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_final_estimator</span> <span class="relational-operator">!=</span> <span class="string-literal">'passthrough'</span><span class="punctuation">:</span>
                <span class="identifier">fit_params_last_step</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_params_steps</span><span class="grouping">[</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">]</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_final_estimator</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params_last_step</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the model and transform with the final estimator

        Fits all the transforms one after the other and transforms the
        data, then uses fit_transform on transformed data with the final
        estimator.

        Parameters
        ----------
        X : iterable
            Training data. Must fulfill input requirements of first step of the
            pipeline.

        y : iterable, default=None
            Training targets. Must fulfill label requirements for all steps of
            the pipeline.

        **fit_params : dict of string -&gt; object
            Parameters passed to the ``fit`` method of each step, where
            each parameter name is prefixed such that parameter ``p`` for step
            ``s`` has key ``s__p``.

        Returns
        -------
        Xt : array-like of shape  (n_samples, n_transformed_features)
            Transformed samples
        """</span>
        <span class="identifier">fit_params_steps</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_fit_params</span><span class="grouping">(</span><span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span>
        <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params_steps</span><span class="grouping">)</span>

        <span class="identifier">last_step</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_final_estimator</span>
        <span class="keyword">with</span> <span class="identifier">_print_elapsed_time</span><span class="grouping">(</span><span class="string-literal">'Pipeline'</span><span class="punctuation">,</span>
                                 <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_log_message</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">last_step</span> <span class="relational-operator">==</span> <span class="string-literal">'passthrough'</span><span class="punctuation">:</span>
                <span class="keyword">return</span> <span class="identifier">Xt</span>
            <span class="identifier">fit_params_last_step</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_params_steps</span><span class="grouping">[</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">]</span>
            <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">last_step</span><span class="punctuation">,</span> <span class="string-literal">'fit_transform'</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">return</span> <span class="identifier">last_step</span><span class="punctuation">.</span><span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params_last_step</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="keyword">return</span> <span class="identifier">last_step</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span>
                                     <span class="arithmetic-operator">**</span><span class="identifier">fit_params_last_step</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="string-literal">'_final_estimator'</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">predict_params</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Apply transforms to the data, and predict with the final estimator

        Parameters
        ----------
        X : iterable
            Data to predict on. Must fulfill input requirements of first step
            of the pipeline.

        **predict_params : dict of string -&gt; object
            Parameters to the ``predict`` called at the end of all
            transformations in the pipeline. Note that while this may be
            used to return uncertainties from some models with return_std
            or return_cov, uncertainties that are generated by the
            transformations in the pipeline are not propagated to the
            final estimator.

            .. versionadded:: 0.20

        Returns
        -------
        y_pred : array-like
        """</span>
        <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
        <span class="keyword">for</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">transform</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="invalid">w</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">a</span><span class="invalid">l</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transform</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">predict_params</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="string-literal">'_final_estimator'</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">fit_predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Applies fit_predict of last step in pipeline after transforms.

        Applies fit_transforms of a pipeline to the data, followed by the
        fit_predict method of the final estimator in the pipeline. Valid
        only if the final estimator implements fit_predict.

        Parameters
        ----------
        X : iterable
            Training data. Must fulfill input requirements of first step of
            the pipeline.

        y : iterable, default=None
            Training targets. Must fulfill label requirements for all steps
            of the pipeline.

        **fit_params : dict of string -&gt; object
            Parameters passed to the ``fit`` method of each step, where
            each parameter name is prefixed such that parameter ``p`` for step
            ``s`` has key ``s__p``.

        Returns
        -------
        y_pred : array-like
        """</span>
        <span class="identifier">fit_params_steps</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_fit_params</span><span class="grouping">(</span><span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span>
        <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params_steps</span><span class="grouping">)</span>

        <span class="identifier">fit_params_last_step</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_params_steps</span><span class="grouping">[</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">]</span>
        <span class="keyword">with</span> <span class="identifier">_print_elapsed_time</span><span class="grouping">(</span><span class="string-literal">'Pipeline'</span><span class="punctuation">,</span>
                                 <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_log_message</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">y_pred</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">fit_predict</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span>
                                                    <span class="arithmetic-operator">**</span><span class="identifier">fit_params_last_step</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">y_pred</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="string-literal">'_final_estimator'</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">predict_proba_params</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Apply transforms, and predict_proba of the final estimator

        Parameters
        ----------
        X : iterable
            Data to predict on. Must fulfill input requirements of first step
            of the pipeline.

        **predict_proba_params : dict of string -&gt; object
            Parameters to the ``predict_proba`` called at the end of all
            transformations in the pipeline.

        Returns
        -------
        y_proba : array-like of shape (n_samples, n_classes)
        """</span>
        <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
        <span class="keyword">for</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">transform</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="invalid">w</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">a</span><span class="invalid">l</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transform</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">predict_proba_params</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="string-literal">'_final_estimator'</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">decision_function</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Apply transforms, and decision_function of the final estimator

        Parameters
        ----------
        X : iterable
            Data to predict on. Must fulfill input requirements of first step
            of the pipeline.

        Returns
        -------
        y_score : array-like of shape (n_samples, n_classes)
        """</span>
        <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
        <span class="keyword">for</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">transform</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="invalid">w</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">a</span><span class="invalid">l</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transform</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">decision_function</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="string-literal">'_final_estimator'</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">score_samples</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Apply transforms, and score_samples of the final estimator.

        Parameters
        ----------
        X : iterable
            Data to predict on. Must fulfill input requirements of first step
            of the pipeline.

        Returns
        -------
        y_score : ndarray of shape (n_samples,)
        """</span>
        <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
        <span class="keyword">for</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">transformer</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="invalid">w</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">a</span><span class="invalid">l</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transformer</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">score_samples</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="string-literal">'_final_estimator'</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">predict_log_proba</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">predict_log_proba_params</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Apply transforms, and predict_log_proba of the final estimator

        Parameters
        ----------
        X : iterable
            Data to predict on. Must fulfill input requirements of first step
            of the pipeline.

        **predict_log_proba_params : dict of string -&gt; object
            Parameters to the ``predict_log_proba`` called at the end of all
            transformations in the pipeline.

        Returns
        -------
        y_score : array-like of shape (n_samples, n_classes)
        """</span>
        <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
        <span class="keyword">for</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">transform</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="invalid">w</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">a</span><span class="invalid">l</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transform</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">predict_log_proba</span><span class="grouping">(</span>
            <span class="identifier">Xt</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">predict_log_proba_params</span>
        <span class="grouping">)</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Apply transforms, and transform with the final estimator

        This also works where final estimator is ``None``: all prior
        transformations are applied.

        Parameters
        ----------
        X : iterable
            Data to transform. Must fulfill input requirements of first step
            of the pipeline.

        Returns
        -------
        Xt : array-like of shape  (n_samples, n_transformed_features)
        """</span>
        <span class="comment"># _final_estimator is None or has transform, otherwise attribute error</span>
        <span class="comment"># XXX: Handling the None case means we can't use if_delegate_has_method</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_final_estimator</span> <span class="relational-operator">!=</span> <span class="string-literal">'passthrough'</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_final_estimator</span><span class="punctuation">.</span><span class="identifier">transform</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_transform</span>

    <span class="keyword">def</span> <span class="identifier">_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
        <span class="keyword">for</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">transform</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transform</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">Xt</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">inverse_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Apply inverse transformations in reverse order

        All estimators in the pipeline must support ``inverse_transform``.

        Parameters
        ----------
        Xt : array-like of shape  (n_samples, n_transformed_features)
            Data samples, where ``n_samples`` is the number of samples and
            ``n_features`` is the number of features. Must fulfill
            input requirements of last step of pipeline's
            ``inverse_transform`` method.

        Returns
        -------
        Xt : array-like of shape (n_samples, n_features)
        """</span>
        <span class="comment"># raise AttributeError if necessary for hasattr behaviour</span>
        <span class="comment"># XXX: Handling the None case means we can't use if_delegate_has_method</span>
        <span class="keyword">for</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">transform</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">transform</span><span class="punctuation">.</span><span class="identifier">inverse_transform</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_inverse_transform</span>

    <span class="keyword">def</span> <span class="identifier">_inverse_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
        <span class="identifier">reverse_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">reversed</span><span class="grouping">(</span><span class="identifier">list</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">transform</span> <span class="relational-operator">in</span> <span class="identifier">reverse_iter</span><span class="punctuation">:</span>
            <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transform</span><span class="punctuation">.</span><span class="identifier">inverse_transform</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">Xt</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="string-literal">'_final_estimator'</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">score</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Apply transforms, and score with the final estimator

        Parameters
        ----------
        X : iterable
            Data to predict on. Must fulfill input requirements of first step
            of the pipeline.

        y : iterable, default=None
            Targets used for scoring. Must fulfill label requirements for all
            steps of the pipeline.

        sample_weight : array-like, default=None
            If not None, this argument is passed as ``sample_weight`` keyword
            argument to the ``score`` method of the final estimator.

        Returns
        -------
        score : float
        """</span>
        <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
        <span class="keyword">for</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">transform</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="invalid">w</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">a</span><span class="invalid">l</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">Xt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transform</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="grouping">)</span>
        <span class="identifier">score_params</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="grouping">}</span>
        <span class="keyword">if</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">score_params</span><span class="grouping">[</span><span class="string-literal">'sample_weight'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sample_weight</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">score</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">score_params</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># check if first estimator expects pairwise input</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'pairwise'</span><span class="punctuation">:</span> <span class="identifier">_safe_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="string-literal">"pairwise"</span><span class="grouping">)</span><span class="grouping">}</span>

    <span class="comment"># TODO: Remove in 1.1</span>
    <span class="comment"># mypy error: Decorated property not supported</span>
    <span class="punctuation">@</span><span class="identifier">deprecated</span><span class="grouping">(</span><span class="string-literal">"Attribute _pairwise was deprecated in "</span>  <span class="comment"># type: ignore</span>
                <span class="string-literal">"version 0.24 and will be removed in 1.1 (renaming of 0.26)."</span><span class="grouping">)</span>
    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">_pairwise</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># check if first estimator expects pairwise input</span>
        <span class="keyword">return</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="string-literal">'_pairwise'</span><span class="punctuation">,</span> <span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">n_features_in_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># delegate to first step (which will call _check_is_fitted)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">n_features_in_</span>

    <span class="keyword">def</span> <span class="identifier">_sk_visual_block_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">estimators</span> <span class="arithmetic-assignment">=</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">)</span>

        <span class="keyword">def</span> <span class="identifier">_get_name</span><span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">est</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">est</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="logical-operator">or</span> <span class="identifier">est</span> <span class="relational-operator">==</span> <span class="string-literal">'passthrough'</span><span class="punctuation">:</span>
                <span class="keyword">return</span> <span class="identifier">f</span><span class="string-literal">'{name}: passthrough'</span>
            <span class="comment"># Is an estimator</span>
            <span class="keyword">return</span> <span class="identifier">f</span><span class="string-literal">'{name}: {est.__class__.__name__}'</span>
        <span class="identifier">names</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">_get_name</span><span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">est</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">est</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">steps</span><span class="grouping">]</span>
        <span class="identifier">name_details</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">str</span><span class="grouping">(</span><span class="identifier">est</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">est</span> <span class="relational-operator">in</span> <span class="identifier">estimators</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="identifier">_VisualBlock</span><span class="grouping">(</span><span class="string-literal">'serial'</span><span class="punctuation">,</span> <span class="identifier">estimators</span><span class="punctuation">,</span>
                            <span class="identifier">names</span><span class="arithmetic-assignment">=</span><span class="identifier">names</span><span class="punctuation">,</span>
                            <span class="identifier">name_details</span><span class="arithmetic-assignment">=</span><span class="identifier">name_details</span><span class="punctuation">,</span>
                            <span class="identifier">dash_wrapped</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_name_estimators</span><span class="grouping">(</span><span class="identifier">estimators</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Generate names for estimators."""</span>

    <span class="identifier">names</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span>
        <span class="identifier">estimator</span>
        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span> <span class="keyword">else</span> <span class="identifier">type</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__name__</span><span class="punctuation">.</span><span class="identifier">lower</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">estimator</span> <span class="relational-operator">in</span> <span class="identifier">estimators</span>
    <span class="grouping">]</span>
    <span class="identifier">namecount</span> <span class="arithmetic-assignment">=</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">d</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">int</span><span class="grouping">)</span>
    <span class="keyword">for</span> <span class="identifier">est</span><span class="punctuation">,</span> <span class="identifier">name</span> <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">estimators</span><span class="punctuation">,</span> <span class="identifier">names</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">namecount</span><span class="grouping">[</span><span class="identifier">name</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">1</span>

    <span class="keyword">for</span> <span class="identifier">k</span><span class="punctuation">,</span> <span class="identifier">v</span> <span class="relational-operator">in</span> <span class="identifier">list</span><span class="grouping">(</span><span class="identifier">namecount</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">v</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">del</span> <span class="identifier">namecount</span><span class="grouping">[</span><span class="identifier">k</span><span class="grouping">]</span>

    <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">reversed</span><span class="grouping">(</span><span class="identifier">range</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">estimators</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">name</span> <span class="arithmetic-assignment">=</span> <span class="identifier">names</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span>
        <span class="keyword">if</span> <span class="identifier">name</span> <span class="relational-operator">in</span> <span class="identifier">namecount</span><span class="punctuation">:</span>
            <span class="identifier">names</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="string-literal">"-%d"</span> <span class="arithmetic-operator">%</span> <span class="identifier">namecount</span><span class="grouping">[</span><span class="identifier">name</span><span class="grouping">]</span>
            <span class="identifier">namecount</span><span class="grouping">[</span><span class="identifier">name</span><span class="grouping">]</span> <span class="arithmetic-assignment">-=</span> <span class="int-literal">1</span>

    <span class="keyword">return</span> <span class="identifier">list</span><span class="grouping">(</span><span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">names</span><span class="punctuation">,</span> <span class="identifier">estimators</span><span class="grouping">)</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">make_pipeline</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">steps</span><span class="punctuation">,</span> <span class="identifier">memory</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Construct a Pipeline from the given estimators.

    This is a shorthand for the Pipeline constructor; it does not require, and
    does not permit, naming the estimators. Instead, their names will be set
    to the lowercase of their types automatically.

    Parameters
    ----------
    *steps : list of estimators.

    memory : str or object with the joblib.Memory interface, default=None
        Used to cache the fitted transformers of the pipeline. By default,
        no caching is performed. If a string is given, it is the path to
        the caching directory. Enabling caching triggers a clone of
        the transformers before fitting. Therefore, the transformer
        instance given to the pipeline cannot be inspected
        directly. Use the attribute ``named_steps`` or ``steps`` to
        inspect estimators within the pipeline. Caching the
        transformers is advantageous when fitting is time consuming.

    verbose : bool, default=False
        If True, the time elapsed while fitting each step will be printed as it
        is completed.

    See Also
    --------
    Pipeline : Class for creating a pipeline of transforms with a final
        estimator.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.naive_bayes import GaussianNB
    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler
    &gt;&gt;&gt; make_pipeline(StandardScaler(), GaussianNB(priors=None))
    Pipeline(steps=[('standardscaler', StandardScaler()),
                    ('gaussiannb', GaussianNB())])

    Returns
    -------
    p : Pipeline
    """</span>
    <span class="keyword">return</span> <span class="identifier">Pipeline</span><span class="grouping">(</span><span class="identifier">_name_estimators</span><span class="grouping">(</span><span class="identifier">steps</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">memory</span><span class="arithmetic-assignment">=</span><span class="identifier">memory</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_transform_one</span><span class="grouping">(</span><span class="identifier">transformer</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">weight</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="identifier">res</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transformer</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="comment"># if we have a weight for this transformer, multiply output</span>
    <span class="keyword">if</span> <span class="identifier">weight</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">res</span>
    <span class="keyword">return</span> <span class="identifier">res</span> <span class="arithmetic-operator">*</span> <span class="identifier">weight</span>


<span class="keyword">def</span> <span class="identifier">_fit_transform_one</span><span class="grouping">(</span><span class="identifier">transformer</span><span class="punctuation">,</span>
                       <span class="identifier">X</span><span class="punctuation">,</span>
                       <span class="identifier">y</span><span class="punctuation">,</span>
                       <span class="identifier">weight</span><span class="punctuation">,</span>
                       <span class="identifier">message_clsname</span><span class="arithmetic-assignment">=</span><span class="string-literal">''</span><span class="punctuation">,</span>
                       <span class="identifier">message</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                       <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""
    Fits ``transformer`` to ``X`` and ``y``. The transformed result is returned
    with the fitted transformer. If ``weight`` is not ``None``, the result will
    be multiplied by ``weight``.
    """</span>
    <span class="keyword">with</span> <span class="identifier">_print_elapsed_time</span><span class="grouping">(</span><span class="identifier">message_clsname</span><span class="punctuation">,</span> <span class="identifier">message</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">transformer</span><span class="punctuation">,</span> <span class="string-literal">'fit_transform'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">res</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transformer</span><span class="punctuation">.</span><span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">res</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transformer</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">weight</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">res</span><span class="punctuation">,</span> <span class="identifier">transformer</span>
    <span class="keyword">return</span> <span class="identifier">res</span> <span class="arithmetic-operator">*</span> <span class="identifier">weight</span><span class="punctuation">,</span> <span class="identifier">transformer</span>


<span class="keyword">def</span> <span class="identifier">_fit_one</span><span class="grouping">(</span><span class="identifier">transformer</span><span class="punctuation">,</span>
             <span class="identifier">X</span><span class="punctuation">,</span>
             <span class="identifier">y</span><span class="punctuation">,</span>
             <span class="identifier">weight</span><span class="punctuation">,</span>
             <span class="identifier">message_clsname</span><span class="arithmetic-assignment">=</span><span class="string-literal">''</span><span class="punctuation">,</span>
             <span class="identifier">message</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
             <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""
    Fits ``transformer`` to ``X`` and ``y``.
    """</span>
    <span class="keyword">with</span> <span class="identifier">_print_elapsed_time</span><span class="grouping">(</span><span class="identifier">message_clsname</span><span class="punctuation">,</span> <span class="identifier">message</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">transformer</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">FeatureUnion</span><span class="grouping">(</span><span class="identifier">TransformerMixin</span><span class="punctuation">,</span> <span class="identifier">_BaseComposition</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Concatenates results of multiple transformer objects.

    This estimator applies a list of transformer objects in parallel to the
    input data, then concatenates the results. This is useful to combine
    several feature extraction mechanisms into a single transformer.

    Parameters of the transformers may be set using its name and the parameter
    name separated by a '__'. A transformer may be replaced entirely by
    setting the parameter with its name to another transformer,
    or removed by setting to 'drop'.

    Read more in the :ref:`User Guide &lt;feature_union&gt;`.

    .. versionadded:: 0.13

    Parameters
    ----------
    transformer_list : list of (string, transformer) tuples
        List of transformer objects to be applied to the data. The first
        half of each tuple is the name of the transformer. The tranformer can
        be 'drop' for it to be ignored.

        .. versionchanged:: 0.22
           Deprecated `None` as a transformer in favor of 'drop'.

    n_jobs : int, default=None
        Number of jobs to run in parallel.
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

        .. versionchanged:: v0.20
           `n_jobs` default changed from 1 to None

    transformer_weights : dict, default=None
        Multiplicative weights for features per transformer.
        Keys are transformer names, values the weights.
        Raises ValueError if key not present in ``transformer_list``.

    verbose : bool, default=False
        If True, the time elapsed while fitting each transformer will be
        printed as it is completed.

    See Also
    --------
    make_union : Convenience function for simplified feature union
        construction.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.pipeline import FeatureUnion
    &gt;&gt;&gt; from sklearn.decomposition import PCA, TruncatedSVD
    &gt;&gt;&gt; union = FeatureUnion([("pca", PCA(n_components=1)),
    ...                       ("svd", TruncatedSVD(n_components=2))])
    &gt;&gt;&gt; X = [[0., 1., 3], [2., 2., 5]]
    &gt;&gt;&gt; union.fit_transform(X)
    array([[ 1.5       ,  3.0...,  0.8...],
           [-1.5       ,  5.7..., -0.4...]])
    """</span>
    <span class="identifier">_required_parameters</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="string-literal">"transformer_list"</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">transformer_list</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">transformer_weights</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_list</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transformer_list</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_jobs</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_weights</span> <span class="arithmetic-assignment">=</span> <span class="identifier">transformer_weights</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">verbose</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_transformers</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">get_params</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">deep</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Get parameters for this estimator.

        Returns the parameters given in the constructor as well as the
        estimators contained within the `transformer_list` of the
        `FeatureUnion`.

        Parameters
        ----------
        deep : bool, default=True
            If True, will return the parameters for this estimator and
            contained subobjects that are estimators.

        Returns
        -------
        params : mapping of string to any
            Parameter names mapped to their values.
        """</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_get_params</span><span class="grouping">(</span><span class="string-literal">'transformer_list'</span><span class="punctuation">,</span> <span class="identifier">deep</span><span class="arithmetic-assignment">=</span><span class="identifier">deep</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">set_params</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">kwargs</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Set the parameters of this estimator.

        Valid parameter keys can be listed with ``get_params()``. Note that
        you can directly set the parameters of the estimators contained in
        `tranformer_list`.

        Returns
        -------
        self
        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_set_params</span><span class="grouping">(</span><span class="string-literal">'transformer_list'</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">kwargs</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">_validate_transformers</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">names</span><span class="punctuation">,</span> <span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_list</span><span class="grouping">)</span>

        <span class="comment"># validate names</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_names</span><span class="grouping">(</span><span class="identifier">names</span><span class="grouping">)</span>

        <span class="comment"># validate estimators</span>
        <span class="keyword">for</span> <span class="identifier">t</span> <span class="relational-operator">in</span> <span class="identifier">transformers</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">t</span> <span class="relational-operator">==</span> <span class="string-literal">'drop'</span><span class="punctuation">:</span>
                <span class="keyword">continue</span>
            <span class="keyword">if</span> <span class="grouping">(</span><span class="logical-operator">not</span> <span class="grouping">(</span><span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">t</span><span class="punctuation">,</span> <span class="string-literal">"fit") or hasattr(t, "fit_transform"</span><span class="grouping">)</span><span class="grouping">)</span> <span class="logical-operator">or</span> <span class="logical-operator">not</span>
                    <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">t</span><span class="punctuation">,</span> <span class="string-literal">"transform"</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">"All estimators should implement fit and "</span>
                                <span class="string-literal">"transform. '%s' (type %s) doesn't"</span> <span class="arithmetic-operator">%</span>
                                <span class="grouping">(</span><span class="identifier">t</span><span class="punctuation">,</span> <span class="identifier">type</span><span class="grouping">(</span><span class="identifier">t</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_validate_transformer_weights</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_weights</span><span class="punctuation">:</span>
            <span class="keyword">return</span>

        <span class="identifier">transformer_names</span> <span class="arithmetic-assignment">=</span> <span class="identifier">set</span><span class="grouping">(</span><span class="identifier">name</span> <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_list</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">name</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_weights</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">name</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="identifier">transformer_names</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                    <span class="identifier">f</span><span class="string-literal">'Attempting to weight transformer "{name}", '</span>
                    <span class="string-literal">'but it is not present in transformer_list.'</span>
                <span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_iter</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Generate (name, trans, weight) tuples excluding None and
        'drop' transformers.
        """</span>
        <span class="identifier">get_weight</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_weights</span> <span class="logical-operator">or</span> <span class="grouping">{</span><span class="grouping">}</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">get</span>
        <span class="keyword">return</span> <span class="grouping">(</span><span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="punctuation">,</span> <span class="identifier">get_weight</span><span class="grouping">(</span><span class="identifier">name</span><span class="grouping">)</span><span class="grouping">)</span>
                <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_list</span>
                <span class="keyword">if</span> <span class="identifier">trans</span> <span class="relational-operator">!=</span> <span class="string-literal">'drop'</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">get_feature_names</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Get feature names from all transformers.

        Returns
        -------
        feature_names : list of strings
            Names of the features produced by transform.
        """</span>
        <span class="identifier">feature_names</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
        <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="punctuation">,</span> <span class="identifier">weight</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">trans</span><span class="punctuation">,</span> <span class="string-literal">'get_feature_names'</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">AttributeError</span><span class="grouping">(</span><span class="string-literal">"Transformer %s (type %s) does not "</span>
                                     <span class="string-literal">"provide get_feature_names."</span>
                                     <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">str</span><span class="grouping">(</span><span class="identifier">name</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">type</span><span class="grouping">(</span><span class="identifier">trans</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__name__</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">feature_names</span><span class="punctuation">.</span><span class="identifier">extend</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">name</span> <span class="arithmetic-operator">+</span> <span class="string-literal">"__"</span> <span class="arithmetic-operator">+</span> <span class="identifier">f</span> <span class="keyword">for</span> <span class="identifier">f</span> <span class="relational-operator">in</span>
                                  <span class="identifier">trans</span><span class="punctuation">.</span><span class="identifier">get_feature_names</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">feature_names</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit all transformers using X.

        Parameters
        ----------
        X : iterable or array-like, depending on transformers
            Input data, used to fit transformers.

        y : array-like of shape (n_samples, n_outputs), default=None
            Targets for supervised learning.

        Returns
        -------
        self : FeatureUnion
            This estimator
        """</span>
        <span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_parallel_func</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">fit_params</span><span class="punctuation">,</span> <span class="identifier">_fit_one</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">transformers</span><span class="punctuation">:</span>
            <span class="comment"># All transformers are None</span>
            <span class="keyword">return</span> <span class="identifier">self</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_update_transformer_list</span><span class="grouping">(</span><span class="identifier">transformers</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit all transformers, transform the data and concatenate results.

        Parameters
        ----------
        X : iterable or array-like, depending on transformers
            Input data to be transformed.

        y : array-like of shape (n_samples, n_outputs), default=None
            Targets for supervised learning.

        Returns
        -------
        X_t : array-like or sparse matrix of \
                shape (n_samples, sum_n_components)
            hstack of results of transformers. sum_n_components is the
            sum of n_components (output dimension) over transformers.
        """</span>
        <span class="identifier">results</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_parallel_func</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">fit_params</span><span class="punctuation">,</span> <span class="identifier">_fit_transform_one</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">results</span><span class="punctuation">:</span>
            <span class="comment"># All transformers are None</span>
            <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">Xs</span><span class="punctuation">,</span> <span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">results</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_update_transformer_list</span><span class="grouping">(</span><span class="identifier">transformers</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_hstack</span><span class="grouping">(</span><span class="identifier">Xs</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_log_message</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">idx</span><span class="punctuation">,</span> <span class="identifier">total</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="none-literal">None</span>
        <span class="keyword">return</span> <span class="string-literal">'(step %d of %d) Processing %s'</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">idx</span><span class="punctuation">,</span> <span class="identifier">total</span><span class="punctuation">,</span> <span class="identifier">name</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_parallel_func</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">fit_params</span><span class="punctuation">,</span> <span class="identifier">func</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Runs func in parallel on X and y"""</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_list</span> <span class="arithmetic-assignment">=</span> <span class="identifier">list</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_list</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_transformers</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_transformer_weights</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">list</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">Parallel</span><span class="grouping">(</span><span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span><span class="grouping">)</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">(</span><span class="identifier">func</span><span class="grouping">)</span><span class="grouping">(</span>
            <span class="identifier">transformer</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">weight</span><span class="punctuation">,</span>
            <span class="identifier">message_clsname</span><span class="arithmetic-assignment">=</span><span class="string-literal">'FeatureUnion'</span><span class="punctuation">,</span>
            <span class="identifier">message</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_log_message</span><span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">idx</span><span class="punctuation">,</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">transformers</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">,</span>
            <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">idx</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">transformer</span><span class="punctuation">,</span>
                                    <span class="identifier">weight</span><span class="grouping">)</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">transformers</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Transform X separately by each transformer, concatenate results.

        Parameters
        ----------
        X : iterable or array-like, depending on transformers
            Input data to be transformed.

        Returns
        -------
        X_t : array-like or sparse matrix of \
                shape (n_samples, sum_n_components)
            hstack of results of transformers. sum_n_components is the
            sum of n_components (output dimension) over transformers.
        """</span>
        <span class="identifier">Xs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Parallel</span><span class="grouping">(</span><span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span><span class="grouping">)</span><span class="grouping">(</span>
            <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">(</span><span class="identifier">_transform_one</span><span class="grouping">)</span><span class="grouping">(</span><span class="identifier">trans</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">weight</span><span class="grouping">)</span>
            <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">trans</span><span class="punctuation">,</span> <span class="identifier">weight</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_iter</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">Xs</span><span class="punctuation">:</span>
            <span class="comment"># All transformers are None</span>
            <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_hstack</span><span class="grouping">(</span><span class="identifier">Xs</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_hstack</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">Xs</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">any</span><span class="grouping">(</span><span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">f</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">f</span> <span class="relational-operator">in</span> <span class="identifier">Xs</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">Xs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">hstack</span><span class="grouping">(</span><span class="identifier">Xs</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">tocsr</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">Xs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">hstack</span><span class="grouping">(</span><span class="identifier">Xs</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">Xs</span>

    <span class="keyword">def</span> <span class="identifier">_update_transformer_list</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">transformers</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">iter</span><span class="grouping">(</span><span class="identifier">transformers</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_list</span><span class="grouping">[</span><span class="punctuation">:</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">old</span> <span class="keyword">if</span> <span class="identifier">old</span> <span class="relational-operator">==</span> <span class="string-literal">'drop'</span>
                                     <span class="keyword">else</span> <span class="identifier">next</span><span class="grouping">(</span><span class="identifier">transformers</span><span class="grouping">)</span><span class="grouping">)</span>
                                    <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">old</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_list</span><span class="grouping">]</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">n_features_in_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># X is passed to all transformers so we just delegate to the first one</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_list</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">n_features_in_</span>

    <span class="keyword">def</span> <span class="identifier">_sk_visual_block_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">names</span><span class="punctuation">,</span> <span class="identifier">transformers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">transformer_list</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">_VisualBlock</span><span class="grouping">(</span><span class="string-literal">'parallel'</span><span class="punctuation">,</span> <span class="identifier">transformers</span><span class="punctuation">,</span> <span class="identifier">names</span><span class="arithmetic-assignment">=</span><span class="identifier">names</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">make_union</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">transformers</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""
    Construct a FeatureUnion from the given transformers.

    This is a shorthand for the FeatureUnion constructor; it does not require,
    and does not permit, naming the transformers. Instead, they will be given
    names automatically based on their types. It also does not allow weighting.

    Parameters
    ----------
    *transformers : list of estimators

    n_jobs : int, default=None
        Number of jobs to run in parallel.
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

        .. versionchanged:: v0.20
           `n_jobs` default changed from 1 to None

    verbose : bool, default=False
        If True, the time elapsed while fitting each transformer will be
        printed as it is completed.

    Returns
    -------
    f : FeatureUnion

    See Also
    --------
    FeatureUnion : Class for concatenating the results of multiple transformer
        objects.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.decomposition import PCA, TruncatedSVD
    &gt;&gt;&gt; from sklearn.pipeline import make_union
    &gt;&gt;&gt; make_union(PCA(), TruncatedSVD())
     FeatureUnion(transformer_list=[('pca', PCA()),
                                   ('truncatedsvd', TruncatedSVD())])
    """</span>
    <span class="keyword">return</span> <span class="identifier">FeatureUnion</span><span class="grouping">(</span>
        <span class="identifier">_name_estimators</span><span class="grouping">(</span><span class="identifier">transformers</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">n_jobs</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="grouping">)</span>

    </pre>
  </body>
</html>