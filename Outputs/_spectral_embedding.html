<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""Spectral Embedding."""</span>

<span class="comment"># Author: Gael Varoquaux &lt;gael.varoquaux@normalesup.org&gt;</span>
<span class="comment">#         Wei LI &lt;kuantkid@gmail.com&gt;</span>
<span class="comment"># License: BSD 3 clause</span>


<span class="keyword">import</span> <span class="identifier">warnings</span>

<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">from</span> <span class="identifier">scipy</span> <span class="keyword">import</span> <span class="identifier">sparse</span>
<span class="keyword">from</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">linalg</span> <span class="keyword">import</span> <span class="identifier">eigh</span>
<span class="keyword">from</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">linalg</span> <span class="keyword">import</span> <span class="identifier">eigsh</span>
<span class="keyword">from</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">csgraph</span> <span class="keyword">import</span> <span class="identifier">connected_components</span>
<span class="keyword">from</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">csgraph</span> <span class="keyword">import</span> <span class="identifier">laplacian</span> <span class="keyword">as</span> <span class="identifier">csgraph_laplacian</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">BaseEstimator</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="grouping">(</span>
    <span class="identifier">check_array</span><span class="punctuation">,</span>
    <span class="identifier">check_random_state</span><span class="punctuation">,</span>
    <span class="identifier">check_symmetric</span><span class="punctuation">,</span>
<span class="grouping">)</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">_arpack</span> <span class="keyword">import</span> <span class="identifier">_init_arpack_v0</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">extmath</span> <span class="keyword">import</span> <span class="identifier">_deterministic_vector_sign_flip</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">fixes</span> <span class="keyword">import</span> <span class="identifier">lobpcg</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">metrics</span><span class="punctuation">.</span><span class="identifier">pairwise</span> <span class="keyword">import</span> <span class="identifier">rbf_kernel</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">neighbors</span> <span class="keyword">import</span> <span class="identifier">kneighbors_graph</span><span class="punctuation">,</span> <span class="identifier">NearestNeighbors</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">deprecation</span> <span class="keyword">import</span> <span class="identifier">deprecated</span>


<span class="keyword">def</span> <span class="identifier">_graph_connected_component</span><span class="grouping">(</span><span class="identifier">graph</span><span class="punctuation">,</span> <span class="identifier">node_id</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Find the largest graph connected components that contains one
    given node.

    Parameters
    ----------
    graph : array-like of shape (n_samples, n_samples)
        Adjacency matrix of the graph, non-zero weight means an edge
        between the nodes.

    node_id : int
        The index of the query node of the graph.

    Returns
    -------
    connected_components_matrix : array-like of shape (n_samples,)
        An array of bool value indicating the indexes of the nodes
        belonging to the largest connected components of the given query
        node.
    """</span>
    <span class="identifier">n_node</span> <span class="arithmetic-assignment">=</span> <span class="identifier">graph</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
    <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">graph</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># speed up row-wise access to boolean connection mask</span>
        <span class="identifier">graph</span> <span class="arithmetic-assignment">=</span> <span class="identifier">graph</span><span class="punctuation">.</span><span class="identifier">tocsr</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="identifier">connected_nodes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">n_node</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">bool</span><span class="grouping">)</span>
    <span class="identifier">nodes_to_explore</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">n_node</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">bool</span><span class="grouping">)</span>
    <span class="identifier">nodes_to_explore</span><span class="grouping">[</span><span class="identifier">node_id</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>
    <span class="keyword">for</span> <span class="identifier">_</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_node</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">last_num_component</span> <span class="arithmetic-assignment">=</span> <span class="identifier">connected_nodes</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">logical_or</span><span class="grouping">(</span><span class="identifier">connected_nodes</span><span class="punctuation">,</span> <span class="identifier">nodes_to_explore</span><span class="punctuation">,</span> <span class="identifier">out</span><span class="arithmetic-assignment">=</span><span class="identifier">connected_nodes</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">last_num_component</span> <span class="relational-operator">&gt;=</span> <span class="identifier">connected_nodes</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">break</span>
        <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">where</span><span class="grouping">(</span><span class="identifier">nodes_to_explore</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">nodes_to_explore</span><span class="punctuation">.</span><span class="identifier">fill</span><span class="grouping">(</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">indices</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">graph</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">neighbors</span> <span class="arithmetic-assignment">=</span> <span class="identifier">graph</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">neighbors</span> <span class="arithmetic-assignment">=</span> <span class="identifier">graph</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span>
            <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">logical_or</span><span class="grouping">(</span><span class="identifier">nodes_to_explore</span><span class="punctuation">,</span> <span class="identifier">neighbors</span><span class="punctuation">,</span> <span class="identifier">out</span><span class="arithmetic-assignment">=</span><span class="identifier">nodes_to_explore</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">connected_nodes</span>


<span class="keyword">def</span> <span class="identifier">_graph_is_connected</span><span class="grouping">(</span><span class="identifier">graph</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">""" Return whether the graph is connected (True) or Not (False).

    Parameters
    ----------
    graph : {array-like, sparse matrix} of shape (n_samples, n_samples)
        Adjacency matrix of the graph, non-zero weight means an edge
        between the nodes.

    Returns
    -------
    is_connected : bool
        True means the graph is fully connected and False means not.
    """</span>
    <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">isspmatrix</span><span class="grouping">(</span><span class="identifier">graph</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># sparse graph, find all the connected components</span>
        <span class="identifier">n_connected_components</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">connected_components</span><span class="grouping">(</span><span class="identifier">graph</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">n_connected_components</span> <span class="relational-operator">==</span> <span class="int-literal">1</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="comment"># dense graph, find all connected components start from node 0</span>
        <span class="keyword">return</span> <span class="identifier">_graph_connected_component</span><span class="grouping">(</span><span class="identifier">graph</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="identifier">graph</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>


<span class="keyword">def</span> <span class="identifier">_set_diag</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">,</span> <span class="identifier">value</span><span class="punctuation">,</span> <span class="identifier">norm_laplacian</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Set the diagonal of the laplacian matrix and convert it to a
    sparse format well suited for eigenvalue decomposition.

    Parameters
    ----------
    laplacian : {ndarray, sparse matrix}
        The graph laplacian.

    value : float
        The value of the diagonal.

    norm_laplacian : bool
        Whether the value of the diagonal should be changed or not.

    Returns
    -------
    laplacian : {array, sparse matrix}
        An array of matrix in a form that is well suited to fast
        eigenvalue decomposition, depending on the band width of the
        matrix.
    """</span>
    <span class="identifier">n_nodes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">laplacian</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
    <span class="comment"># We need all entries in the diagonal to values</span>
    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">isspmatrix</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">norm_laplacian</span><span class="punctuation">:</span>
            <span class="identifier">laplacian</span><span class="punctuation">.</span><span class="identifier">flat</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="identifier">n_nodes</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">value</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">laplacian</span> <span class="arithmetic-assignment">=</span> <span class="identifier">laplacian</span><span class="punctuation">.</span><span class="identifier">tocoo</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">norm_laplacian</span><span class="punctuation">:</span>
            <span class="identifier">diag_idx</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">.</span><span class="identifier">row</span> <span class="relational-operator">==</span> <span class="identifier">laplacian</span><span class="punctuation">.</span><span class="identifier">col</span><span class="grouping">)</span>
            <span class="identifier">laplacian</span><span class="punctuation">.</span><span class="identifier">data</span><span class="grouping">[</span><span class="identifier">diag_idx</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">value</span>
        <span class="comment"># If the matrix has a small number of diagonals (as in the</span>
        <span class="comment"># case of structured matrices coming from images), the</span>
        <span class="comment"># dia format might be best suited for matvec products:</span>
        <span class="identifier">n_diags</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">.</span><span class="identifier">row</span> <span class="arithmetic-operator">-</span> <span class="identifier">laplacian</span><span class="punctuation">.</span><span class="identifier">col</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">size</span>
        <span class="keyword">if</span> <span class="identifier">n_diags</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">7</span><span class="punctuation">:</span>
            <span class="comment"># 3 or less outer diagonals on each side</span>
            <span class="identifier">laplacian</span> <span class="arithmetic-assignment">=</span> <span class="identifier">laplacian</span><span class="punctuation">.</span><span class="identifier">todia</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># csr has the fastest matvec and is thus best suited to</span>
            <span class="comment"># arpack</span>
            <span class="identifier">laplacian</span> <span class="arithmetic-assignment">=</span> <span class="identifier">laplacian</span><span class="punctuation">.</span><span class="identifier">tocsr</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">laplacian</span>


<span class="keyword">def</span> <span class="identifier">spectral_embedding</span><span class="grouping">(</span><span class="identifier">adjacency</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">n_components</span><span class="arithmetic-assignment">=</span><span class="int-literal">8</span><span class="punctuation">,</span> <span class="identifier">eigen_solver</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                       <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">eigen_tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.0</span><span class="punctuation">,</span>
                       <span class="identifier">norm_laplacian</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">drop_first</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Project the sample on the first eigenvectors of the graph Laplacian.

    The adjacency matrix is used to compute a normalized graph Laplacian
    whose spectrum (especially the eigenvectors associated to the
    smallest eigenvalues) has an interpretation in terms of minimal
    number of cuts necessary to split the graph into comparably sized
    components.

    This embedding can also 'work' even if the ``adjacency`` variable is
    not strictly the adjacency matrix of a graph but more generally
    an affinity or similarity matrix between samples (for instance the
    heat kernel of a euclidean distance matrix or a k-NN matrix).

    However care must taken to always make the affinity matrix symmetric
    so that the eigenvector decomposition works as expected.

    Note : Laplacian Eigenmaps is the actual algorithm implemented here.

    Read more in the :ref:`User Guide &lt;spectral_embedding&gt;`.

    Parameters
    ----------
    adjacency : {array-like, sparse graph} of shape (n_samples, n_samples)
        The adjacency matrix of the graph to embed.

    n_components : int, default=8
        The dimension of the projection subspace.

    eigen_solver : {'arpack', 'lobpcg', 'amg'}, default=None
        The eigenvalue decomposition strategy to use. AMG requires pyamg
        to be installed. It can be faster on very large, sparse problems,
        but may also lead to instabilities. If None, then ``'arpack'`` is
        used.

    random_state : int, RandomState instance or None, default=None
        A pseudo random number generator used for the initialization
        of the lobpcg eigen vectors decomposition when `eigen_solver ==
        'amg'`, and for the K-Means initialization. Use an int to make
        the results deterministic across calls (See
        :term:`Glossary &lt;random_state&gt;`).

        .. note::
            When using `eigen_solver == 'amg'`,
            it is necessary to also fix the global numpy seed with
            `np.random.seed(int)` to get deterministic results. See
            https://github.com/pyamg/pyamg/issues/139 for further
            information.

    eigen_tol : float, default=0.0
        Stopping criterion for eigendecomposition of the Laplacian matrix
        when using arpack eigen_solver.

    norm_laplacian : bool, default=True
        If True, then compute normalized Laplacian.

    drop_first : bool, default=True
        Whether to drop the first eigenvector. For spectral embedding, this
        should be True as the first eigenvector should be constant vector for
        connected graph, but for spectral clustering, this should be kept as
        False to retain the first eigenvector.

    Returns
    -------
    embedding : ndarray of shape (n_samples, n_components)
        The reduced samples.

    Notes
    -----
    Spectral Embedding (Laplacian Eigenmaps) is most useful when the graph
    has one connected component. If there graph has many components, the first
    few eigenvectors will simply uncover the connected components of the graph.

    References
    ----------
    * https://en.wikipedia.org/wiki/LOBPCG

    * Toward the Optimal Preconditioned Eigensolver: Locally Optimal
      Block Preconditioned Conjugate Gradient Method
      Andrew V. Knyazev
      https://doi.org/10.1137%2FS1064827500366124
    """</span>
    <span class="identifier">adjacency</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_symmetric</span><span class="grouping">(</span><span class="identifier">adjacency</span><span class="grouping">)</span>

    <span class="keyword">try</span><span class="punctuation">:</span>
        <span class="keyword">from</span> <span class="identifier">pyamg</span> <span class="keyword">import</span> <span class="identifier">smoothed_aggregation_solver</span>
    <span class="keyword">except</span> <span class="invalid">I</span><span class="invalid">m</span><span class="invalid">p</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">t</span><span class="invalid">E</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">o</span><span class="invalid">r</span> <span class="keyword">as</span> <span class="identifier">e</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">eigen_solver</span> <span class="relational-operator">==</span> <span class="string-literal">"amg"</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"The eigen_solver was set to 'amg', but pyamg is "</span>
                             <span class="string-literal">"not available."</span><span class="grouping">)</span> <span class="keyword">from</span> <span class="identifier">e</span>

    <span class="keyword">if</span> <span class="identifier">eigen_solver</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">eigen_solver</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'arpack'</span>
    <span class="keyword">elif</span> <span class="identifier">eigen_solver</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="string-literal">'arpack', 'lobpcg', 'amg'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Unknown value for eigen_solver: '%s'."</span>
                         <span class="string-literal">"Should be 'amg', 'arpack', or 'lobpcg'"</span>
                         <span class="arithmetic-operator">%</span> <span class="identifier">eigen_solver</span><span class="grouping">)</span>

    <span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">random_state</span><span class="grouping">)</span>

    <span class="identifier">n_nodes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">adjacency</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
    <span class="comment"># Whether to drop the first eigenvector</span>
    <span class="keyword">if</span> <span class="identifier">drop_first</span><span class="punctuation">:</span>
        <span class="identifier">n_components</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_components</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span>

    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">_graph_is_connected</span><span class="grouping">(</span><span class="identifier">adjacency</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">"Graph is not fully connected, spectral embedding"</span>
                      <span class="string-literal">" may not work as expected."</span><span class="grouping">)</span>

    <span class="identifier">laplacian</span><span class="punctuation">,</span> <span class="identifier">dd</span> <span class="arithmetic-assignment">=</span> <span class="identifier">csgraph_laplacian</span><span class="grouping">(</span><span class="identifier">adjacency</span><span class="punctuation">,</span> <span class="identifier">normed</span><span class="arithmetic-assignment">=</span><span class="identifier">norm_laplacian</span><span class="punctuation">,</span>
                                      <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">i</span><span class="invalid">a</span><span class="invalid">g</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">eigen_solver</span> <span class="relational-operator">==</span> <span class="string-literal">'arpack' or eigen_solver != 'lobpcg'</span> <span class="logical-operator">and</span>
       <span class="grouping">(</span><span class="logical-operator">not</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">isspmatrix</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="grouping">)</span> <span class="logical-operator">or</span> <span class="identifier">n_nodes</span> <span class="relational-operator">&lt;</span> <span class="int-literal">5</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_components</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># lobpcg used with eigen_solver='amg' has bugs for low number of nodes</span>
        <span class="comment"># for details see the source code in scipy:</span>
        <span class="comment"># https://github.com/scipy/scipy/blob/v0.11.0/scipy/sparse/linalg/eigen</span>
        <span class="comment"># /lobpcg/lobpcg.py#L237</span>
        <span class="comment"># or matlab:</span>
        <span class="comment"># https://www.mathworks.com/matlabcentral/fileexchange/48-lobpcg-m</span>
        <span class="identifier">laplacian</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_set_diag</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">norm_laplacian</span><span class="grouping">)</span>

        <span class="comment"># Here we'll use shift-invert mode for fast eigenvalues</span>
        <span class="comment"># (see https://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html</span>
        <span class="comment">#  for a short explanation of what this means)</span>
        <span class="comment"># Because the normalized Laplacian has eigenvalues between 0 and 2,</span>
        <span class="comment"># I - L has eigenvalues between -1 and 1.  ARPACK is most efficient</span>
        <span class="comment"># when finding eigenvalues of largest magnitude (keyword which='LM')</span>
        <span class="comment"># and when these eigenvalues are very large compared to the rest.</span>
        <span class="comment"># For very large, very sparse graphs, I - L can have many, many</span>
        <span class="comment"># eigenvalues very near 1.0.  This leads to slow convergence.  So</span>
        <span class="comment"># instead, we'll use ARPACK's shift-invert mode, asking for the</span>
        <span class="comment"># eigenvalues near 1.0.  This effectively spreads-out the spectrum</span>
        <span class="comment"># near 1.0 and leads to much faster convergence: potentially an</span>
        <span class="comment"># orders-of-magnitude speedup over simply using keyword which='LA'</span>
        <span class="comment"># in standard mode.</span>
        <span class="keyword">try</span><span class="punctuation">:</span>
            <span class="comment"># We are computing the opposite of the laplacian inplace so as</span>
            <span class="comment"># to spare a memory allocation of a possibly very large array</span>
            <span class="identifier">laplacian</span> <span class="arithmetic-assignment">*=</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span>
            <span class="identifier">v0</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_init_arpack_v0</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="grouping">)</span>
            <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">diffusion_map</span> <span class="arithmetic-assignment">=</span> <span class="identifier">eigsh</span><span class="grouping">(</span>
                <span class="identifier">laplacian</span><span class="punctuation">,</span> <span class="identifier">k</span><span class="arithmetic-assignment">=</span><span class="identifier">n_components</span><span class="punctuation">,</span> <span class="identifier">sigma</span><span class="arithmetic-assignment">=</span><span class="float-literal">1.0</span><span class="punctuation">,</span> <span class="identifier">which</span><span class="arithmetic-assignment">=</span><span class="string-literal">'LM'</span><span class="punctuation">,</span>
                <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">eigen_tol</span><span class="punctuation">,</span> <span class="identifier">v0</span><span class="arithmetic-assignment">=</span><span class="identifier">v0</span><span class="grouping">)</span>
            <span class="identifier">embedding</span> <span class="arithmetic-assignment">=</span> <span class="identifier">diffusion_map</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">n_components</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span>
            <span class="keyword">if</span> <span class="identifier">norm_laplacian</span><span class="punctuation">:</span>
                <span class="identifier">embedding</span> <span class="arithmetic-assignment">=</span> <span class="identifier">embedding</span> <span class="arithmetic-operator">/</span> <span class="identifier">dd</span>
        <span class="keyword">except</span> <span class="identifier">RuntimeError</span><span class="punctuation">:</span>
            <span class="comment"># When submatrices are exactly singular, an LU decomposition</span>
            <span class="comment"># in arpack fails. We fallback to lobpcg</span>
            <span class="identifier">eigen_solver</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"lobpcg"</span>
            <span class="comment"># Revert the laplacian to its opposite to have lobpcg work</span>
            <span class="identifier">laplacian</span> <span class="arithmetic-assignment">*=</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span>

    <span class="keyword">elif</span> <span class="identifier">eigen_solver</span> <span class="relational-operator">==</span> <span class="string-literal">'amg'</span><span class="punctuation">:</span>
        <span class="comment"># Use AMG to get a preconditioner and speed up the eigenvalue</span>
        <span class="comment"># problem.</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">"AMG works better for sparse matrices"</span><span class="grouping">)</span>
        <span class="comment"># lobpcg needs double precision floats</span>
        <span class="identifier">laplacian</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span>
                                <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">laplacian</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_set_diag</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">norm_laplacian</span><span class="grouping">)</span>

        <span class="comment"># The Laplacian matrix is always singular, having at least one zero</span>
        <span class="comment"># eigenvalue, corresponding to the trivial eigenvector, which is a</span>
        <span class="comment"># constant. Using a singular matrix for preconditioning may result in</span>
        <span class="comment"># random failures in LOBPCG and is not supported by the existing</span>
        <span class="comment"># theory:</span>
        <span class="comment">#     see https://doi.org/10.1007/s10208-015-9297-1</span>
        <span class="comment"># Shift the Laplacian so its diagononal is not all ones. The shift</span>
        <span class="comment"># does change the eigenpairs however, so we'll feed the shifted</span>
        <span class="comment"># matrix to the solver and afterward set it back to the original.</span>
        <span class="identifier">diag_shift</span> <span class="arithmetic-assignment">=</span> <span class="float-literal">1e-5</span> <span class="arithmetic-operator">*</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">eye</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="identifier">laplacian</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">diag_shift</span>
        <span class="identifier">ml</span> <span class="arithmetic-assignment">=</span> <span class="identifier">smoothed_aggregation_solver</span><span class="grouping">(</span><span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">,</span>
                                                     <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csr'</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">laplacian</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">diag_shift</span>

        <span class="identifier">M</span> <span class="arithmetic-assignment">=</span> <span class="identifier">ml</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">p</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">d</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">i</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">e</span><span class="invalid">r</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span><span class="punctuation">.</span><span class="identifier">rand</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">n_components</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span>
        <span class="identifier">X</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dd</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">diffusion_map</span> <span class="arithmetic-assignment">=</span> <span class="identifier">lobpcg</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">M</span><span class="arithmetic-assignment">=</span><span class="identifier">M</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">.</span><span class="identifier">e</span><span class="arithmetic-operator">-</span><span class="int-literal">5</span><span class="punctuation">,</span>
                                  <span class="identifier">largest</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">embedding</span> <span class="arithmetic-assignment">=</span> <span class="identifier">diffusion_map</span><span class="punctuation">.</span><span class="identifier">T</span>
        <span class="keyword">if</span> <span class="identifier">norm_laplacian</span><span class="punctuation">:</span>
            <span class="identifier">embedding</span> <span class="arithmetic-assignment">=</span> <span class="identifier">embedding</span> <span class="arithmetic-operator">/</span> <span class="identifier">dd</span>
        <span class="keyword">if</span> <span class="identifier">embedding</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span>

    <span class="keyword">if</span> <span class="identifier">eigen_solver</span> <span class="relational-operator">==</span> <span class="string-literal">"lobpcg"</span><span class="punctuation">:</span>
        <span class="comment"># lobpcg needs double precision floats</span>
        <span class="identifier">laplacian</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span>
                                <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">n_nodes</span> <span class="relational-operator">&lt;</span> <span class="int-literal">5</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_components</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="comment"># see note above under arpack why lobpcg has problems with small</span>
            <span class="comment"># number of nodes</span>
            <span class="comment"># lobpcg will fallback to eigh, so we short circuit it</span>
            <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">isspmatrix</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">laplacian</span> <span class="arithmetic-assignment">=</span> <span class="identifier">laplacian</span><span class="punctuation">.</span><span class="identifier">toarray</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">diffusion_map</span> <span class="arithmetic-assignment">=</span> <span class="identifier">eigh</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">,</span> <span class="identifier">check_finite</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
            <span class="identifier">embedding</span> <span class="arithmetic-assignment">=</span> <span class="identifier">diffusion_map</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_components</span><span class="grouping">]</span>
            <span class="keyword">if</span> <span class="identifier">norm_laplacian</span><span class="punctuation">:</span>
                <span class="identifier">embedding</span> <span class="arithmetic-assignment">=</span> <span class="identifier">embedding</span> <span class="arithmetic-operator">/</span> <span class="identifier">dd</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">laplacian</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_set_diag</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">norm_laplacian</span><span class="grouping">)</span>
            <span class="comment"># We increase the number of eigenvectors requested, as lobpcg</span>
            <span class="comment"># doesn't behave well in low dimension</span>
            <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span><span class="punctuation">.</span><span class="identifier">rand</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">n_components</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span>
            <span class="identifier">X</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dd</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">diffusion_map</span> <span class="arithmetic-assignment">=</span> <span class="identifier">lobpcg</span><span class="grouping">(</span><span class="identifier">laplacian</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-15</span><span class="punctuation">,</span>
                                      <span class="identifier">largest</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">maxiter</span><span class="arithmetic-assignment">=</span><span class="int-literal">2000</span><span class="grouping">)</span>
            <span class="identifier">embedding</span> <span class="arithmetic-assignment">=</span> <span class="identifier">diffusion_map</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_components</span><span class="grouping">]</span>
            <span class="keyword">if</span> <span class="identifier">norm_laplacian</span><span class="punctuation">:</span>
                <span class="identifier">embedding</span> <span class="arithmetic-assignment">=</span> <span class="identifier">embedding</span> <span class="arithmetic-operator">/</span> <span class="identifier">dd</span>
            <span class="keyword">if</span> <span class="identifier">embedding</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span>

    <span class="identifier">embedding</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_deterministic_vector_sign_flip</span><span class="grouping">(</span><span class="identifier">embedding</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">drop_first</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">embedding</span><span class="grouping">[</span><span class="int-literal">1</span><span class="punctuation">:</span><span class="identifier">n_components</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">T</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">embedding</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_components</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">T</span>


<span class="keyword">class</span> <span class="identifier">SpectralEmbedding</span><span class="grouping">(</span><span class="identifier">BaseEstimator</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Spectral embedding for non-linear dimensionality reduction.

    Forms an affinity matrix given by the specified function and
    applies spectral decomposition to the corresponding graph laplacian.
    The resulting transformation is given by the value of the
    eigenvectors for each data point.

    Note : Laplacian Eigenmaps is the actual algorithm implemented here.

    Read more in the :ref:`User Guide &lt;spectral_embedding&gt;`.

    Parameters
    ----------
    n_components : int, default=2
        The dimension of the projected subspace.

    affinity : {'nearest_neighbors', 'rbf', 'precomputed', \
                'precomputed_nearest_neighbors'} or callable, \
                default='nearest_neighbors'
        How to construct the affinity matrix.
         - 'nearest_neighbors' : construct the affinity matrix by computing a
           graph of nearest neighbors.
         - 'rbf' : construct the affinity matrix by computing a radial basis
           function (RBF) kernel.
         - 'precomputed' : interpret ``X`` as a precomputed affinity matrix.
         - 'precomputed_nearest_neighbors' : interpret ``X`` as a sparse graph
           of precomputed nearest neighbors, and constructs the affinity matrix
           by selecting the ``n_neighbors`` nearest neighbors.
         - callable : use passed in function as affinity
           the function takes in data matrix (n_samples, n_features)
           and return affinity matrix (n_samples, n_samples).

    gamma : float, default=None
        Kernel coefficient for rbf kernel. If None, gamma will be set to
        1/n_features.

    random_state : int, RandomState instance or None, default=None
        A pseudo random number generator used for the initialization
        of the lobpcg eigen vectors decomposition when `eigen_solver ==
        'amg'`, and for the K-Means initialization. Use an int to make
        the results deterministic across calls (See
        :term:`Glossary &lt;random_state&gt;`).

        .. note::
            When using `eigen_solver == 'amg'`,
            it is necessary to also fix the global numpy seed with
            `np.random.seed(int)` to get deterministic results. See
            https://github.com/pyamg/pyamg/issues/139 for further
            information.

    eigen_solver : {'arpack', 'lobpcg', 'amg'}, default=None
        The eigenvalue decomposition strategy to use. AMG requires pyamg
        to be installed. It can be faster on very large, sparse problems.
        If None, then ``'arpack'`` is used.

    n_neighbors : int, default=None
        Number of nearest neighbors for nearest_neighbors graph building.
        If None, n_neighbors will be set to max(n_samples/10, 1).

    n_jobs : int, default=None
        The number of parallel jobs to run.
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

    Attributes
    ----------
    embedding_ : ndarray of shape (n_samples, n_components)
        Spectral embedding of the training matrix.

    affinity_matrix_ : ndarray of shape (n_samples, n_samples)
        Affinity_matrix constructed from samples or precomputed.

    n_neighbors_ : int
        Number of nearest neighbors effectively used.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.datasets import load_digits
    &gt;&gt;&gt; from sklearn.manifold import SpectralEmbedding
    &gt;&gt;&gt; X, _ = load_digits(return_X_y=True)
    &gt;&gt;&gt; X.shape
    (1797, 64)
    &gt;&gt;&gt; embedding = SpectralEmbedding(n_components=2)
    &gt;&gt;&gt; X_transformed = embedding.fit_transform(X[:100])
    &gt;&gt;&gt; X_transformed.shape
    (100, 2)

    References
    ----------

    - A Tutorial on Spectral Clustering, 2007
      Ulrike von Luxburg
      http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.165.9323

    - On Spectral Clustering: Analysis and an algorithm, 2001
      Andrew Y. Ng, Michael I. Jordan, Yair Weiss
      http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.8100

    - Normalized cuts and image segmentation, 2000
      Jianbo Shi, Jitendra Malik
      http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.160.2324
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">n_components</span><span class="arithmetic-assignment">=</span><span class="int-literal">2</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">affinity</span><span class="arithmetic-assignment">=</span><span class="string-literal">"nearest_neighbors"</span><span class="punctuation">,</span>
                 <span class="identifier">gamma</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">eigen_solver</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">n_neighbors</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_components</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity</span> <span class="arithmetic-assignment">=</span> <span class="identifier">affinity</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">gamma</span> <span class="arithmetic-assignment">=</span> <span class="identifier">gamma</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">eigen_solver</span> <span class="arithmetic-assignment">=</span> <span class="identifier">eigen_solver</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_neighbors</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_neighbors</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_jobs</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'pairwise'</span><span class="punctuation">:</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="string-literal">"precomputed"</span><span class="punctuation">,</span>
                                              <span class="string-literal">"precomputed_nearest_neighbors"</span><span class="grouping">]</span><span class="grouping">}</span>

    <span class="comment"># TODO: Remove in 1.1</span>
    <span class="comment"># mypy error: Decorated property not supported</span>
    <span class="punctuation">@</span><span class="identifier">deprecated</span><span class="grouping">(</span><span class="string-literal">"Attribute _pairwise was deprecated in "</span>  <span class="comment"># type: ignore</span>
                <span class="string-literal">"version 0.24 and will be removed in 1.1 (renaming of 0.26)."</span><span class="grouping">)</span>
    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">_pairwise</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="string-literal">"precomputed"</span><span class="punctuation">,</span>
                                 <span class="string-literal">"precomputed_nearest_neighbors"</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">_get_affinity_matrix</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">Y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Calculate the affinity matrix from data
        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training vector, where n_samples is the number of samples
            and n_features is the number of features.

            If affinity is "precomputed"
            X : array-like of shape (n_samples, n_samples),
            Interpret X as precomputed adjacency graph computed from
            samples.

        Y: Ignored

        Returns
        -------
        affinity_matrix of shape (n_samples, n_samples)
        """</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity</span> <span class="relational-operator">==</span> <span class="string-literal">'precomputed'</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity_matrix_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity_matrix_</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity</span> <span class="relational-operator">==</span> <span class="string-literal">'precomputed_nearest_neighbors'</span><span class="punctuation">:</span>
            <span class="identifier">estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">NearestNeighbors</span><span class="grouping">(</span><span class="identifier">n_neighbors</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_neighbors</span><span class="punctuation">,</span>
                                         <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span><span class="punctuation">,</span>
                                         <span class="identifier">metric</span><span class="arithmetic-assignment">=</span><span class="string-literal">"precomputed"</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
            <span class="identifier">connectivity</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">kneighbors_graph</span><span class="grouping">(</span><span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">mode</span><span class="arithmetic-assignment">=</span><span class="string-literal">'connectivity'</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity_matrix_</span> <span class="arithmetic-assignment">=</span> <span class="float-literal">0.5</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="identifier">connectivity</span> <span class="arithmetic-operator">+</span> <span class="identifier">connectivity</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity_matrix_</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity</span> <span class="relational-operator">==</span> <span class="string-literal">'nearest_neighbors'</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">"Nearest neighbors affinity currently does "</span>
                              <span class="string-literal">"not support sparse input, falling back to "</span>
                              <span class="string-literal">"rbf affinity"</span><span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"rbf"</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_neighbors_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_neighbors</span>
                                     <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_neighbors</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span>
                                     <span class="keyword">else</span> <span class="identifier">max</span><span class="grouping">(</span><span class="identifier">int</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-operator">/</span> <span class="int-literal">10</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity_matrix_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">kneighbors_graph</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_neighbors_</span><span class="punctuation">,</span>
                                                         <span class="identifier">include_self</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                                                         <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span><span class="grouping">)</span>
                <span class="comment"># currently only symmetric affinity_matrix supported</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity_matrix_</span> <span class="arithmetic-assignment">=</span> <span class="float-literal">0.5</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity_matrix_</span> <span class="arithmetic-operator">+</span>
                                               <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity_matrix_</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span>
                <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity_matrix_</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity</span> <span class="relational-operator">==</span> <span class="string-literal">'rbf'</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">gamma_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">gamma</span>
                           <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">gamma</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="keyword">else</span> <span class="float-literal">1.0</span> <span class="arithmetic-operator">/</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity_matrix_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">rbf_kernel</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">gamma</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">gamma_</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity_matrix_</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity_matrix_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity_matrix_</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the model from data in X.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            Training vector, where n_samples is the number of samples
            and n_features is the number of features.

            If affinity is "precomputed"
            X : {array-like, sparse matrix}, shape (n_samples, n_samples),
            Interpret X as precomputed adjacency graph computed from
            samples.

        y : Ignored

        Returns
        -------
        self : object
            Returns the instance itself.
        """</span>

        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csr'</span><span class="punctuation">,</span> <span class="identifier">ensure_min_samples</span><span class="arithmetic-assignment">=</span><span class="int-literal">2</span><span class="punctuation">,</span>
                                <span class="identifier">estimator</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="grouping">)</span>

        <span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">{</span><span class="string-literal">"nearest_neighbors", "rbf", "precomputed"</span><span class="punctuation">,</span>
                                     <span class="string-literal">"precomputed_nearest_neighbors"</span><span class="grouping">}</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="grouping">(</span><span class="string-literal">"%s is not a valid affinity. Expected "</span>
                                  <span class="string-literal">"'precomputed', 'rbf', 'nearest_neighbors' "</span>
                                  <span class="string-literal">"or a callable."</span><span class="grouping">)</span> <span class="arithmetic-operator">%</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="logical-operator">not</span> <span class="identifier">callable</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="grouping">(</span><span class="string-literal">"'affinity' is expected to be an affinity "</span>
                              <span class="string-literal">"name or a callable. Got: %s"</span><span class="grouping">)</span> <span class="arithmetic-operator">%</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">affinity</span><span class="grouping">)</span>

        <span class="identifier">affinity_matrix</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_get_affinity_matrix</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">embedding_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">spectral_embedding</span><span class="grouping">(</span><span class="identifier">affinity_matrix</span><span class="punctuation">,</span>
                                             <span class="identifier">n_components</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_components</span><span class="punctuation">,</span>
                                             <span class="identifier">eigen_solver</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">eigen_solver</span><span class="punctuation">,</span>
                                             <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the model from data in X and transform X.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            Training vector, where n_samples is the number of samples
            and n_features is the number of features.

            If affinity is "precomputed"
            X : {array-like, sparse matrix} of shape (n_samples, n_samples),
            Interpret X as precomputed adjacency graph computed from
            samples.

        y : Ignored

        Returns
        -------
        X_new : array-like of shape (n_samples, n_components)
        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">embedding_</span>

    </pre>
  </body>
</html>