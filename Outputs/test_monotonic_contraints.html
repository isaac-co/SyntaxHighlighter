<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">import</span> <span class="identifier">pytest</span>

<span class="keyword">from</span> <span class="identifier">sklearn</span><span class="punctuation">.</span><span class="identifier">ensemble</span><span class="punctuation">.</span><span class="identifier">_hist_gradient_boosting</span><span class="punctuation">.</span><span class="identifier">grower</span> <span class="keyword">import</span> <span class="identifier">TreeGrower</span>
<span class="keyword">from</span> <span class="identifier">sklearn</span><span class="punctuation">.</span><span class="identifier">ensemble</span><span class="punctuation">.</span><span class="identifier">_hist_gradient_boosting</span><span class="punctuation">.</span><span class="identifier">common</span> <span class="keyword">import</span> <span class="identifier">G_H_DTYPE</span>
<span class="keyword">from</span> <span class="identifier">sklearn</span><span class="punctuation">.</span><span class="identifier">ensemble</span><span class="punctuation">.</span><span class="identifier">_hist_gradient_boosting</span><span class="punctuation">.</span><span class="identifier">common</span> <span class="keyword">import</span> <span class="identifier">X_BINNED_DTYPE</span>
<span class="keyword">from</span> <span class="identifier">sklearn</span><span class="punctuation">.</span><span class="identifier">ensemble</span><span class="punctuation">.</span><span class="identifier">_hist_gradient_boosting</span><span class="punctuation">.</span><span class="identifier">common</span> <span class="keyword">import</span> <span class="identifier">MonotonicConstraint</span>
<span class="keyword">from</span> <span class="identifier">sklearn</span><span class="punctuation">.</span><span class="identifier">ensemble</span><span class="punctuation">.</span><span class="identifier">_hist_gradient_boosting</span><span class="punctuation">.</span><span class="identifier">splitting</span> <span class="keyword">import</span> <span class="grouping">(</span>
    <span class="identifier">Splitter</span><span class="punctuation">,</span>
    <span class="identifier">compute_node_value</span>
<span class="grouping">)</span>
<span class="keyword">from</span> <span class="identifier">sklearn</span><span class="punctuation">.</span><span class="identifier">ensemble</span><span class="punctuation">.</span><span class="identifier">_hist_gradient_boosting</span><span class="punctuation">.</span><span class="identifier">histogram</span> <span class="keyword">import</span> <span class="identifier">HistogramBuilder</span>
<span class="keyword">from</span> <span class="identifier">sklearn</span><span class="punctuation">.</span><span class="identifier">ensemble</span> <span class="keyword">import</span> <span class="identifier">HistGradientBoostingRegressor</span>
<span class="keyword">from</span> <span class="identifier">sklearn</span><span class="punctuation">.</span><span class="identifier">ensemble</span> <span class="keyword">import</span> <span class="identifier">HistGradientBoostingClassifier</span>


<span class="keyword">def</span> <span class="identifier">is_increasing</span><span class="grouping">(</span><span class="identifier">a</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="keyword">return</span> <span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">diff</span><span class="grouping">(</span><span class="identifier">a</span><span class="grouping">)</span> <span class="relational-operator">&gt;=</span> <span class="float-literal">0.0</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">all</span><span class="grouping">(</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">is_decreasing</span><span class="grouping">(</span><span class="identifier">a</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="keyword">return</span> <span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">diff</span><span class="grouping">(</span><span class="identifier">a</span><span class="grouping">)</span> <span class="relational-operator">&lt;=</span> <span class="float-literal">0.0</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">all</span><span class="grouping">(</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">a</span><span class="invalid">v</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">v</span><span class="invalid">a</span><span class="invalid">l</span><span class="invalid">u</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">o</span><span class="invalid">t</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">c</span><span class="grouping">(</span><span class="identifier">predictor</span><span class="punctuation">,</span> <span class="identifier">monotonic_cst</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment"># make sure leaves values (from left to right) are either all increasing</span>
    <span class="comment"># or all decreasing (or neither) depending on the monotonic constraint.</span>
    <span class="identifier">nodes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">predictor</span><span class="punctuation">.</span><span class="identifier">nodes</span>

    <span class="keyword">def</span> <span class="identifier">get_leaves_values</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""get leaves values from left to right"""</span>
        <span class="identifier">values</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>

        <span class="keyword">def</span> <span class="identifier">depth_first_collect_leaf_values</span><span class="grouping">(</span><span class="identifier">node_idx</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">node</span> <span class="arithmetic-assignment">=</span> <span class="identifier">nodes</span><span class="grouping">[</span><span class="identifier">node_idx</span><span class="grouping">]</span>
            <span class="keyword">if</span> <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'is_leaf'</span><span class="grouping">]</span><span class="punctuation">:</span>
                <span class="identifier">values</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'value'</span><span class="grouping">]</span><span class="grouping">)</span>
                <span class="keyword">return</span>
            <span class="identifier">depth_first_collect_leaf_values</span><span class="grouping">(</span><span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'left'</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="identifier">depth_first_collect_leaf_values</span><span class="grouping">(</span><span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'right'</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="identifier">depth_first_collect_leaf_values</span><span class="grouping">(</span><span class="int-literal">0</span><span class="grouping">)</span>  <span class="comment"># start at root (0)</span>
        <span class="keyword">return</span> <span class="identifier">values</span>

    <span class="identifier">values</span> <span class="arithmetic-assignment">=</span> <span class="identifier">get_leaves_values</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">monotonic_cst</span> <span class="relational-operator">==</span> <span class="identifier">MonotonicConstraint</span><span class="punctuation">.</span><span class="identifier">NO_CST</span><span class="punctuation">:</span>
        <span class="comment"># some increasing, some decreasing</span>
        <span class="keyword">assert</span> <span class="logical-operator">not</span> <span class="identifier">is_increasing</span><span class="grouping">(</span><span class="identifier">values</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="logical-operator">not</span> <span class="identifier">is_decreasing</span><span class="grouping">(</span><span class="identifier">values</span><span class="grouping">)</span>
    <span class="keyword">elif</span> <span class="identifier">monotonic_cst</span> <span class="relational-operator">==</span> <span class="identifier">MonotonicConstraint</span><span class="punctuation">.</span><span class="identifier">POS</span><span class="punctuation">:</span>
        <span class="comment"># all increasing</span>
        <span class="keyword">assert</span> <span class="identifier">is_increasing</span><span class="grouping">(</span><span class="identifier">values</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>  <span class="comment"># NEG</span>
        <span class="comment"># all decreasing</span>
        <span class="keyword">assert</span> <span class="identifier">is_decreasing</span><span class="grouping">(</span><span class="identifier">values</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">h</span><span class="invalid">i</span><span class="invalid">l</span><span class="invalid">d</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">v</span><span class="invalid">a</span><span class="invalid">l</span><span class="invalid">u</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">o</span><span class="invalid">t</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">c</span><span class="grouping">(</span><span class="identifier">predictor</span><span class="punctuation">,</span> <span class="identifier">monotonic_cst</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment"># Make sure siblings values respect the monotonic constraints. Left should</span>
    <span class="comment"># be lower (resp greater) than right child if constraint is POS (resp.</span>
    <span class="comment"># NEG).</span>
    <span class="comment"># Note that this property alone isn't enough to ensure full monotonicity,</span>
    <span class="comment"># since we also need to guanrantee that all the descendents of the left</span>
    <span class="comment"># child won't be greater (resp. lower) than the right child, or its</span>
    <span class="comment"># descendents. That's why we need to bound the predicted values (this is</span>
    <span class="comment"># tested in assert_children_values_bounded)</span>
    <span class="identifier">nodes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">predictor</span><span class="punctuation">.</span><span class="identifier">nodes</span>
    <span class="identifier">left_lower</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
    <span class="identifier">left_greater</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
    <span class="keyword">for</span> <span class="identifier">node</span> <span class="relational-operator">in</span> <span class="identifier">nodes</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'is_leaf'</span><span class="grouping">]</span><span class="punctuation">:</span>
            <span class="keyword">continue</span>

        <span class="identifier">left_idx</span> <span class="arithmetic-assignment">=</span> <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'left'</span><span class="grouping">]</span>
        <span class="identifier">right_idx</span> <span class="arithmetic-assignment">=</span> <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'right'</span><span class="grouping">]</span>

        <span class="keyword">if</span> <span class="identifier">nodes</span><span class="grouping">[</span><span class="identifier">left_idx</span><span class="grouping">]</span><span class="grouping">[</span><span class="string-literal">'value'] &lt; nodes[right_idx]['value'</span><span class="grouping">]</span><span class="punctuation">:</span>
            <span class="identifier">left_lower</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">node</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">nodes</span><span class="grouping">[</span><span class="identifier">left_idx</span><span class="grouping">]</span><span class="grouping">[</span><span class="string-literal">'value'] &gt; nodes[right_idx]['value'</span><span class="grouping">]</span><span class="punctuation">:</span>
            <span class="identifier">left_greater</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">node</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">monotonic_cst</span> <span class="relational-operator">==</span> <span class="identifier">MonotonicConstraint</span><span class="punctuation">.</span><span class="identifier">NO_CST</span><span class="punctuation">:</span>
        <span class="keyword">assert</span> <span class="identifier">left_lower</span> <span class="logical-operator">and</span> <span class="identifier">left_greater</span>
    <span class="keyword">elif</span> <span class="identifier">monotonic_cst</span> <span class="relational-operator">==</span> <span class="identifier">MonotonicConstraint</span><span class="punctuation">.</span><span class="identifier">POS</span><span class="punctuation">:</span>
        <span class="keyword">assert</span> <span class="identifier">left_lower</span> <span class="logical-operator">and</span> <span class="logical-operator">not</span> <span class="identifier">left_greater</span>
    <span class="keyword">else</span><span class="punctuation">:</span>  <span class="comment"># NEG</span>
        <span class="keyword">assert</span> <span class="logical-operator">not</span> <span class="identifier">left_lower</span> <span class="logical-operator">and</span> <span class="identifier">left_greater</span>


<span class="keyword">def</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">h</span><span class="invalid">i</span><span class="invalid">l</span><span class="invalid">d</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">v</span><span class="invalid">a</span><span class="invalid">l</span><span class="invalid">u</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">b</span><span class="invalid">o</span><span class="invalid">u</span><span class="invalid">n</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">(</span><span class="identifier">grower</span><span class="punctuation">,</span> <span class="identifier">monotonic_cst</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment"># Make sure that the values of the children of a node are bounded by the</span>
    <span class="comment"># middle value between that node and its sibling (if there is a monotonic</span>
    <span class="comment"># constraint).</span>
    <span class="comment"># As a bonus, we also check that the siblings values are properly ordered</span>
    <span class="comment"># which is slightly redundant with assert_children_values_monotonic (but</span>
    <span class="comment"># this check is done on the grower nodes whereas</span>
    <span class="comment"># assert_children_values_monotonic is done on the predictor nodes)</span>

    <span class="keyword">if</span> <span class="identifier">monotonic_cst</span> <span class="relational-operator">==</span> <span class="identifier">MonotonicConstraint</span><span class="punctuation">.</span><span class="identifier">NO_CST</span><span class="punctuation">:</span>
        <span class="keyword">return</span>

    <span class="keyword">def</span> <span class="identifier">recursively_check_children_node_values</span><span class="grouping">(</span><span class="identifier">node</span><span class="punctuation">,</span> <span class="identifier">right_sibling</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">is_leaf</span><span class="punctuation">:</span>
            <span class="keyword">return</span>
        <span class="keyword">if</span> <span class="identifier">right_sibling</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">middle</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">value</span> <span class="arithmetic-operator">+</span> <span class="identifier">right_sibling</span><span class="punctuation">.</span><span class="identifier">value</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="int-literal">2</span>
            <span class="keyword">if</span> <span class="identifier">monotonic_cst</span> <span class="relational-operator">==</span> <span class="identifier">MonotonicConstraint</span><span class="punctuation">.</span><span class="identifier">POS</span><span class="punctuation">:</span>
                <span class="keyword">assert</span> <span class="grouping">(</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">left_child</span><span class="punctuation">.</span><span class="identifier">value</span> <span class="relational-operator">&lt;=</span>
                        <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">right_child</span><span class="punctuation">.</span><span class="identifier">value</span> <span class="relational-operator">&lt;=</span>
                        <span class="identifier">middle</span><span class="grouping">)</span>
                <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">right_sibling</span><span class="punctuation">.</span><span class="identifier">is_leaf</span><span class="punctuation">:</span>
                    <span class="keyword">assert</span> <span class="grouping">(</span><span class="identifier">middle</span> <span class="relational-operator">&lt;=</span>
                            <span class="identifier">right_sibling</span><span class="punctuation">.</span><span class="identifier">left_child</span><span class="punctuation">.</span><span class="identifier">value</span> <span class="relational-operator">&lt;=</span>
                            <span class="identifier">right_sibling</span><span class="punctuation">.</span><span class="identifier">right_child</span><span class="punctuation">.</span><span class="identifier">value</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>  <span class="comment"># NEG</span>
                <span class="keyword">assert</span> <span class="grouping">(</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">left_child</span><span class="punctuation">.</span><span class="identifier">value</span> <span class="relational-operator">&gt;=</span>
                        <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">right_child</span><span class="punctuation">.</span><span class="identifier">value</span> <span class="relational-operator">&gt;=</span>
                        <span class="identifier">middle</span><span class="grouping">)</span>
                <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">right_sibling</span><span class="punctuation">.</span><span class="identifier">is_leaf</span><span class="punctuation">:</span>
                    <span class="keyword">assert</span> <span class="grouping">(</span><span class="identifier">middle</span> <span class="relational-operator">&gt;=</span>
                            <span class="identifier">right_sibling</span><span class="punctuation">.</span><span class="identifier">left_child</span><span class="punctuation">.</span><span class="identifier">value</span> <span class="relational-operator">&gt;=</span>
                            <span class="identifier">right_sibling</span><span class="punctuation">.</span><span class="identifier">right_child</span><span class="punctuation">.</span><span class="identifier">value</span><span class="grouping">)</span>

        <span class="identifier">recursively_check_children_node_values</span><span class="grouping">(</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">left_child</span><span class="punctuation">,</span>
                                               <span class="identifier">right_sibling</span><span class="arithmetic-assignment">=</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">right_child</span><span class="grouping">)</span>
        <span class="identifier">recursively_check_children_node_values</span><span class="grouping">(</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">right_child</span><span class="grouping">)</span>

    <span class="identifier">recursively_check_children_node_values</span><span class="grouping">(</span><span class="identifier">grower</span><span class="punctuation">.</span><span class="identifier">root</span><span class="grouping">)</span>


<span class="punctuation">@</span><span class="identifier">pytest</span><span class="punctuation">.</span><span class="identifier">mark</span><span class="punctuation">.</span><span class="identifier">parametrize</span><span class="grouping">(</span><span class="string-literal">'seed'</span><span class="punctuation">,</span> <span class="identifier">range</span><span class="grouping">(</span><span class="int-literal">3</span><span class="grouping">)</span><span class="grouping">)</span>
<span class="punctuation">@</span><span class="identifier">pytest</span><span class="punctuation">.</span><span class="identifier">mark</span><span class="punctuation">.</span><span class="identifier">parametrize</span><span class="grouping">(</span><span class="string-literal">'monotonic_cst'</span><span class="punctuation">,</span> <span class="grouping">(</span>
    <span class="identifier">MonotonicConstraint</span><span class="punctuation">.</span><span class="identifier">NO_CST</span><span class="punctuation">,</span>
    <span class="identifier">MonotonicConstraint</span><span class="punctuation">.</span><span class="identifier">POS</span><span class="punctuation">,</span>
    <span class="identifier">MonotonicConstraint</span><span class="punctuation">.</span><span class="identifier">NEG</span><span class="punctuation">,</span>
<span class="grouping">)</span><span class="grouping">)</span>
<span class="keyword">def</span> <span class="identifier">test_nodes_values</span><span class="grouping">(</span><span class="identifier">monotonic_cst</span><span class="punctuation">,</span> <span class="identifier">seed</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment"># Build a single tree with only one feature, and make sure the nodes</span>
    <span class="comment"># values respect the monotonic constraints.</span>

    <span class="comment"># Considering the following tree with a monotonic POS constraint, we</span>
    <span class="comment"># should have:</span>
    <span class="comment">#</span>
    <span class="comment">#       root</span>
    <span class="comment">#      /    \</span>
    <span class="comment">#     5     10    # middle = 7.5</span>
    <span class="comment">#    / \   / \</span>
    <span class="comment">#   a  b  c  d</span>
    <span class="comment">#</span>
    <span class="comment"># a &lt;= b and c &lt;= d  (assert_children_values_monotonic)</span>
    <span class="comment"># a, b &lt;= middle &lt;= c, d (assert_children_values_bounded)</span>
    <span class="comment"># a &lt;= b &lt;= c &lt;= d (assert_leaves_values_monotonic)</span>
    <span class="comment">#</span>
    <span class="comment"># The last one is a consequence of the others, but can't hurt to check</span>

    <span class="identifier">rng</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">random</span><span class="punctuation">.</span><span class="identifier">RandomState</span><span class="grouping">(</span><span class="identifier">seed</span><span class="grouping">)</span>
    <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1000</span>
    <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>
    <span class="identifier">X_binned</span> <span class="arithmetic-assignment">=</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">randint</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="int-literal">255</span><span class="punctuation">,</span> <span class="identifier">size</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">,</span>
                           <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">uint8</span><span class="grouping">)</span>
    <span class="identifier">X_binned</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">n</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">X_binned</span><span class="grouping">)</span>

    <span class="identifier">gradients</span> <span class="arithmetic-assignment">=</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">normal</span><span class="grouping">(</span><span class="identifier">size</span><span class="arithmetic-assignment">=</span><span class="identifier">n_samples</span><span class="grouping">)</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">G_H_DTYPE</span><span class="grouping">)</span>
    <span class="identifier">hessians</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ones</span><span class="grouping">(</span><span class="identifier">shape</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">G_H_DTYPE</span><span class="grouping">)</span>

    <span class="identifier">grower</span> <span class="arithmetic-assignment">=</span> <span class="identifier">TreeGrower</span><span class="grouping">(</span><span class="identifier">X_binned</span><span class="punctuation">,</span> <span class="identifier">gradients</span><span class="punctuation">,</span> <span class="identifier">hessians</span><span class="punctuation">,</span>
                        <span class="identifier">monotonic_cst</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">monotonic_cst</span><span class="grouping">]</span><span class="punctuation">,</span>
                        <span class="identifier">shrinkage</span><span class="arithmetic-assignment">=</span><span class="float-literal">.1</span><span class="grouping">)</span>
    <span class="identifier">grower</span><span class="punctuation">.</span><span class="identifier">grow</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="comment"># grow() will shrink the leaves values at the very end. For our comparison</span>
    <span class="comment"># tests, we need to revert the shrinkage of the leaves, else we would</span>
    <span class="comment"># compare the value of a leaf (shrunk) with a node (not shrunk) and the</span>
    <span class="comment"># test would not be correct.</span>
    <span class="keyword">for</span> <span class="identifier">leave</span> <span class="relational-operator">in</span> <span class="identifier">grower</span><span class="punctuation">.</span><span class="identifier">finalized_leaves</span><span class="punctuation">:</span>
        <span class="identifier">leave</span><span class="punctuation">.</span><span class="identifier">value</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">grower</span><span class="punctuation">.</span><span class="identifier">shrinkage</span>

    <span class="comment"># We pass undefined binning_thresholds because we won't use predict anyway</span>
    <span class="identifier">predictor</span> <span class="arithmetic-assignment">=</span> <span class="identifier">grower</span><span class="punctuation">.</span><span class="identifier">make_predictor</span><span class="grouping">(</span>
        <span class="identifier">binning_thresholds</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">X_binned</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X_binned</span><span class="punctuation">.</span><span class="identifier">max</span><span class="grouping">(</span><span class="grouping">)</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="grouping">)</span>

    <span class="comment"># The consistency of the bounds can only be checked on the tree grower</span>
    <span class="comment"># as the node bounds are not copied into the predictor tree. The</span>
    <span class="comment"># consistency checks on the values of node children and leaves can be</span>
    <span class="comment"># done either on the grower tree or on the predictor tree. We only</span>
    <span class="comment"># do those checks on the predictor tree as the latter is derived from</span>
    <span class="comment"># the former.</span>
    <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">h</span><span class="invalid">i</span><span class="invalid">l</span><span class="invalid">d</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">v</span><span class="invalid">a</span><span class="invalid">l</span><span class="invalid">u</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">o</span><span class="invalid">t</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">c</span><span class="grouping">(</span><span class="identifier">predictor</span><span class="punctuation">,</span> <span class="identifier">monotonic_cst</span><span class="grouping">)</span>
    <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">h</span><span class="invalid">i</span><span class="invalid">l</span><span class="invalid">d</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">v</span><span class="invalid">a</span><span class="invalid">l</span><span class="invalid">u</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">b</span><span class="invalid">o</span><span class="invalid">u</span><span class="invalid">n</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">(</span><span class="identifier">grower</span><span class="punctuation">,</span> <span class="identifier">monotonic_cst</span><span class="grouping">)</span>
    <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">a</span><span class="invalid">v</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">v</span><span class="invalid">a</span><span class="invalid">l</span><span class="invalid">u</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">o</span><span class="invalid">t</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">c</span><span class="grouping">(</span><span class="identifier">predictor</span><span class="punctuation">,</span> <span class="identifier">monotonic_cst</span><span class="grouping">)</span>


<span class="punctuation">@</span><span class="identifier">pytest</span><span class="punctuation">.</span><span class="identifier">mark</span><span class="punctuation">.</span><span class="identifier">parametrize</span><span class="grouping">(</span><span class="string-literal">'seed'</span><span class="punctuation">,</span> <span class="identifier">range</span><span class="grouping">(</span><span class="int-literal">3</span><span class="grouping">)</span><span class="grouping">)</span>
<span class="keyword">def</span> <span class="identifier">test_predictions</span><span class="grouping">(</span><span class="identifier">seed</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment"># Train a model with a POS constraint on the first feature and a NEG</span>
    <span class="comment"># constraint on the second feature, and make sure the constraints are</span>
    <span class="comment"># respected by checking the predictions.</span>
    <span class="comment"># test adapted from lightgbm's test_monotone_constraint(), itself inspired</span>
    <span class="comment"># by https://xgboost.readthedocs.io/en/latest/tutorials/monotonic.html</span>

    <span class="identifier">rng</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">random</span><span class="punctuation">.</span><span class="identifier">RandomState</span><span class="grouping">(</span><span class="identifier">seed</span><span class="grouping">)</span>

    <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1000</span>
    <span class="identifier">f_0</span> <span class="arithmetic-assignment">=</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">rand</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="grouping">)</span>  <span class="comment"># positive correlation with y</span>
    <span class="identifier">f_1</span> <span class="arithmetic-assignment">=</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">rand</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="grouping">)</span>  <span class="comment"># negative correslation with y</span>
    <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">c_</span><span class="grouping">[</span><span class="identifier">f_0</span><span class="punctuation">,</span> <span class="identifier">f_1</span><span class="grouping">]</span>
    <span class="identifier">noise</span> <span class="arithmetic-assignment">=</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">normal</span><span class="grouping">(</span><span class="identifier">loc</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.0</span><span class="punctuation">,</span> <span class="identifier">scale</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.01</span><span class="punctuation">,</span> <span class="identifier">size</span><span class="arithmetic-assignment">=</span><span class="identifier">n_samples</span><span class="grouping">)</span>
    <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="int-literal">5</span> <span class="arithmetic-operator">*</span> <span class="identifier">f_0</span> <span class="arithmetic-operator">+</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sin</span><span class="grouping">(</span><span class="int-literal">10</span> <span class="arithmetic-operator">*</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">pi</span> <span class="arithmetic-operator">*</span> <span class="identifier">f_0</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span>
         <span class="int-literal">5</span> <span class="arithmetic-operator">*</span> <span class="identifier">f_1</span> <span class="arithmetic-operator">-</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">cos</span><span class="grouping">(</span><span class="int-literal">10</span> <span class="arithmetic-operator">*</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">pi</span> <span class="arithmetic-operator">*</span> <span class="identifier">f_1</span><span class="grouping">)</span> <span class="arithmetic-operator">+</span>
         <span class="identifier">noise</span><span class="grouping">)</span>

    <span class="identifier">gbdt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">HistGradientBoostingRegressor</span><span class="grouping">(</span><span class="identifier">monotonic_cst</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
    <span class="identifier">gbdt</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>

    <span class="identifier">linspace</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">linspace</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="int-literal">100</span><span class="grouping">)</span>
    <span class="identifier">sin</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sin</span><span class="grouping">(</span><span class="identifier">linspace</span><span class="grouping">)</span>
    <span class="identifier">constant</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">full_like</span><span class="grouping">(</span><span class="identifier">linspace</span><span class="punctuation">,</span> <span class="identifier">fill_value</span><span class="arithmetic-assignment">=</span><span class="float-literal">.5</span><span class="grouping">)</span>

    <span class="comment"># We now assert the predictions properly respect the constraints, on each</span>
    <span class="comment"># feature. When testing for a feature we need to set the other one to a</span>
    <span class="comment"># constant, because the monotonic constraints are only a "all else being</span>
    <span class="comment"># equal" type of constraints:</span>
    <span class="comment"># a constraint on the first feature only means that</span>
    <span class="comment"># x0 &lt; x0' =&gt; f(x0, x1) &lt; f(x0', x1)</span>
    <span class="comment"># while x1 stays constant.</span>
    <span class="comment"># The constraint does not guanrantee that</span>
    <span class="comment"># x0 &lt; x0' =&gt; f(x0, x1) &lt; f(x0', x1')</span>

    <span class="comment"># First feature (POS)</span>
    <span class="comment"># assert pred is all increasing when f_0 is all increasing</span>
    <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">c_</span><span class="grouping">[</span><span class="identifier">linspace</span><span class="punctuation">,</span> <span class="identifier">constant</span><span class="grouping">]</span>
    <span class="identifier">pred</span> <span class="arithmetic-assignment">=</span> <span class="identifier">gbdt</span><span class="punctuation">.</span><span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="keyword">assert</span> <span class="identifier">is_increasing</span><span class="grouping">(</span><span class="identifier">pred</span><span class="grouping">)</span>
    <span class="comment"># assert pred actually follows the variations of f_0</span>
    <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">c_</span><span class="grouping">[</span><span class="identifier">sin</span><span class="punctuation">,</span> <span class="identifier">constant</span><span class="grouping">]</span>
    <span class="identifier">pred</span> <span class="arithmetic-assignment">=</span> <span class="identifier">gbdt</span><span class="punctuation">.</span><span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="keyword">assert</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">all</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">diff</span><span class="grouping">(</span><span class="identifier">pred</span><span class="grouping">)</span> <span class="relational-operator">&gt;=</span> <span class="int-literal">0</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">diff</span><span class="grouping">(</span><span class="identifier">sin</span><span class="grouping">)</span> <span class="relational-operator">&gt;=</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="comment"># Second feature (NEG)</span>
    <span class="comment"># assert pred is all decreasing when f_1 is all increasing</span>
    <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">c_</span><span class="grouping">[</span><span class="identifier">constant</span><span class="punctuation">,</span> <span class="identifier">linspace</span><span class="grouping">]</span>
    <span class="identifier">pred</span> <span class="arithmetic-assignment">=</span> <span class="identifier">gbdt</span><span class="punctuation">.</span><span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="keyword">assert</span> <span class="identifier">is_decreasing</span><span class="grouping">(</span><span class="identifier">pred</span><span class="grouping">)</span>
    <span class="comment"># assert pred actually follows the inverse variations of f_1</span>
    <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">c_</span><span class="grouping">[</span><span class="identifier">constant</span><span class="punctuation">,</span> <span class="identifier">sin</span><span class="grouping">]</span>
    <span class="identifier">pred</span> <span class="arithmetic-assignment">=</span> <span class="identifier">gbdt</span><span class="punctuation">.</span><span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="keyword">assert</span> <span class="grouping">(</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">diff</span><span class="grouping">(</span><span class="identifier">pred</span><span class="grouping">)</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">diff</span><span class="grouping">(</span><span class="identifier">sin</span><span class="grouping">)</span> <span class="relational-operator">&gt;=</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">all</span><span class="grouping">(</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">test_input_error</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">[</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="int-literal">2</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="grouping">[</span><span class="int-literal">2</span><span class="punctuation">,</span> <span class="int-literal">3</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="grouping">[</span><span class="int-literal">3</span><span class="punctuation">,</span> <span class="int-literal">4</span><span class="grouping">]</span><span class="grouping">]</span>
    <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="int-literal">2</span><span class="grouping">]</span>

    <span class="identifier">gbdt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">HistGradientBoostingRegressor</span><span class="grouping">(</span><span class="identifier">monotonic_cst</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
    <span class="keyword">with</span> <span class="identifier">pytest</span><span class="punctuation">.</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">(</span><span class="identifier">ValueError</span><span class="punctuation">,</span>
                       <span class="identifier">match</span><span class="arithmetic-assignment">=</span><span class="string-literal">'monotonic_cst has shape 3 but the input data'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">gbdt</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>

    <span class="keyword">for</span> <span class="identifier">monotonic_cst</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="grouping">[</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="int-literal">3</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="grouping">[</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">3</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">gbdt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">HistGradientBoostingRegressor</span><span class="grouping">(</span><span class="identifier">monotonic_cst</span><span class="arithmetic-assignment">=</span><span class="identifier">monotonic_cst</span><span class="grouping">)</span>
        <span class="keyword">with</span> <span class="identifier">pytest</span><span class="punctuation">.</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">(</span><span class="identifier">ValueError</span><span class="punctuation">,</span>
                           <span class="identifier">match</span><span class="arithmetic-assignment">=</span><span class="string-literal">'must be None or an array-like of '</span>
                                 <span class="string-literal">'-1, 0 or 1'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">gbdt</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>

    <span class="identifier">gbdt</span> <span class="arithmetic-assignment">=</span> <span class="identifier">HistGradientBoostingClassifier</span><span class="grouping">(</span><span class="identifier">monotonic_cst</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
    <span class="keyword">with</span> <span class="identifier">pytest</span><span class="punctuation">.</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="grouping">(</span>
            <span class="identifier">ValueError</span><span class="punctuation">,</span>
            <span class="identifier">match</span><span class="arithmetic-assignment">=</span><span class="string-literal">'monotonic constraints are not supported '</span>
                  <span class="string-literal">'for multiclass classification'</span>
            <span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">gbdt</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">test_bounded_value_min_gain_to_split</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment"># The purpose of this test is to show that when computing the gain at a</span>
    <span class="comment"># given split, the value of the current node should be properly bounded to</span>
    <span class="comment"># respect the monotonic constraints, because it strongly interacts with</span>
    <span class="comment"># min_gain_to_split. We build a simple example where gradients are [1, 1,</span>
    <span class="comment"># 100, 1, 1] (hessians are all ones). The best split happens on the 3rd</span>
    <span class="comment"># bin, and depending on whether the value of the node is bounded or not,</span>
    <span class="comment"># the min_gain_to_split constraint is or isn't satisfied.</span>
    <span class="identifier">l2_regularization</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
    <span class="identifier">min_hessian_to_split</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
    <span class="identifier">min_samples_leaf</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>
    <span class="identifier">n_bins</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">5</span>
    <span class="identifier">X_binned</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">X_BINNED_DTYPE</span><span class="grouping">)</span>
    <span class="identifier">sample_indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">uint32</span><span class="grouping">)</span>
    <span class="identifier">all_hessians</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ones</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">G_H_DTYPE</span><span class="grouping">)</span>
    <span class="identifier">all_gradients</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="int-literal">100</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">G_H_DTYPE</span><span class="grouping">)</span>
    <span class="identifier">sum_gradients</span> <span class="arithmetic-assignment">=</span> <span class="identifier">all_gradients</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="identifier">sum_hessians</span> <span class="arithmetic-assignment">=</span> <span class="identifier">all_hessians</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="identifier">hessians_are_constant</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>

    <span class="identifier">builder</span> <span class="arithmetic-assignment">=</span> <span class="identifier">HistogramBuilder</span><span class="grouping">(</span><span class="identifier">X_binned</span><span class="punctuation">,</span> <span class="identifier">n_bins</span><span class="punctuation">,</span> <span class="identifier">all_gradients</span><span class="punctuation">,</span>
                               <span class="identifier">all_hessians</span><span class="punctuation">,</span> <span class="identifier">hessians_are_constant</span><span class="grouping">)</span>
    <span class="identifier">n_bins_non_missing</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span><span class="identifier">n_bins</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">X_binned</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span>
                                  <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">uint32</span><span class="grouping">)</span>
    <span class="identifier">has_missing_values</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span><span class="bool-literal">False</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">X_binned</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">uint8</span><span class="grouping">)</span>
    <span class="identifier">monotonic_cst</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span>
        <span class="grouping">[</span><span class="identifier">MonotonicConstraint</span><span class="punctuation">.</span><span class="identifier">NO_CST</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">X_binned</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span>
        <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">int8</span><span class="grouping">)</span>
    <span class="identifier">is_categorical</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros_like</span><span class="grouping">(</span><span class="identifier">monotonic_cst</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">uint8</span><span class="grouping">)</span>
    <span class="identifier">missing_values_bin_idx</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_bins</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span>
    <span class="identifier">children_lower_bound</span><span class="punctuation">,</span> <span class="identifier">children_upper_bound</span> <span class="arithmetic-assignment">=</span> <span class="arithmetic-operator">-</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">inf</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">inf</span>

    <span class="identifier">min_gain_to_split</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">2000</span>
    <span class="identifier">splitter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Splitter</span><span class="grouping">(</span><span class="identifier">X_binned</span><span class="punctuation">,</span> <span class="identifier">n_bins_non_missing</span><span class="punctuation">,</span> <span class="identifier">missing_values_bin_idx</span><span class="punctuation">,</span>
                        <span class="identifier">has_missing_values</span><span class="punctuation">,</span> <span class="identifier">is_categorical</span><span class="punctuation">,</span> <span class="identifier">monotonic_cst</span><span class="punctuation">,</span>
                        <span class="identifier">l2_regularization</span><span class="punctuation">,</span> <span class="identifier">min_hessian_to_split</span><span class="punctuation">,</span>
                        <span class="identifier">min_samples_leaf</span><span class="punctuation">,</span> <span class="identifier">min_gain_to_split</span><span class="punctuation">,</span>
                        <span class="identifier">hessians_are_constant</span><span class="grouping">)</span>

    <span class="identifier">histograms</span> <span class="arithmetic-assignment">=</span> <span class="identifier">builder</span><span class="punctuation">.</span><span class="identifier">compute_histograms_brute</span><span class="grouping">(</span><span class="identifier">sample_indices</span><span class="grouping">)</span>

    <span class="comment"># Since the gradient array is [1, 1, 100, 1, 1]</span>
    <span class="comment"># the max possible gain happens on the 3rd bin (or equivalently in the 2nd)</span>
    <span class="comment"># and is equal to about 1307, which less than min_gain_to_split = 2000, so</span>
    <span class="comment"># the node is considered unsplittable (gain = -1)</span>
    <span class="identifier">current_lower_bound</span><span class="punctuation">,</span> <span class="identifier">current_upper_bound</span> <span class="arithmetic-assignment">=</span> <span class="arithmetic-operator">-</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">inf</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">inf</span>
    <span class="identifier">value</span> <span class="arithmetic-assignment">=</span> <span class="identifier">compute_node_value</span><span class="grouping">(</span><span class="identifier">sum_gradients</span><span class="punctuation">,</span> <span class="identifier">sum_hessians</span><span class="punctuation">,</span>
                               <span class="identifier">current_lower_bound</span><span class="punctuation">,</span> <span class="identifier">current_upper_bound</span><span class="punctuation">,</span>
                               <span class="identifier">l2_regularization</span><span class="grouping">)</span>
    <span class="comment"># the unbounded value is equal to -sum_gradients / sum_hessians</span>
    <span class="keyword">assert</span> <span class="identifier">value</span> <span class="relational-operator">==</span> <span class="identifier">pytest</span><span class="punctuation">.</span><span class="identifier">approx</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="int-literal">104</span> <span class="arithmetic-operator">/</span> <span class="int-literal">5</span><span class="grouping">)</span>
    <span class="identifier">split_info</span> <span class="arithmetic-assignment">=</span> <span class="identifier">splitter</span><span class="punctuation">.</span><span class="identifier">find_node_split</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">histograms</span><span class="punctuation">,</span>
                                          <span class="identifier">sum_gradients</span><span class="punctuation">,</span> <span class="identifier">sum_hessians</span><span class="punctuation">,</span> <span class="identifier">value</span><span class="punctuation">,</span>
                                          <span class="identifier">lower_bound</span><span class="arithmetic-assignment">=</span><span class="identifier">children_lower_bound</span><span class="punctuation">,</span>
                                          <span class="identifier">upper_bound</span><span class="arithmetic-assignment">=</span><span class="identifier">children_upper_bound</span><span class="grouping">)</span>
    <span class="keyword">assert</span> <span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">gain</span> <span class="relational-operator">==</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span>  <span class="comment"># min_gain_to_split not respected</span>

    <span class="comment"># here again the max possible gain is on the 3rd bin but we now cap the</span>
    <span class="comment"># value of the node into [-10, inf].</span>
    <span class="comment"># This means the gain is now about 2430 which is more than the</span>
    <span class="comment"># min_gain_to_split constraint.</span>
    <span class="identifier">current_lower_bound</span><span class="punctuation">,</span> <span class="identifier">current_upper_bound</span> <span class="arithmetic-assignment">=</span> <span class="arithmetic-operator">-</span><span class="int-literal">10</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">inf</span>
    <span class="identifier">value</span> <span class="arithmetic-assignment">=</span> <span class="identifier">compute_node_value</span><span class="grouping">(</span><span class="identifier">sum_gradients</span><span class="punctuation">,</span> <span class="identifier">sum_hessians</span><span class="punctuation">,</span>
                               <span class="identifier">current_lower_bound</span><span class="punctuation">,</span> <span class="identifier">current_upper_bound</span><span class="punctuation">,</span>
                               <span class="identifier">l2_regularization</span><span class="grouping">)</span>
    <span class="keyword">assert</span> <span class="identifier">value</span> <span class="relational-operator">==</span> <span class="arithmetic-operator">-</span><span class="int-literal">10</span>
    <span class="identifier">split_info</span> <span class="arithmetic-assignment">=</span> <span class="identifier">splitter</span><span class="punctuation">.</span><span class="identifier">find_node_split</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">histograms</span><span class="punctuation">,</span>
                                          <span class="identifier">sum_gradients</span><span class="punctuation">,</span> <span class="identifier">sum_hessians</span><span class="punctuation">,</span> <span class="identifier">value</span><span class="punctuation">,</span>
                                          <span class="identifier">lower_bound</span><span class="arithmetic-assignment">=</span><span class="identifier">children_lower_bound</span><span class="punctuation">,</span>
                                          <span class="identifier">upper_bound</span><span class="arithmetic-assignment">=</span><span class="identifier">children_upper_bound</span><span class="grouping">)</span>
    <span class="keyword">assert</span> <span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">gain</span> <span class="relational-operator">&gt;</span> <span class="identifier">min_gain_to_split</span>

    </pre>
  </body>
</html>