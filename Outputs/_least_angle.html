<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""
Least Angle Regression algorithm. See the documentation on the
Generalized Linear Model for a complete discussion.
"""</span>
<span class="comment"># Author: Fabian Pedregosa &lt;fabian.pedregosa@inria.fr&gt;</span>
<span class="comment">#         Alexandre Gramfort &lt;alexandre.gramfort@inria.fr&gt;</span>
<span class="comment">#         Gael Varoquaux</span>
<span class="comment">#</span>
<span class="comment"># License: BSD 3 clause</span>

<span class="keyword">from</span> <span class="identifier">math</span> <span class="keyword">import</span> <span class="identifier">log</span>
<span class="keyword">import</span> <span class="identifier">sys</span>
<span class="keyword">import</span> <span class="identifier">warnings</span>

<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">from</span> <span class="identifier">scipy</span> <span class="keyword">import</span> <span class="identifier">linalg</span><span class="punctuation">,</span> <span class="identifier">interpolate</span>
<span class="keyword">from</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">lapack</span> <span class="keyword">import</span> <span class="identifier">get_lapack_funcs</span>
<span class="keyword">from</span> <span class="identifier">joblib</span> <span class="keyword">import</span> <span class="identifier">Parallel</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_base</span> <span class="keyword">import</span> <span class="identifier">LinearModel</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">RegressorMixin</span><span class="punctuation">,</span> <span class="identifier">MultiOutputMixin</span>
<span class="comment"># mypy error: Module 'sklearn.utils' has no attribute 'arrayfuncs'</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">arrayfuncs</span><span class="punctuation">,</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">l</span><span class="invalid">o</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span>  <span class="comment"># type: ignore</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">check_random_state</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">model_selection</span> <span class="keyword">import</span> <span class="identifier">check_cv</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="invalid">e</span><span class="invalid">x</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="invalid">i</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">s</span> <span class="keyword">import</span> <span class="identifier">ConvergenceWarning</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">fixes</span> <span class="keyword">import</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span>

<span class="identifier">SOLVE_TRIANGULAR_ARGS</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="string-literal">'check_finite'</span><span class="punctuation">:</span> <span class="bool-literal">False</span><span class="grouping">}</span>


<span class="keyword">def</span> <span class="identifier">lars_path</span><span class="grouping">(</span>
    <span class="identifier">X</span><span class="punctuation">,</span>
    <span class="identifier">y</span><span class="punctuation">,</span>
    <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
    <span class="arithmetic-operator">*</span><span class="punctuation">,</span>
    <span class="identifier">Gram</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
    <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">500</span><span class="punctuation">,</span>
    <span class="identifier">alpha_min</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span>
    <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="string-literal">"lar"</span><span class="punctuation">,</span>
    <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
    <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">float</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="punctuation">,</span>
    <span class="identifier">copy_Gram</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
    <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span>
    <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">h</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
    <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
    <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span>
<span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Compute Least Angle Regression or Lasso path using LARS algorithm [1]

    The optimization objective for the case method='lasso' is::

    (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1

    in the case of method='lars', the objective function is only known in
    the form of an implicit equation (see discussion in [1])

    Read more in the :ref:`User Guide &lt;least_angle_regression&gt;`.

    Parameters
    ----------
    X : None or array-like of shape (n_samples, n_features)
        Input data. Note that if X is None then the Gram matrix must be
        specified, i.e., cannot be None or False.

    y : None or array-like of shape (n_samples,)
        Input targets.

    Xy : array-like of shape (n_samples,) or (n_samples, n_targets), \
            default=None
        Xy = np.dot(X.T, y) that can be precomputed. It is useful
        only when the Gram matrix is precomputed.

    Gram : None, 'auto', array-like of shape (n_features, n_features), \
            default=None
        Precomputed Gram matrix (X' * X), if ``'auto'``, the Gram
        matrix is precomputed from the given X, if there are more samples
        than features.

    max_iter : int, default=500
        Maximum number of iterations to perform, set to infinity for no limit.

    alpha_min : float, default=0
        Minimum correlation along the path. It corresponds to the
        regularization parameter alpha parameter in the Lasso.

    method : {'lar', 'lasso'}, default='lar'
        Specifies the returned model. Select ``'lar'`` for Least Angle
        Regression, ``'lasso'`` for the Lasso.

    copy_X : bool, default=True
        If ``False``, ``X`` is overwritten.

    eps : float, default=np.finfo(float).eps
        The machine-precision regularization in the computation of the
        Cholesky diagonal factors. Increase this for very ill-conditioned
        systems. Unlike the ``tol`` parameter in some iterative
        optimization-based algorithms, this parameter does not control
        the tolerance of the optimization.

    copy_Gram : bool, default=True
        If ``False``, ``Gram`` is overwritten.

    verbose : int, default=0
        Controls output verbosity.

    return_path : bool, default=True
        If ``return_path==True`` returns the entire path, else returns only the
        last point of the path.

    return_n_iter : bool, default=False
        Whether to return the number of iterations.

    positive : bool, default=False
        Restrict coefficients to be &gt;= 0.
        This option is only allowed with method 'lasso'. Note that the model
        coefficients will not converge to the ordinary-least-squares solution
        for small values of alpha. Only coefficients up to the smallest alpha
        value (``alphas_[alphas_ &gt; 0.].min()`` when fit_path=True) reached by
        the stepwise Lars-Lasso algorithm are typically in congruence with the
        solution of the coordinate descent lasso_path function.

    Returns
    -------
    alphas : array-like of shape (n_alphas + 1,)
        Maximum of covariances (in absolute value) at each iteration.
        ``n_alphas`` is either ``max_iter``, ``n_features`` or the
        number of nodes in the path with ``alpha &gt;= alpha_min``, whichever
        is smaller.

    active : array-like of shape (n_alphas,)
        Indices of active variables at the end of the path.

    coefs : array-like of shape (n_features, n_alphas + 1)
        Coefficients along the path

    n_iter : int
        Number of iterations run. Returned only if return_n_iter is set
        to True.

    See Also
    --------
    lars_path_gram
    lasso_path
    lasso_path_gram
    LassoLars
    Lars
    LassoLarsCV
    LarsCV
    sklearn.decomposition.sparse_encode

    References
    ----------
    .. [1] "Least Angle Regression", Efron et al.
           http://statweb.stanford.edu/~tibs/ftp/lars.pdf

    .. [2] `Wikipedia entry on the Least-angle regression
           &lt;https://en.wikipedia.org/wiki/Least-angle_regression&gt;`_

    .. [3] `Wikipedia entry on the Lasso
           &lt;https://en.wikipedia.org/wiki/Lasso_(statistics)&gt;`_

    """</span>
    <span class="keyword">if</span> <span class="identifier">X</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">Gram</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
            <span class="string-literal">'X cannot be None if Gram is not None'</span>
            <span class="string-literal">'Use lars_path_gram to avoid passing X and y.'</span>
        <span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">_lars_path_solver</span><span class="grouping">(</span>
        <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="identifier">Xy</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="arithmetic-assignment">=</span><span class="identifier">Gram</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
        <span class="identifier">alpha_min</span><span class="arithmetic-assignment">=</span><span class="identifier">alpha_min</span><span class="punctuation">,</span> <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="identifier">method</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="identifier">copy_X</span><span class="punctuation">,</span>
        <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="identifier">copy_Gram</span><span class="arithmetic-assignment">=</span><span class="identifier">copy_Gram</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">h</span><span class="arithmetic-assignment">=</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">h</span><span class="punctuation">,</span>
        <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="identifier">positive</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">lars_path_gram</span><span class="grouping">(</span>
    <span class="identifier">Xy</span><span class="punctuation">,</span>
    <span class="identifier">Gram</span><span class="punctuation">,</span>
    <span class="arithmetic-operator">*</span><span class="punctuation">,</span>
    <span class="identifier">n_samples</span><span class="punctuation">,</span>
    <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">500</span><span class="punctuation">,</span>
    <span class="identifier">alpha_min</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span>
    <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="string-literal">"lar"</span><span class="punctuation">,</span>
    <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
    <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">float</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="punctuation">,</span>
    <span class="identifier">copy_Gram</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
    <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span>
    <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">h</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
    <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
    <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span>
<span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""lars_path in the sufficient stats mode [1]

    The optimization objective for the case method='lasso' is::

    (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1

    in the case of method='lars', the objective function is only known in
    the form of an implicit equation (see discussion in [1])

    Read more in the :ref:`User Guide &lt;least_angle_regression&gt;`.

    Parameters
    ----------
    Xy : array-like of shape (n_samples,) or (n_samples, n_targets)
        Xy = np.dot(X.T, y).

    Gram : array-like of shape (n_features, n_features)
        Gram = np.dot(X.T * X).

    n_samples : int or float
        Equivalent size of sample.

    max_iter : int, default=500
        Maximum number of iterations to perform, set to infinity for no limit.

    alpha_min : float, default=0
        Minimum correlation along the path. It corresponds to the
        regularization parameter alpha parameter in the Lasso.

    method : {'lar', 'lasso'}, default='lar'
        Specifies the returned model. Select ``'lar'`` for Least Angle
        Regression, ``'lasso'`` for the Lasso.

    copy_X : bool, default=True
        If ``False``, ``X`` is overwritten.

    eps : float, default=np.finfo(float).eps
        The machine-precision regularization in the computation of the
        Cholesky diagonal factors. Increase this for very ill-conditioned
        systems. Unlike the ``tol`` parameter in some iterative
        optimization-based algorithms, this parameter does not control
        the tolerance of the optimization.

    copy_Gram : bool, default=True
        If ``False``, ``Gram`` is overwritten.

    verbose : int, default=0
        Controls output verbosity.

    return_path : bool, default=True
        If ``return_path==True`` returns the entire path, else returns only the
        last point of the path.

    return_n_iter : bool, default=False
        Whether to return the number of iterations.

    positive : bool, default=False
        Restrict coefficients to be &gt;= 0.
        This option is only allowed with method 'lasso'. Note that the model
        coefficients will not converge to the ordinary-least-squares solution
        for small values of alpha. Only coefficients up to the smallest alpha
        value (``alphas_[alphas_ &gt; 0.].min()`` when fit_path=True) reached by
        the stepwise Lars-Lasso algorithm are typically in congruence with the
        solution of the coordinate descent lasso_path function.

    Returns
    -------
    alphas : array-like of shape (n_alphas + 1,)
        Maximum of covariances (in absolute value) at each iteration.
        ``n_alphas`` is either ``max_iter``, ``n_features`` or the
        number of nodes in the path with ``alpha &gt;= alpha_min``, whichever
        is smaller.

    active : array-like of shape (n_alphas,)
        Indices of active variables at the end of the path.

    coefs : array-like of shape (n_features, n_alphas + 1)
        Coefficients along the path

    n_iter : int
        Number of iterations run. Returned only if return_n_iter is set
        to True.

    See Also
    --------
    lars_path
    lasso_path
    lasso_path_gram
    LassoLars
    Lars
    LassoLarsCV
    LarsCV
    sklearn.decomposition.sparse_encode

    References
    ----------
    .. [1] "Least Angle Regression", Efron et al.
           http://statweb.stanford.edu/~tibs/ftp/lars.pdf

    .. [2] `Wikipedia entry on the Least-angle regression
           &lt;https://en.wikipedia.org/wiki/Least-angle_regression&gt;`_

    .. [3] `Wikipedia entry on the Lasso
           &lt;https://en.wikipedia.org/wiki/Lasso_(statistics)&gt;`_

    """</span>
    <span class="keyword">return</span> <span class="identifier">_lars_path_solver</span><span class="grouping">(</span>
        <span class="identifier">X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="identifier">Xy</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="arithmetic-assignment">=</span><span class="identifier">Gram</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="arithmetic-assignment">=</span><span class="identifier">n_samples</span><span class="punctuation">,</span>
        <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">alpha_min</span><span class="arithmetic-assignment">=</span><span class="identifier">alpha_min</span><span class="punctuation">,</span> <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="identifier">method</span><span class="punctuation">,</span>
        <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="identifier">copy_X</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="identifier">copy_Gram</span><span class="arithmetic-assignment">=</span><span class="identifier">copy_Gram</span><span class="punctuation">,</span>
        <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">h</span><span class="arithmetic-assignment">=</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">h</span><span class="punctuation">,</span>
        <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="identifier">positive</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_lars_path_solver</span><span class="grouping">(</span>
    <span class="identifier">X</span><span class="punctuation">,</span>
    <span class="identifier">y</span><span class="punctuation">,</span>
    <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
    <span class="identifier">Gram</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
    <span class="identifier">n_samples</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
    <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">500</span><span class="punctuation">,</span>
    <span class="identifier">alpha_min</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span>
    <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="string-literal">"lar"</span><span class="punctuation">,</span>
    <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
    <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">float</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="punctuation">,</span>
    <span class="identifier">copy_Gram</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
    <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span>
    <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">h</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
    <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
    <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
<span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Compute Least Angle Regression or Lasso path using LARS algorithm [1]

    The optimization objective for the case method='lasso' is::

    (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1

    in the case of method='lars', the objective function is only known in
    the form of an implicit equation (see discussion in [1])

    Read more in the :ref:`User Guide &lt;least_angle_regression&gt;`.

    Parameters
    ----------
    X : None or ndarray of shape (n_samples, n_features)
        Input data. Note that if X is None then Gram must be specified,
        i.e., cannot be None or False.

    y : None or ndarray of shape (n_samples,)
        Input targets.

    Xy : array-like of shape (n_samples,) or (n_samples, n_targets), \
            default=None
        `Xy = np.dot(X.T, y)` that can be precomputed. It is useful
        only when the Gram matrix is precomputed.

    Gram : None, 'auto' or array-like of shape (n_features, n_features), \
            default=None
        Precomputed Gram matrix `(X' * X)`, if ``'auto'``, the Gram
        matrix is precomputed from the given X, if there are more samples
        than features.

    n_samples : int or float, default=None
        Equivalent size of sample. If `None`, it will be `n_samples`.

    max_iter : int, default=500
        Maximum number of iterations to perform, set to infinity for no limit.

    alpha_min : float, default=0
        Minimum correlation along the path. It corresponds to the
        regularization parameter alpha parameter in the Lasso.

    method : {'lar', 'lasso'}, default='lar'
        Specifies the returned model. Select ``'lar'`` for Least Angle
        Regression, ``'lasso'`` for the Lasso.

    copy_X : bool, default=True
        If ``False``, ``X`` is overwritten.

    eps : float, default=np.finfo(float).eps
        The machine-precision regularization in the computation of the
        Cholesky diagonal factors. Increase this for very ill-conditioned
        systems. Unlike the ``tol`` parameter in some iterative
        optimization-based algorithms, this parameter does not control
        the tolerance of the optimization.

    copy_Gram : bool, default=True
        If ``False``, ``Gram`` is overwritten.

    verbose : int, default=0
        Controls output verbosity.

    return_path : bool, default=True
        If ``return_path==True`` returns the entire path, else returns only the
        last point of the path.

    return_n_iter : bool, default=False
        Whether to return the number of iterations.

    positive : bool, default=False
        Restrict coefficients to be &gt;= 0.
        This option is only allowed with method 'lasso'. Note that the model
        coefficients will not converge to the ordinary-least-squares solution
        for small values of alpha. Only coefficients up to the smallest alpha
        value (``alphas_[alphas_ &gt; 0.].min()`` when fit_path=True) reached by
        the stepwise Lars-Lasso algorithm are typically in congruence with the
        solution of the coordinate descent lasso_path function.

    Returns
    -------
    alphas : array-like of shape (n_alphas + 1,)
        Maximum of covariances (in absolute value) at each iteration.
        ``n_alphas`` is either ``max_iter``, ``n_features`` or the
        number of nodes in the path with ``alpha &gt;= alpha_min``, whichever
        is smaller.

    active : array-like of shape (n_alphas,)
        Indices of active variables at the end of the path.

    coefs : array-like of shape (n_features, n_alphas + 1)
        Coefficients along the path

    n_iter : int
        Number of iterations run. Returned only if return_n_iter is set
        to True.

    See Also
    --------
    lasso_path
    LassoLars
    Lars
    LassoLarsCV
    LarsCV
    sklearn.decomposition.sparse_encode

    References
    ----------
    .. [1] "Least Angle Regression", Efron et al.
           http://statweb.stanford.edu/~tibs/ftp/lars.pdf

    .. [2] `Wikipedia entry on the Least-angle regression
           &lt;https://en.wikipedia.org/wiki/Least-angle_regression&gt;`_

    .. [3] `Wikipedia entry on the Lasso
           &lt;https://en.wikipedia.org/wiki/Lasso_(statistics)&gt;`_

    """</span>
    <span class="keyword">if</span> <span class="identifier">method</span> <span class="relational-operator">==</span> <span class="string-literal">"lar"</span> <span class="logical-operator">and</span> <span class="identifier">positive</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
            <span class="string-literal">"Positive constraint not supported for 'lar' " "coding method."</span>
        <span class="grouping">)</span>

    <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_samples</span> <span class="keyword">if</span> <span class="identifier">n_samples</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="keyword">else</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">size</span>

    <span class="keyword">if</span> <span class="identifier">Xy</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">Cov</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">Cov</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Xy</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">Gram</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="logical-operator">or</span> <span class="identifier">Gram</span> <span class="relational-operator">is</span> <span class="bool-literal">False</span><span class="punctuation">:</span>
        <span class="identifier">Gram</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
        <span class="keyword">if</span> <span class="identifier">X</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'X and Gram cannot both be unspecified.'</span><span class="grouping">)</span>
    <span class="keyword">elif</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">Gram</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">Gram</span> <span class="relational-operator">==</span> <span class="string-literal">'auto'</span> <span class="logical-operator">or</span> <span class="identifier">Gram</span> <span class="relational-operator">is</span> <span class="bool-literal">True</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">Gram</span> <span class="relational-operator">is</span> <span class="bool-literal">True</span> <span class="logical-operator">or</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">&gt;</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">:</span>
            <span class="identifier">Gram</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">Gram</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
    <span class="keyword">elif</span> <span class="identifier">copy_Gram</span><span class="punctuation">:</span>
        <span class="identifier">Gram</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Gram</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">Gram</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Cov</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="keyword">if</span> <span class="identifier">Gram</span><span class="punctuation">.</span><span class="identifier">shape</span> <span class="relational-operator">!=</span> <span class="grouping">(</span><span class="identifier">n_features</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'The shapes of the inputs Gram and Xy'</span>
                             <span class="string-literal">' do not match.'</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">copy_X</span> <span class="logical-operator">and</span> <span class="identifier">X</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">Gram</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="comment"># force copy. setting the array to be fortran-ordered</span>
        <span class="comment"># speeds up the calculation of the (partial) Gram matrix</span>
        <span class="comment"># and allows to easily swap columns</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="string-literal">'F'</span><span class="grouping">)</span>

    <span class="identifier">max_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">min</span><span class="grouping">(</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span>

    <span class="identifier">dtypes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">set</span><span class="grouping">(</span><span class="identifier">a</span><span class="punctuation">.</span><span class="identifier">dtype</span> <span class="keyword">for</span> <span class="identifier">a</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="grouping">)</span> <span class="keyword">if</span> <span class="identifier">a</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">dtypes</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="comment"># use the precision level of input data if it is consistent</span>
        <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span> <span class="arithmetic-assignment">=</span> <span class="identifier">next</span><span class="grouping">(</span><span class="identifier">iter</span><span class="grouping">(</span><span class="identifier">dtypes</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="comment"># fallback to double precision otherwise</span>
        <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span>

    <span class="keyword">if</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">h</span><span class="punctuation">:</span>
        <span class="identifier">coefs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">max_features</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">)</span>
        <span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">max_features</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">coef</span><span class="punctuation">,</span> <span class="identifier">prev_coef</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">n_features</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">)</span><span class="punctuation">,</span>
                           <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">n_features</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">prev_alpha</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span><span class="int-literal">0</span><span class="punctuation">.</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">)</span><span class="punctuation">,</span>
                             <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="grouping">[</span><span class="int-literal">0</span><span class="punctuation">.</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="comment"># above better ideas?</span>

    <span class="identifier">n_iter</span><span class="punctuation">,</span> <span class="identifier">n_active</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">,</span> <span class="int-literal">0</span>
    <span class="identifier">active</span><span class="punctuation">,</span> <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">list</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">n_features</span><span class="grouping">)</span>
    <span class="comment"># holds the sign of covariance</span>
    <span class="identifier">sign_active</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">max_features</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">int8</span><span class="grouping">)</span>
    <span class="identifier">drop</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>

    <span class="comment"># will hold the cholesky factorization. Only lower part is</span>
    <span class="comment"># referenced.</span>
    <span class="keyword">if</span> <span class="identifier">Gram</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">L</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">max_features</span><span class="punctuation">,</span> <span class="identifier">max_features</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="identifier">swap</span><span class="punctuation">,</span> <span class="identifier">nrm2</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">get_blas_funcs</span><span class="grouping">(</span><span class="grouping">(</span><span class="string-literal">'swap', 'nrm2'</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">L</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">max_features</span><span class="punctuation">,</span> <span class="identifier">max_features</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">Gram</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="identifier">swap</span><span class="punctuation">,</span> <span class="identifier">nrm2</span> <span class="arithmetic-assignment">=</span> <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">get_blas_funcs</span><span class="grouping">(</span><span class="grouping">(</span><span class="string-literal">'swap', 'nrm2'</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">Cov</span><span class="punctuation">,</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="identifier">solve_cholesky</span><span class="punctuation">,</span> <span class="arithmetic-assignment">=</span> <span class="identifier">get_lapack_funcs</span><span class="grouping">(</span><span class="grouping">(</span><span class="string-literal">'potrs'</span><span class="punctuation">,</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">L</span><span class="punctuation">,</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">verbose</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">verbose</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"Step\t\tAdded\t\tDropped\t\tActive set size\t\tC"</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">sys</span><span class="punctuation">.</span><span class="identifier">stdout</span><span class="punctuation">.</span><span class="identifier">write</span><span class="grouping">(</span><span class="string-literal">'.'</span><span class="grouping">)</span>
            <span class="identifier">sys</span><span class="punctuation">.</span><span class="identifier">stdout</span><span class="punctuation">.</span><span class="identifier">flush</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="identifier">tiny32</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">tiny</span>  <span class="comment"># to avoid division by 0 warning</span>
    <span class="identifier">equality_tolerance</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span>

    <span class="keyword">if</span> <span class="identifier">Gram</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">Gram_copy</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Gram</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">Cov_copy</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Cov</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">while</span> <span class="bool-literal">True</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">Cov</span><span class="punctuation">.</span><span class="identifier">size</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">positive</span><span class="punctuation">:</span>
                <span class="identifier">C_idx</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argmax</span><span class="grouping">(</span><span class="identifier">Cov</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">C_idx</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argmax</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">Cov</span><span class="grouping">)</span><span class="grouping">)</span>

            <span class="identifier">C_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Cov</span><span class="grouping">[</span><span class="identifier">C_idx</span><span class="grouping">]</span>

            <span class="keyword">if</span> <span class="identifier">positive</span><span class="punctuation">:</span>
                <span class="identifier">C</span> <span class="arithmetic-assignment">=</span> <span class="identifier">C_</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">C</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">fabs</span><span class="grouping">(</span><span class="identifier">C_</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">C</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>

        <span class="keyword">if</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">h</span><span class="punctuation">:</span>
            <span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alphas</span><span class="grouping">[</span><span class="identifier">n_iter</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
            <span class="identifier">coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coefs</span><span class="grouping">[</span><span class="identifier">n_iter</span><span class="grouping">]</span>
            <span class="identifier">prev_alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alphas</span><span class="grouping">[</span><span class="identifier">n_iter</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
            <span class="identifier">prev_coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coefs</span><span class="grouping">[</span><span class="identifier">n_iter</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">]</span>

        <span class="identifier">alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">C</span> <span class="arithmetic-operator">/</span> <span class="identifier">n_samples</span>
        <span class="keyword">if</span> <span class="identifier">alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">&lt;=</span> <span class="identifier">alpha_min</span> <span class="arithmetic-operator">+</span> <span class="identifier">equality_tolerance</span><span class="punctuation">:</span>  <span class="comment"># early stopping</span>
            <span class="keyword">if</span> <span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-operator">-</span> <span class="identifier">alpha_min</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="identifier">equality_tolerance</span><span class="punctuation">:</span>
                <span class="comment"># interpolation factor 0 &lt;= ss &lt; 1</span>
                <span class="keyword">if</span> <span class="identifier">n_iter</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
                    <span class="comment"># In the first iteration, all alphas are zero, the formula</span>
                    <span class="comment"># below would make ss a NaN</span>
                    <span class="identifier">ss</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="grouping">(</span><span class="identifier">prev_alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-operator">-</span> <span class="identifier">alpha_min</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span>
                          <span class="grouping">(</span><span class="identifier">prev_alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-operator">-</span> <span class="identifier">alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>
                    <span class="identifier">coef</span><span class="grouping">[</span><span class="punctuation">:</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">prev_coef</span> <span class="arithmetic-operator">+</span> <span class="identifier">ss</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="identifier">coef</span> <span class="arithmetic-operator">-</span> <span class="identifier">prev_coef</span><span class="grouping">)</span>
                <span class="identifier">alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha_min</span>
            <span class="keyword">if</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">h</span><span class="punctuation">:</span>
                <span class="identifier">coefs</span><span class="grouping">[</span><span class="identifier">n_iter</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coef</span>
            <span class="keyword">break</span>

        <span class="keyword">if</span> <span class="identifier">n_iter</span> <span class="relational-operator">&gt;=</span> <span class="identifier">max_iter</span> <span class="logical-operator">or</span> <span class="identifier">n_active</span> <span class="relational-operator">&gt;=</span> <span class="identifier">n_features</span><span class="punctuation">:</span>
            <span class="keyword">break</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">drop</span><span class="punctuation">:</span>

            <span class="comment">##########################################################</span>
            <span class="comment"># Append x_j to the Cholesky factorization of (Xa * Xa') #</span>
            <span class="comment">#                                                        #</span>
            <span class="comment">#            ( L   0 )                                   #</span>
            <span class="comment">#     L  -&gt;  (       )  , where L * w = Xa' x_j          #</span>
            <span class="comment">#            ( w   z )    and z = ||x_j||                #</span>
            <span class="comment">#                                                        #</span>
            <span class="comment">##########################################################</span>

            <span class="keyword">if</span> <span class="identifier">positive</span><span class="punctuation">:</span>
                <span class="identifier">sign_active</span><span class="grouping">[</span><span class="identifier">n_active</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ones_like</span><span class="grouping">(</span><span class="identifier">C_</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">sign_active</span><span class="grouping">[</span><span class="identifier">n_active</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sign</span><span class="grouping">(</span><span class="identifier">C_</span><span class="grouping">)</span>
            <span class="identifier">m</span><span class="punctuation">,</span> <span class="identifier">n</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_active</span><span class="punctuation">,</span> <span class="identifier">C_idx</span> <span class="arithmetic-operator">+</span> <span class="identifier">n_active</span>

            <span class="identifier">Cov</span><span class="grouping">[</span><span class="identifier">C_idx</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Cov</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">swap</span><span class="grouping">(</span><span class="identifier">Cov</span><span class="grouping">[</span><span class="identifier">C_idx</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Cov</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">n</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">m</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">m</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">n</span><span class="grouping">]</span>
            <span class="identifier">Cov_not_shortened</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Cov</span>
            <span class="identifier">Cov</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Cov</span><span class="grouping">[</span><span class="int-literal">1</span><span class="punctuation">:</span><span class="grouping">]</span>  <span class="comment"># remove Cov[0]</span>

            <span class="keyword">if</span> <span class="identifier">Gram</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">n</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">m</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">swap</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">n</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">m</span><span class="grouping">]</span><span class="grouping">)</span>
                <span class="identifier">c</span> <span class="arithmetic-assignment">=</span> <span class="identifier">nrm2</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="grouping">)</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span>
                <span class="identifier">L</span><span class="grouping">[</span><span class="identifier">n_active</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
                    <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="comment"># swap does only work inplace if matrix is fortran</span>
                <span class="comment"># contiguous ...</span>
                <span class="identifier">Gram</span><span class="grouping">[</span><span class="identifier">m</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="grouping">[</span><span class="identifier">n</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">swap</span><span class="grouping">(</span><span class="identifier">Gram</span><span class="grouping">[</span><span class="identifier">m</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="grouping">[</span><span class="identifier">n</span><span class="grouping">]</span><span class="grouping">)</span>
                <span class="identifier">Gram</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">m</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">n</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">swap</span><span class="grouping">(</span><span class="identifier">Gram</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">m</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">n</span><span class="grouping">]</span><span class="grouping">)</span>
                <span class="identifier">c</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Gram</span><span class="grouping">[</span><span class="identifier">n_active</span><span class="punctuation">,</span> <span class="identifier">n_active</span><span class="grouping">]</span>
                <span class="identifier">L</span><span class="grouping">[</span><span class="identifier">n_active</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Gram</span><span class="grouping">[</span><span class="identifier">n_active</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span>

            <span class="comment"># Update the cholesky decomposition for the Gram matrix</span>
            <span class="keyword">if</span> <span class="identifier">n_active</span><span class="punctuation">:</span>
                <span class="identifier">linalg</span><span class="punctuation">.</span><span class="identifier">solve_triangular</span><span class="grouping">(</span><span class="identifier">L</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_active</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="punctuation">,</span>
                                        <span class="identifier">L</span><span class="grouping">[</span><span class="identifier">n_active</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="punctuation">,</span>
                                        <span class="identifier">trans</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">lower</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span>
                                        <span class="identifier">overwrite_b</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                                        <span class="arithmetic-operator">**</span><span class="identifier">SOLVE_TRIANGULAR_ARGS</span><span class="grouping">)</span>

            <span class="identifier">v</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">L</span><span class="grouping">[</span><span class="identifier">n_active</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">L</span><span class="grouping">[</span><span class="identifier">n_active</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="identifier">diag</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">c</span> <span class="arithmetic-operator">-</span> <span class="identifier">v</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="grouping">)</span>
            <span class="identifier">L</span><span class="grouping">[</span><span class="identifier">n_active</span><span class="punctuation">,</span> <span class="identifier">n_active</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">diag</span>

            <span class="keyword">if</span> <span class="identifier">diag</span> <span class="relational-operator">&lt;</span> <span class="float-literal">1e-7</span><span class="punctuation">:</span>
                <span class="comment"># The system is becoming too ill-conditioned.</span>
                <span class="comment"># We have degenerate vectors in our active set.</span>
                <span class="comment"># We'll 'drop for good' the last regressor added.</span>

                <span class="comment"># Note: this case is very rare. It is no longer triggered by</span>
                <span class="comment"># the test suite. The `equality_tolerance` margin added in 0.16</span>
                <span class="comment"># to get early stopping to work consistently on all versions of</span>
                <span class="comment"># Python including 32 bit Python under Windows seems to make it</span>
                <span class="comment"># very difficult to trigger the 'drop for good' strategy.</span>
                <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">'Regressors in active set degenerate. '</span>
                              <span class="string-literal">'Dropping a regressor, after %i iterations, '</span>
                              <span class="string-literal">'i.e. alpha=%.3e, '</span>
                              <span class="string-literal">'with an active set of %i regressors, and '</span>
                              <span class="string-literal">'the smallest cholesky pivot element being %.3e.'</span>
                              <span class="string-literal">' Reduce max_iter or increase eps parameters.'</span>
                              <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">n_iter</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">n_active</span><span class="punctuation">,</span> <span class="identifier">diag</span><span class="grouping">)</span><span class="punctuation">,</span>
                              <span class="identifier">ConvergenceWarning</span><span class="grouping">)</span>

                <span class="comment"># XXX: need to figure a 'drop for good' way</span>
                <span class="identifier">Cov</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Cov_not_shortened</span>
                <span class="identifier">Cov</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
                <span class="identifier">Cov</span><span class="grouping">[</span><span class="identifier">C_idx</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Cov</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">swap</span><span class="grouping">(</span><span class="identifier">Cov</span><span class="grouping">[</span><span class="identifier">C_idx</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Cov</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>
                <span class="keyword">continue</span>

            <span class="identifier">active</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="identifier">n_active</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">1</span>

            <span class="keyword">if</span> <span class="identifier">verbose</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"%s\t\t%s\t\t%s\t\t%s\t\t%s"</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">n_iter</span><span class="punctuation">,</span> <span class="identifier">active</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="string-literal">''</span><span class="punctuation">,</span>
                                                      <span class="identifier">n_active</span><span class="punctuation">,</span> <span class="identifier">C</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">method</span> <span class="relational-operator">==</span> <span class="string-literal">'lasso'</span> <span class="logical-operator">and</span> <span class="identifier">n_iter</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span> <span class="logical-operator">and</span> <span class="identifier">prev_alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">&lt;</span> <span class="identifier">alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">:</span>
            <span class="comment"># alpha is increasing. This is because the updates of Cov are</span>
            <span class="comment"># bringing in too much numerical error that is greater than</span>
            <span class="comment"># than the remaining correlation with the</span>
            <span class="comment"># regressors. Time to bail out</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">'Early stopping the lars path, as the residues '</span>
                          <span class="string-literal">'are small and the current value of alpha is no '</span>
                          <span class="string-literal">'longer well controlled. %i iterations, alpha=%.3e, '</span>
                          <span class="string-literal">'previous alpha=%.3e, with an active set of %i '</span>
                          <span class="string-literal">'regressors.'</span>
                          <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">n_iter</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">prev_alpha</span><span class="punctuation">,</span> <span class="identifier">n_active</span><span class="grouping">)</span><span class="punctuation">,</span>
                          <span class="identifier">ConvergenceWarning</span><span class="grouping">)</span>
            <span class="keyword">break</span>

        <span class="comment"># least squares solution</span>
        <span class="identifier">least_squares</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">solve_cholesky</span><span class="grouping">(</span><span class="identifier">L</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_active</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="punctuation">,</span>
                                          <span class="identifier">sign_active</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="punctuation">,</span>
                                          <span class="identifier">lower</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">least_squares</span><span class="punctuation">.</span><span class="identifier">size</span> <span class="relational-operator">==</span> <span class="int-literal">1</span> <span class="logical-operator">and</span> <span class="identifier">least_squares</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="comment"># This happens because sign_active[:n_active] = 0</span>
            <span class="identifier">least_squares</span><span class="grouping">[</span><span class="punctuation">.</span><span class="punctuation">.</span><span class="punctuation">.</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>
            <span class="identifier">AA</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span><span class="punctuation">.</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># is this really needed ?</span>
            <span class="identifier">AA</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">/</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">least_squares</span> <span class="arithmetic-operator">*</span> <span class="identifier">sign_active</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">isfinite</span><span class="grouping">(</span><span class="identifier">AA</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="comment"># L is too ill-conditioned</span>
                <span class="identifier">i</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
                <span class="identifier">L_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">L</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_active</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="grouping">)</span>
                <span class="keyword">while</span> <span class="logical-operator">not</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">isfinite</span><span class="grouping">(</span><span class="identifier">AA</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">L_</span><span class="punctuation">.</span><span class="identifier">flat</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="identifier">n_active</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="grouping">(</span><span class="int-literal">2</span> <span class="arithmetic-operator">**</span> <span class="identifier">i</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">eps</span>
                    <span class="identifier">least_squares</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">solve_cholesky</span><span class="grouping">(</span>
                        <span class="identifier">L_</span><span class="punctuation">,</span> <span class="identifier">sign_active</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">lower</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
                    <span class="identifier">tmp</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">least_squares</span> <span class="arithmetic-operator">*</span> <span class="identifier">sign_active</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">,</span>
                              <span class="identifier">eps</span><span class="grouping">)</span>
                    <span class="identifier">AA</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">/</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">tmp</span><span class="grouping">)</span>
                    <span class="identifier">i</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">1</span>
            <span class="identifier">least_squares</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">AA</span>

        <span class="keyword">if</span> <span class="identifier">Gram</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="comment"># equiangular direction of variables in the active set</span>
            <span class="identifier">eq_dir</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">least_squares</span><span class="grouping">)</span>
            <span class="comment"># correlation between each unactive variables and</span>
            <span class="comment"># eqiangular vector</span>
            <span class="identifier">corr_eq_dir</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">n_active</span><span class="punctuation">:</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">eq_dir</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># if huge number of features, this takes 50% of time, I</span>
            <span class="comment"># think could be avoided if we just update it using an</span>
            <span class="comment"># orthogonal (QR) decomposition of X</span>
            <span class="identifier">corr_eq_dir</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">Gram</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_active</span><span class="punctuation">,</span> <span class="identifier">n_active</span><span class="punctuation">:</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span>
                                 <span class="identifier">least_squares</span><span class="grouping">)</span>

        <span class="identifier">g1</span> <span class="arithmetic-assignment">=</span> <span class="identifier">arrayfuncs</span><span class="punctuation">.</span><span class="identifier">min_pos</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">C</span> <span class="arithmetic-operator">-</span> <span class="identifier">Cov</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">AA</span> <span class="arithmetic-operator">-</span> <span class="identifier">corr_eq_dir</span> <span class="arithmetic-operator">+</span> <span class="identifier">tiny32</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">positive</span><span class="punctuation">:</span>
            <span class="identifier">gamma_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">min</span><span class="grouping">(</span><span class="identifier">g1</span><span class="punctuation">,</span> <span class="identifier">C</span> <span class="arithmetic-operator">/</span> <span class="identifier">AA</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">g2</span> <span class="arithmetic-assignment">=</span> <span class="identifier">arrayfuncs</span><span class="punctuation">.</span><span class="identifier">min_pos</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">C</span> <span class="arithmetic-operator">+</span> <span class="identifier">Cov</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">AA</span> <span class="arithmetic-operator">+</span> <span class="identifier">corr_eq_dir</span> <span class="arithmetic-operator">+</span> <span class="identifier">tiny32</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">gamma_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">min</span><span class="grouping">(</span><span class="identifier">g1</span><span class="punctuation">,</span> <span class="identifier">g2</span><span class="punctuation">,</span> <span class="identifier">C</span> <span class="arithmetic-operator">/</span> <span class="identifier">AA</span><span class="grouping">)</span>

        <span class="comment"># TODO: better names for these variables: z</span>
        <span class="identifier">drop</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
        <span class="identifier">z</span> <span class="arithmetic-assignment">=</span> <span class="arithmetic-operator">-</span><span class="identifier">coef</span><span class="grouping">[</span><span class="identifier">active</span><span class="grouping">]</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">least_squares</span> <span class="arithmetic-operator">+</span> <span class="identifier">tiny32</span><span class="grouping">)</span>
        <span class="identifier">z_pos</span> <span class="arithmetic-assignment">=</span> <span class="identifier">arrayfuncs</span><span class="punctuation">.</span><span class="identifier">min_pos</span><span class="grouping">(</span><span class="identifier">z</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">z_pos</span> <span class="relational-operator">&lt;</span> <span class="identifier">gamma_</span><span class="punctuation">:</span>
            <span class="comment"># some coefficients have changed sign</span>
            <span class="identifier">idx</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">where</span><span class="grouping">(</span><span class="identifier">z</span> <span class="relational-operator">==</span> <span class="identifier">z_pos</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span>

            <span class="comment"># update the sign, important for LAR</span>
            <span class="identifier">sign_active</span><span class="grouping">[</span><span class="identifier">idx</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="arithmetic-operator">-</span><span class="identifier">sign_active</span><span class="grouping">[</span><span class="identifier">idx</span><span class="grouping">]</span>

            <span class="keyword">if</span> <span class="identifier">method</span> <span class="relational-operator">==</span> <span class="string-literal">'lasso'</span><span class="punctuation">:</span>
                <span class="identifier">gamma_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">z_pos</span>
            <span class="identifier">drop</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>

        <span class="identifier">n_iter</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">1</span>

        <span class="keyword">if</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">h</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">n_iter</span> <span class="relational-operator">&gt;=</span> <span class="identifier">coefs</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">:</span>
                <span class="keyword">del</span> <span class="identifier">coef</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">prev_alpha</span><span class="punctuation">,</span> <span class="identifier">prev_coef</span>
                <span class="comment"># resize the coefs and alphas array</span>
                <span class="identifier">add_features</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">2</span> <span class="arithmetic-operator">*</span> <span class="identifier">max</span><span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">max_features</span> <span class="arithmetic-operator">-</span> <span class="identifier">n_active</span><span class="grouping">)</span><span class="grouping">)</span>
                <span class="identifier">coefs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">resize</span><span class="grouping">(</span><span class="identifier">coefs</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">n_iter</span> <span class="arithmetic-operator">+</span> <span class="identifier">add_features</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="grouping">)</span>
                <span class="identifier">coefs</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="identifier">add_features</span><span class="punctuation">:</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
                <span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">resize</span><span class="grouping">(</span><span class="identifier">alphas</span><span class="punctuation">,</span> <span class="identifier">n_iter</span> <span class="arithmetic-operator">+</span> <span class="identifier">add_features</span><span class="grouping">)</span>
                <span class="identifier">alphas</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="identifier">add_features</span><span class="punctuation">:</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
            <span class="identifier">coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coefs</span><span class="grouping">[</span><span class="identifier">n_iter</span><span class="grouping">]</span>
            <span class="identifier">prev_coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coefs</span><span class="grouping">[</span><span class="identifier">n_iter</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">]</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># mimic the effect of incrementing n_iter on the array references</span>
            <span class="identifier">prev_coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coef</span>
            <span class="identifier">prev_alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
            <span class="identifier">coef</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros_like</span><span class="grouping">(</span><span class="identifier">coef</span><span class="grouping">)</span>

        <span class="identifier">coef</span><span class="grouping">[</span><span class="identifier">active</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">prev_coef</span><span class="grouping">[</span><span class="identifier">active</span><span class="grouping">]</span> <span class="arithmetic-operator">+</span> <span class="identifier">gamma_</span> <span class="arithmetic-operator">*</span> <span class="identifier">least_squares</span>

        <span class="comment"># update correlations</span>
        <span class="identifier">Cov</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">gamma_</span> <span class="arithmetic-operator">*</span> <span class="identifier">corr_eq_dir</span>

        <span class="comment"># See if any coefficient has changed sign</span>
        <span class="keyword">if</span> <span class="identifier">drop</span> <span class="logical-operator">and</span> <span class="identifier">method</span> <span class="relational-operator">==</span> <span class="string-literal">'lasso'</span><span class="punctuation">:</span>

            <span class="comment"># handle the case when idx is not length of 1</span>
            <span class="keyword">for</span> <span class="identifier">ii</span> <span class="relational-operator">in</span> <span class="identifier">idx</span><span class="punctuation">:</span>
                <span class="identifier">arrayfuncs</span><span class="punctuation">.</span><span class="identifier">cholesky_delete</span><span class="grouping">(</span><span class="identifier">L</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_active</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">ii</span><span class="grouping">)</span>

            <span class="identifier">n_active</span> <span class="arithmetic-assignment">-=</span> <span class="int-literal">1</span>
            <span class="comment"># handle the case when idx is not length of 1</span>
            <span class="identifier">drop_idx</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">active</span><span class="punctuation">.</span><span class="identifier">pop</span><span class="grouping">(</span><span class="identifier">ii</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">ii</span> <span class="relational-operator">in</span> <span class="identifier">idx</span><span class="grouping">]</span>

            <span class="keyword">if</span> <span class="identifier">Gram</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                <span class="comment"># propagate dropped variable</span>
                <span class="keyword">for</span> <span class="identifier">ii</span> <span class="relational-operator">in</span> <span class="identifier">idx</span><span class="punctuation">:</span>
                    <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">ii</span><span class="punctuation">,</span> <span class="identifier">n_active</span><span class="grouping">)</span><span class="punctuation">:</span>
                        <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">swap</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
                        <span class="comment"># yeah this is stupid</span>
                        <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span>

                <span class="comment"># TODO: this could be updated</span>
                <span class="identifier">residual</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span> <span class="arithmetic-operator">-</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">coef</span><span class="grouping">[</span><span class="identifier">active</span><span class="grouping">]</span><span class="grouping">)</span>
                <span class="identifier">temp</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">n_active</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">residual</span><span class="grouping">)</span>

                <span class="identifier">Cov</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">r_</span><span class="grouping">[</span><span class="identifier">temp</span><span class="punctuation">,</span> <span class="identifier">Cov</span><span class="grouping">]</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="keyword">for</span> <span class="identifier">ii</span> <span class="relational-operator">in</span> <span class="identifier">idx</span><span class="punctuation">:</span>
                    <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">ii</span><span class="punctuation">,</span> <span class="identifier">n_active</span><span class="grouping">)</span><span class="punctuation">:</span>
                        <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">indices</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span>
                        <span class="identifier">Gram</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="grouping">[</span><span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">swap</span><span class="grouping">(</span><span class="identifier">Gram</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="grouping">[</span><span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
                        <span class="identifier">Gram</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">swap</span><span class="grouping">(</span><span class="identifier">Gram</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="grouping">]</span><span class="punctuation">,</span>
                                                          <span class="identifier">Gram</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>

                <span class="comment"># Cov_n = Cov_j + x_j * X + increment(betas) TODO:</span>
                <span class="comment"># will this still work with multiple drops ?</span>

                <span class="comment"># recompute covariance. Probably could be done better</span>
                <span class="comment"># wrong as Xy is not swapped with the rest of variables</span>

                <span class="comment"># TODO: this could be updated</span>
                <span class="identifier">temp</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Cov_copy</span><span class="grouping">[</span><span class="identifier">drop_idx</span><span class="grouping">]</span> <span class="arithmetic-operator">-</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">Gram_copy</span><span class="grouping">[</span><span class="identifier">drop_idx</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">coef</span><span class="grouping">)</span>
                <span class="identifier">Cov</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">r_</span><span class="grouping">[</span><span class="identifier">temp</span><span class="punctuation">,</span> <span class="identifier">Cov</span><span class="grouping">]</span>

            <span class="identifier">sign_active</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">sign_active</span><span class="punctuation">,</span> <span class="identifier">idx</span><span class="grouping">)</span>
            <span class="identifier">sign_active</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">sign_active</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="punctuation">.</span><span class="grouping">)</span>  <span class="comment"># just to maintain size</span>
            <span class="keyword">if</span> <span class="identifier">verbose</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"%s\t\t%s\t\t%s\t\t%s\t\t%s"</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">n_iter</span><span class="punctuation">,</span> <span class="string-literal">''</span><span class="punctuation">,</span> <span class="identifier">drop_idx</span><span class="punctuation">,</span>
                                                      <span class="identifier">n_active</span><span class="punctuation">,</span> <span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">temp</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">h</span><span class="punctuation">:</span>
        <span class="comment"># resize coefs in case of early stop</span>
        <span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alphas</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_iter</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span>
        <span class="identifier">coefs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coefs</span><span class="grouping">[</span><span class="punctuation">:</span><span class="identifier">n_iter</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span>

        <span class="keyword">if</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">alphas</span><span class="punctuation">,</span> <span class="identifier">active</span><span class="punctuation">,</span> <span class="identifier">coefs</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">n_iter</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">alphas</span><span class="punctuation">,</span> <span class="identifier">active</span><span class="punctuation">,</span> <span class="identifier">coefs</span><span class="punctuation">.</span><span class="identifier">T</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">active</span><span class="punctuation">,</span> <span class="identifier">coef</span><span class="punctuation">,</span> <span class="identifier">n_iter</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">active</span><span class="punctuation">,</span> <span class="identifier">coef</span>


<span class="comment">###############################################################################</span>
<span class="comment"># Estimator classes</span>

<span class="keyword">class</span> <span class="identifier">Lars</span><span class="grouping">(</span><span class="identifier">MultiOutputMixin</span><span class="punctuation">,</span> <span class="identifier">RegressorMixin</span><span class="punctuation">,</span> <span class="identifier">LinearModel</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Least Angle Regression model a.k.a. LAR

    Read more in the :ref:`User Guide &lt;least_angle_regression&gt;`.

    Parameters
    ----------
    fit_intercept : bool, default=True
        Whether to calculate the intercept for this model. If set
        to false, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    verbose : bool or int, default=False
        Sets the verbosity amount.

    normalize : bool, default=True
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

    precompute : bool, 'auto' or array-like , default='auto'
        Whether to use a precomputed Gram matrix to speed up
        calculations. If set to ``'auto'`` let us decide. The Gram
        matrix can also be passed as argument.

    n_nonzero_coefs : int, default=500
        Target number of non-zero coefficients. Use ``np.inf`` for no limit.

    eps : float, default=np.finfo(float).eps
        The machine-precision regularization in the computation of the
        Cholesky diagonal factors. Increase this for very ill-conditioned
        systems. Unlike the ``tol`` parameter in some iterative
        optimization-based algorithms, this parameter does not control
        the tolerance of the optimization.

    copy_X : bool, default=True
        If ``True``, X will be copied; else, it may be overwritten.

    fit_path : bool, default=True
        If True the full path is stored in the ``coef_path_`` attribute.
        If you compute the solution for a large problem or many targets,
        setting ``fit_path`` to ``False`` will lead to a speedup, especially
        with a small alpha.

    jitter : float, default=None
        Upper bound on a uniform noise parameter to be added to the
        `y` values, to satisfy the model's assumption of
        one-at-a-time computations. Might help with stability.

        .. versionadded:: 0.23

    random_state : int, RandomState instance or None, default=None
        Determines random number generation for jittering. Pass an int
        for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`. Ignored if `jitter` is None.

        .. versionadded:: 0.23

    Attributes
    ----------
    alphas_ : array-like of shape (n_alphas + 1,) or list of such arrays
        Maximum of covariances (in absolute value) at each iteration.
        ``n_alphas`` is either ``max_iter``, ``n_features`` or the
        number of nodes in the path with ``alpha &gt;= alpha_min``, whichever
        is smaller. If this is a list of array-like, the length of the outer
        list is `n_targets`.

    active_ : list of shape (n_alphas,) or list of such lists
        Indices of active variables at the end of the path.
        If this is a list of list, the length of the outer list is `n_targets`.

    coef_path_ : array-like of shape (n_features, n_alphas + 1) or list \
            of such arrays
        The varying values of the coefficients along the path. It is not
        present if the ``fit_path`` parameter is ``False``. If this is a list
        of array-like, the length of the outer list is `n_targets`.

    coef_ : array-like of shape (n_features,) or (n_targets, n_features)
        Parameter vector (w in the formulation formula).

    intercept_ : float or array-like of shape (n_targets,)
        Independent term in decision function.

    n_iter_ : array-like or int
        The number of iterations taken by lars_path to find the
        grid of alphas for each target.

    Examples
    --------
    &gt;&gt;&gt; from sklearn import linear_model
    &gt;&gt;&gt; reg = linear_model.Lars(n_nonzero_coefs=1)
    &gt;&gt;&gt; reg.fit([[-1, 1], [0, 0], [1, 1]], [-1.1111, 0, -1.1111])
    Lars(n_nonzero_coefs=1)
    &gt;&gt;&gt; print(reg.coef_)
    [ 0. -1.11...]

    See Also
    --------
    lars_path, LarsCV
    sklearn.decomposition.sparse_encode

    """</span>

    <span class="identifier">method</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"lar"</span>
    <span class="identifier">positive</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span> <span class="identifier">n_nonzero_coefs</span><span class="arithmetic-assignment">=</span><span class="int-literal">500</span><span class="punctuation">,</span>
                 <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">float</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">fit_path</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">jitter</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_intercept</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">verbose</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">normalize</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">precompute</span> <span class="arithmetic-assignment">=</span> <span class="identifier">precompute</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_nonzero_coefs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_nonzero_coefs</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">eps</span> <span class="arithmetic-assignment">=</span> <span class="identifier">eps</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy_X</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_path</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_path</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">jitter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">jitter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>

    <span class="punctuation">@</span><span class="identifier">staticmethod</span>
    <span class="keyword">def</span> <span class="identifier">_get_gram</span><span class="grouping">(</span><span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="grouping">(</span><span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">precompute</span><span class="punctuation">,</span> <span class="string-literal">'__array__'</span><span class="grouping">)</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="grouping">(</span>
                <span class="grouping">(</span><span class="identifier">precompute</span> <span class="relational-operator">is</span> <span class="bool-literal">True</span><span class="grouping">)</span> <span class="logical-operator">or</span>
                <span class="grouping">(</span><span class="identifier">precompute</span> <span class="relational-operator">==</span> <span class="string-literal">'auto'</span> <span class="logical-operator">and</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">&gt;</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span> <span class="logical-operator">or</span>
                <span class="grouping">(</span><span class="identifier">precompute</span> <span class="relational-operator">==</span> <span class="string-literal">'auto'</span> <span class="logical-operator">and</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">precompute</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">precompute</span>

    <span class="keyword">def</span> <span class="identifier">_fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">fit_path</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Auxiliary method to fit the model using X, y as training data"""</span>
        <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>

        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">X_offset</span><span class="punctuation">,</span> <span class="identifier">y_offset</span><span class="punctuation">,</span> <span class="identifier">X_scale</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_preprocess_data</span><span class="grouping">(</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>

        <span class="identifier">n_targets</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>

        <span class="identifier">Gram</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_get_gram</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">n_targets</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">fit_path</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">active_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_path_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
            <span class="keyword">for</span> <span class="identifier">k</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_targets</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">this_Xy</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span> <span class="keyword">if</span> <span class="identifier">Xy</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="keyword">else</span> <span class="identifier">Xy</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">k</span><span class="grouping">]</span>
                <span class="identifier">alphas</span><span class="punctuation">,</span> <span class="identifier">active</span><span class="punctuation">,</span> <span class="identifier">coef_path</span><span class="punctuation">,</span> <span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">lars_path</span><span class="grouping">(</span>
                    <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">k</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="arithmetic-assignment">=</span><span class="identifier">Gram</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="identifier">this_Xy</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span><span class="punctuation">,</span>
                    <span class="identifier">copy_Gram</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">alpha_min</span><span class="arithmetic-assignment">=</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">method</span><span class="punctuation">,</span>
                    <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">max</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
                    <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">h</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                    <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">positive</span><span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">alphas</span><span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">active_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">active</span><span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">n_iter_</span><span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_path_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">coef_path</span><span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span><span class="grouping">[</span><span class="identifier">k</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coef_path</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span>

            <span class="keyword">if</span> <span class="identifier">n_targets</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">active_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_path_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span>
                    <span class="identifier">a</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="keyword">for</span> <span class="identifier">a</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">active_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_path_</span><span class="punctuation">,</span>
                                   <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span><span class="grouping">)</span><span class="grouping">]</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">for</span> <span class="identifier">k</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_targets</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">this_Xy</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span> <span class="keyword">if</span> <span class="identifier">Xy</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="keyword">else</span> <span class="identifier">Xy</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">k</span><span class="grouping">]</span>
                <span class="identifier">alphas</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span><span class="grouping">[</span><span class="identifier">k</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">lars_path</span><span class="grouping">(</span>
                    <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">k</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="arithmetic-assignment">=</span><span class="identifier">Gram</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="identifier">this_Xy</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span><span class="punctuation">,</span>
                    <span class="identifier">copy_Gram</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">alpha_min</span><span class="arithmetic-assignment">=</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">method</span><span class="punctuation">,</span>
                    <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">max</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
                    <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">h</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                    <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">positive</span><span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">alphas</span><span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">n_iter_</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">n_targets</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_set_intercept</span><span class="grouping">(</span><span class="identifier">X_offset</span><span class="punctuation">,</span> <span class="identifier">y_offset</span><span class="punctuation">,</span> <span class="identifier">X_scale</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the model using X, y as training data.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data.

        y : array-like of shape (n_samples,) or (n_samples, n_targets)
            Target values.

        Xy : array-like of shape (n_samples,) or (n_samples, n_targets), \
                default=None
            Xy = np.dot(X.T, y) that can be precomputed. It is useful
            only when the Gram matrix is precomputed.

        Returns
        -------
        self : object
            returns an instance of self.
        """</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">y_numeric</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">multi_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

        <span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">'alpha'</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="punctuation">.</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">'n_nonzero_coefs'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>  <span class="comment"># n_nonzero_coefs parametrization takes priority</span>
            <span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_nonzero_coefs</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">jitter</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">rng</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span>

            <span class="identifier">noise</span> <span class="arithmetic-assignment">=</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">uniform</span><span class="grouping">(</span><span class="identifier">high</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">jitter</span><span class="punctuation">,</span> <span class="identifier">size</span><span class="arithmetic-assignment">=</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span> <span class="arithmetic-operator">+</span> <span class="identifier">noise</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">fit_path</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_path</span><span class="punctuation">,</span>
                  <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="identifier">Xy</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span>


<span class="keyword">class</span> <span class="identifier">LassoLars</span><span class="grouping">(</span><span class="identifier">Lars</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Lasso model fit with Least Angle Regression a.k.a. Lars

    It is a Linear Model trained with an L1 prior as regularizer.

    The optimization objective for Lasso is::

    (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1

    Read more in the :ref:`User Guide &lt;least_angle_regression&gt;`.

    Parameters
    ----------
    alpha : float, default=1.0
        Constant that multiplies the penalty term. Defaults to 1.0.
        ``alpha = 0`` is equivalent to an ordinary least square, solved
        by :class:`LinearRegression`. For numerical reasons, using
        ``alpha = 0`` with the LassoLars object is not advised and you
        should prefer the LinearRegression object.

    fit_intercept : bool, default=True
        whether to calculate the intercept for this model. If set
        to false, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    verbose : bool or int, default=False
        Sets the verbosity amount.

    normalize : bool, default=True
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

    precompute : bool, 'auto' or array-like, default='auto'
        Whether to use a precomputed Gram matrix to speed up
        calculations. If set to ``'auto'`` let us decide. The Gram
        matrix can also be passed as argument.

    max_iter : int, default=500
        Maximum number of iterations to perform.

    eps : float, default=np.finfo(float).eps
        The machine-precision regularization in the computation of the
        Cholesky diagonal factors. Increase this for very ill-conditioned
        systems. Unlike the ``tol`` parameter in some iterative
        optimization-based algorithms, this parameter does not control
        the tolerance of the optimization.

    copy_X : bool, default=True
        If True, X will be copied; else, it may be overwritten.

    fit_path : bool, default=True
        If ``True`` the full path is stored in the ``coef_path_`` attribute.
        If you compute the solution for a large problem or many targets,
        setting ``fit_path`` to ``False`` will lead to a speedup, especially
        with a small alpha.

    positive : bool, default=False
        Restrict coefficients to be &gt;= 0. Be aware that you might want to
        remove fit_intercept which is set True by default.
        Under the positive restriction the model coefficients will not converge
        to the ordinary-least-squares solution for small values of alpha.
        Only coefficients up to the smallest alpha value (``alphas_[alphas_ &gt;
        0.].min()`` when fit_path=True) reached by the stepwise Lars-Lasso
        algorithm are typically in congruence with the solution of the
        coordinate descent Lasso estimator.

    jitter : float, default=None
        Upper bound on a uniform noise parameter to be added to the
        `y` values, to satisfy the model's assumption of
        one-at-a-time computations. Might help with stability.

        .. versionadded:: 0.23

    random_state : int, RandomState instance or None, default=None
        Determines random number generation for jittering. Pass an int
        for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`. Ignored if `jitter` is None.

        .. versionadded:: 0.23

    Attributes
    ----------
    alphas_ : array-like of shape (n_alphas + 1,) or list of such arrays
        Maximum of covariances (in absolute value) at each iteration.
        ``n_alphas`` is either ``max_iter``, ``n_features`` or the
        number of nodes in the path with ``alpha &gt;= alpha_min``, whichever
        is smaller. If this is a list of array-like, the length of the outer
        list is `n_targets`.

    active_ : list of length n_alphas or list of such lists
        Indices of active variables at the end of the path.
        If this is a list of list, the length of the outer list is `n_targets`.

    coef_path_ : array-like of shape (n_features, n_alphas + 1) or list \
            of such arrays
        If a list is passed it's expected to be one of n_targets such arrays.
        The varying values of the coefficients along the path. It is not
        present if the ``fit_path`` parameter is ``False``. If this is a list
        of array-like, the length of the outer list is `n_targets`.

    coef_ : array-like of shape (n_features,) or (n_targets, n_features)
        Parameter vector (w in the formulation formula).

    intercept_ : float or array-like of shape (n_targets,)
        Independent term in decision function.

    n_iter_ : array-like or int
        The number of iterations taken by lars_path to find the
        grid of alphas for each target.

    Examples
    --------
    &gt;&gt;&gt; from sklearn import linear_model
    &gt;&gt;&gt; reg = linear_model.LassoLars(alpha=0.01)
    &gt;&gt;&gt; reg.fit([[-1, 1], [0, 0], [1, 1]], [-1, 0, -1])
    LassoLars(alpha=0.01)
    &gt;&gt;&gt; print(reg.coef_)
    [ 0.         -0.963257...]

    See Also
    --------
    lars_path
    lasso_path
    Lasso
    LassoCV
    LassoLarsCV
    LassoLarsIC
    sklearn.decomposition.sparse_encode

    """</span>
    <span class="identifier">method</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'lasso'</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="float-literal">1.0</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                 <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">500</span><span class="punctuation">,</span>
                 <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">float</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">fit_path</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">jitter</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_intercept</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">verbose</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">normalize</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">positive</span> <span class="arithmetic-assignment">=</span> <span class="identifier">positive</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">precompute</span> <span class="arithmetic-assignment">=</span> <span class="identifier">precompute</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy_X</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">eps</span> <span class="arithmetic-assignment">=</span> <span class="identifier">eps</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_path</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_path</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">jitter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">jitter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>


<span class="comment">###############################################################################</span>
<span class="comment"># Cross-validated estimator classes</span>

<span class="keyword">def</span> <span class="identifier">_check_copy_and_writeable</span><span class="grouping">(</span><span class="identifier">array</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="keyword">if</span> <span class="identifier">copy</span> <span class="logical-operator">or</span> <span class="logical-operator">not</span> <span class="identifier">array</span><span class="punctuation">.</span><span class="identifier">flags</span><span class="punctuation">.</span><span class="identifier">writeable</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">array</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">array</span>


<span class="keyword">def</span> <span class="identifier">_lars_path_residues</span><span class="grouping">(</span><span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">X_test</span><span class="punctuation">,</span> <span class="identifier">y_test</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                        <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="string-literal">'lars'</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                        <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">500</span><span class="punctuation">,</span>
                        <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">float</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Compute the residues on left-out data for a full LARS path

    Parameters
    -----------
    X_train : array-like of shape (n_samples, n_features)
        The data to fit the LARS on

    y_train : array-like of shape (n_samples,)
        The target variable to fit LARS on

    X_test : array-like of shape (n_samples, n_features)
        The data to compute the residues on

    y_test : array-like of shape (n_samples,)
        The target variable to compute the residues on

    Gram : None, 'auto' or array-like of shape (n_features, n_features), \
            default=None
        Precomputed Gram matrix (X' * X), if ``'auto'``, the Gram
        matrix is precomputed from the given X, if there are more samples
        than features

    copy : bool, default=True
        Whether X_train, X_test, y_train and y_test should be copied;
        if False, they may be overwritten.

    method : {'lar' , 'lasso'}, default='lar'
        Specifies the returned model. Select ``'lar'`` for Least Angle
        Regression, ``'lasso'`` for the Lasso.

    verbose : bool or int, default=False
        Sets the amount of verbosity

    fit_intercept : bool, default=True
        whether to calculate the intercept for this model. If set
        to false, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    positive : bool, default=False
        Restrict coefficients to be &gt;= 0. Be aware that you might want to
        remove fit_intercept which is set True by default.
        See reservations for using this option in combination with method
        'lasso' for expected small values of alpha in the doc of LassoLarsCV
        and LassoLarsIC.

    normalize : bool, default=True
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

    max_iter : int, default=500
        Maximum number of iterations to perform.

    eps : float, default=np.finfo(float).eps
        The machine-precision regularization in the computation of the
        Cholesky diagonal factors. Increase this for very ill-conditioned
        systems. Unlike the ``tol`` parameter in some iterative
        optimization-based algorithms, this parameter does not control
        the tolerance of the optimization.

    Returns
    --------
    alphas : array-like of shape (n_alphas,)
        Maximum of covariances (in absolute value) at each iteration.
        ``n_alphas`` is either ``max_iter`` or ``n_features``, whichever
        is smaller.

    active : list
        Indices of active variables at the end of the path.

    coefs : array-like of shape (n_features, n_alphas)
        Coefficients along the path

    residues : array-like of shape (n_alphas, n_samples)
        Residues of the prediction on the test data
    """</span>
    <span class="identifier">X_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_copy_and_writeable</span><span class="grouping">(</span><span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="grouping">)</span>
    <span class="identifier">y_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_copy_and_writeable</span><span class="grouping">(</span><span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="grouping">)</span>
    <span class="identifier">X_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_copy_and_writeable</span><span class="grouping">(</span><span class="identifier">X_test</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="grouping">)</span>
    <span class="identifier">y_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_copy_and_writeable</span><span class="grouping">(</span><span class="identifier">y_test</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">fit_intercept</span><span class="punctuation">:</span>
        <span class="identifier">X_mean</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_train</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
        <span class="identifier">X_train</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">X_mean</span>
        <span class="identifier">X_test</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">X_mean</span>
        <span class="identifier">y_mean</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y_train</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
        <span class="identifier">y_train</span> <span class="arithmetic-assignment">=</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">l</span><span class="invalid">o</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">y_train</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">y_mean</span>
        <span class="identifier">y_test</span> <span class="arithmetic-assignment">=</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">l</span><span class="invalid">o</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">y_test</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">y_test</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">y_mean</span>

    <span class="keyword">if</span> <span class="identifier">normalize</span><span class="punctuation">:</span>
        <span class="identifier">norms</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">X_train</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">nonzeros</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">flatnonzero</span><span class="grouping">(</span><span class="identifier">norms</span><span class="grouping">)</span>
        <span class="identifier">X_train</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">nonzeros</span><span class="grouping">]</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">norms</span><span class="grouping">[</span><span class="identifier">nonzeros</span><span class="grouping">]</span>

    <span class="identifier">alphas</span><span class="punctuation">,</span> <span class="identifier">active</span><span class="punctuation">,</span> <span class="identifier">coefs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">lars_path</span><span class="grouping">(</span>
        <span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="arithmetic-assignment">=</span><span class="identifier">Gram</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">copy_Gram</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
        <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="identifier">method</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">max</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">verbose</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">eps</span><span class="punctuation">,</span>
        <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="identifier">positive</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">normalize</span><span class="punctuation">:</span>
        <span class="identifier">coefs</span><span class="grouping">[</span><span class="identifier">nonzeros</span><span class="grouping">]</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">norms</span><span class="grouping">[</span><span class="identifier">nonzeros</span><span class="grouping">]</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
    <span class="identifier">residues</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X_test</span><span class="punctuation">,</span> <span class="identifier">coefs</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">y_test</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
    <span class="keyword">return</span> <span class="identifier">alphas</span><span class="punctuation">,</span> <span class="identifier">active</span><span class="punctuation">,</span> <span class="identifier">coefs</span><span class="punctuation">,</span> <span class="identifier">residues</span><span class="punctuation">.</span><span class="identifier">T</span>


<span class="keyword">class</span> <span class="identifier">LarsCV</span><span class="grouping">(</span><span class="identifier">Lars</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Cross-validated Least Angle Regression model.

    See glossary entry for :term:`cross-validation estimator`.

    Read more in the :ref:`User Guide &lt;least_angle_regression&gt;`.

    Parameters
    ----------
    fit_intercept : bool, default=True
        whether to calculate the intercept for this model. If set
        to false, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    verbose : bool or int, default=False
        Sets the verbosity amount.

    max_iter : int, default=500
        Maximum number of iterations to perform.

    normalize : bool, default=True
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

    precompute : bool, 'auto' or array-like , default='auto'
        Whether to use a precomputed Gram matrix to speed up
        calculations. If set to ``'auto'`` let us decide. The Gram matrix
        cannot be passed as argument since we will use only subsets of X.

    cv : int, cross-validation generator or an iterable, default=None
        Determines the cross-validation splitting strategy.
        Possible inputs for cv are:

        - None, to use the default 5-fold cross-validation,
        - integer, to specify the number of folds.
        - :term:`CV splitter`,
        - An iterable yielding (train, test) splits as arrays of indices.

        For integer/None inputs, :class:`KFold` is used.

        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
        cross-validation strategies that can be used here.

        .. versionchanged:: 0.22
            ``cv`` default value if None changed from 3-fold to 5-fold.

    max_n_alphas : int, default=1000
        The maximum number of points on the path used to compute the
        residuals in the cross-validation

    n_jobs : int or None, default=None
        Number of CPUs to use during the cross validation.
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

    eps : float, default=np.finfo(float).eps
        The machine-precision regularization in the computation of the
        Cholesky diagonal factors. Increase this for very ill-conditioned
        systems. Unlike the ``tol`` parameter in some iterative
        optimization-based algorithms, this parameter does not control
        the tolerance of the optimization.

    copy_X : bool, default=True
        If ``True``, X will be copied; else, it may be overwritten.

    Attributes
    ----------
    active_ : list of length n_alphas or list of such lists
        Indices of active variables at the end of the path.
        If this is a list of lists, the outer list length is `n_targets`.

    coef_ : array-like of shape (n_features,)
        parameter vector (w in the formulation formula)

    intercept_ : float
        independent term in decision function

    coef_path_ : array-like of shape (n_features, n_alphas)
        the varying values of the coefficients along the path

    alpha_ : float
        the estimated regularization parameter alpha

    alphas_ : array-like of shape (n_alphas,)
        the different values of alpha along the path

    cv_alphas_ : array-like of shape (n_cv_alphas,)
        all the values of alpha along the path for the different folds

    mse_path_ : array-like of shape (n_folds, n_cv_alphas)
        the mean square error on left-out for each fold along the path
        (alpha values given by ``cv_alphas``)

    n_iter_ : array-like or int
        the number of iterations run by Lars with the optimal alpha.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.linear_model import LarsCV
    &gt;&gt;&gt; from sklearn.datasets import make_regression
    &gt;&gt;&gt; X, y = make_regression(n_samples=200, noise=4.0, random_state=0)
    &gt;&gt;&gt; reg = LarsCV(cv=5).fit(X, y)
    &gt;&gt;&gt; reg.score(X, y)
    0.9996...
    &gt;&gt;&gt; reg.alpha_
    0.0254...
    &gt;&gt;&gt; reg.predict(X[:1,])
    array([154.0842...])

    See Also
    --------
    lars_path, LassoLars, LassoLarsCV
    """</span>

    <span class="identifier">method</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"lar"</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">500</span><span class="punctuation">,</span>
                 <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">max_n_alphas</span><span class="arithmetic-assignment">=</span><span class="int-literal">1000</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">float</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="punctuation">,</span>
                 <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cv</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_n_alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_n_alphas</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_jobs</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span>
                         <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="identifier">normalize</span><span class="punctuation">,</span>
                         <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="identifier">precompute</span><span class="punctuation">,</span>
                         <span class="identifier">n_nonzero_coefs</span><span class="arithmetic-assignment">=</span><span class="int-literal">500</span><span class="punctuation">,</span>
                         <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="identifier">copy_X</span><span class="punctuation">,</span> <span class="identifier">fit_path</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'multioutput'</span><span class="punctuation">:</span> <span class="bool-literal">False</span><span class="grouping">}</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the model using X, y as training data.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data.

        y : array-like of shape (n_samples,)
            Target values.

        Returns
        -------
        self : object
            returns an instance of self.
        """</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">y_numeric</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">l</span><span class="invalid">o</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span><span class="grouping">)</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">l</span><span class="invalid">o</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span><span class="grouping">)</span>

        <span class="comment"># init cross-validation generator</span>
        <span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_cv</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

        <span class="comment"># As we use cross-validation, the Gram matrix is not precomputed here</span>
        <span class="identifier">Gram</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">precompute</span>
        <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">Gram</span><span class="punctuation">,</span> <span class="string-literal">'__array__'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">'Parameter "precompute" cannot be an array in '</span>
                          <span class="string-literal">'%s. Automatically switch to "auto" instead.'</span>
                          <span class="arithmetic-operator">%</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__class__</span><span class="punctuation">.</span><span class="identifier">__name__</span><span class="grouping">)</span>
            <span class="identifier">Gram</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'auto'</span>

        <span class="identifier">cv_paths</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Parallel</span><span class="grouping">(</span><span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="grouping">)</span><span class="grouping">(</span>
            <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">(</span><span class="identifier">_lars_path_residues</span><span class="grouping">)</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">train</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">[</span><span class="identifier">train</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">test</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">[</span><span class="identifier">test</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="arithmetic-assignment">=</span><span class="identifier">Gram</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">method</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">max</span><span class="grouping">(</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">,</span>
                <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span>
                <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">positive</span><span class="grouping">)</span>
            <span class="keyword">for</span> <span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span> <span class="relational-operator">in</span> <span class="identifier">cv</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">all_alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">concatenate</span><span class="grouping">(</span><span class="identifier">list</span><span class="grouping">(</span><span class="identifier">zip</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">cv_paths</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="comment"># Unique also sorts</span>
        <span class="identifier">all_alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">all_alphas</span><span class="grouping">)</span>
        <span class="comment"># Take at most max_n_alphas values</span>
        <span class="identifier">stride</span> <span class="arithmetic-assignment">=</span> <span class="identifier">int</span><span class="grouping">(</span><span class="identifier">max</span><span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">int</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">all_alphas</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">float</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_n_alphas</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">all_alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">all_alphas</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="identifier">stride</span><span class="grouping">]</span>

        <span class="identifier">mse_path</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">all_alphas</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">cv_paths</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">index</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">alphas</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">residues</span><span class="grouping">)</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">cv_paths</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alphas</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span>
            <span class="identifier">residues</span> <span class="arithmetic-assignment">=</span> <span class="identifier">residues</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span>
            <span class="keyword">if</span> <span class="identifier">alphas</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">!=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
                <span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">r_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="grouping">]</span>
                <span class="identifier">residues</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">r_</span><span class="grouping">[</span><span class="identifier">residues</span><span class="grouping">[</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">residues</span><span class="grouping">]</span>
            <span class="keyword">if</span> <span class="identifier">alphas</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="relational-operator">!=</span> <span class="identifier">all_alphas</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">:</span>
                <span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">r_</span><span class="grouping">[</span><span class="identifier">alphas</span><span class="punctuation">,</span> <span class="identifier">all_alphas</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">]</span>
                <span class="identifier">residues</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">r_</span><span class="grouping">[</span><span class="identifier">residues</span><span class="punctuation">,</span> <span class="identifier">residues</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span><span class="grouping">]</span>
            <span class="identifier">this_residues</span> <span class="arithmetic-assignment">=</span> <span class="identifier">interpolate</span><span class="punctuation">.</span><span class="identifier">interp1d</span><span class="grouping">(</span><span class="identifier">alphas</span><span class="punctuation">,</span>
                                                 <span class="identifier">residues</span><span class="punctuation">,</span>
                                                 <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">(</span><span class="identifier">all_alphas</span><span class="grouping">)</span>
            <span class="identifier">this_residues</span> <span class="arithmetic-assignment">**=</span> <span class="int-literal">2</span>
            <span class="identifier">mse_path</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">index</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="identifier">this_residues</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span>

        <span class="identifier">mask</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">all</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">isfinite</span><span class="grouping">(</span><span class="identifier">mse_path</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span>
        <span class="identifier">all_alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">all_alphas</span><span class="grouping">[</span><span class="identifier">mask</span><span class="grouping">]</span>
        <span class="identifier">mse_path</span> <span class="arithmetic-assignment">=</span> <span class="identifier">mse_path</span><span class="grouping">[</span><span class="identifier">mask</span><span class="grouping">]</span>
        <span class="comment"># Select the alpha that minimizes left-out error</span>
        <span class="identifier">i_best_alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argmin</span><span class="grouping">(</span><span class="identifier">mse_path</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">best_alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">all_alphas</span><span class="grouping">[</span><span class="identifier">i_best_alpha</span><span class="grouping">]</span>

        <span class="comment"># Store our parameters</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">best_alpha</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv_alphas_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">all_alphas</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">mse_path_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">mse_path</span>

        <span class="comment"># Now compute the full model</span>
        <span class="comment"># it will call a lasso internally when self if LassoLarsCV</span>
        <span class="comment"># as self.method == 'lasso'</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="identifier">best_alpha</span><span class="punctuation">,</span>
                  <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">fit_path</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>


<span class="keyword">class</span> <span class="identifier">LassoLarsCV</span><span class="grouping">(</span><span class="identifier">LarsCV</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Cross-validated Lasso, using the LARS algorithm.

    See glossary entry for :term:`cross-validation estimator`.

    The optimization objective for Lasso is::

    (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1

    Read more in the :ref:`User Guide &lt;least_angle_regression&gt;`.

    Parameters
    ----------
    fit_intercept : bool, default=True
        whether to calculate the intercept for this model. If set
        to false, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    verbose : bool or int, default=False
        Sets the verbosity amount.

    max_iter : int, default=500
        Maximum number of iterations to perform.

    normalize : bool, default=True
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

    precompute : bool or 'auto' , default='auto'
        Whether to use a precomputed Gram matrix to speed up
        calculations. If set to ``'auto'`` let us decide. The Gram matrix
        cannot be passed as argument since we will use only subsets of X.

    cv : int, cross-validation generator or an iterable, default=None
        Determines the cross-validation splitting strategy.
        Possible inputs for cv are:

        - None, to use the default 5-fold cross-validation,
        - integer, to specify the number of folds.
        - :term:`CV splitter`,
        - An iterable yielding (train, test) splits as arrays of indices.

        For integer/None inputs, :class:`KFold` is used.

        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
        cross-validation strategies that can be used here.

        .. versionchanged:: 0.22
            ``cv`` default value if None changed from 3-fold to 5-fold.

    max_n_alphas : int, default=1000
        The maximum number of points on the path used to compute the
        residuals in the cross-validation

    n_jobs : int or None, default=None
        Number of CPUs to use during the cross validation.
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

    eps : float, default=np.finfo(float).eps
        The machine-precision regularization in the computation of the
        Cholesky diagonal factors. Increase this for very ill-conditioned
        systems. Unlike the ``tol`` parameter in some iterative
        optimization-based algorithms, this parameter does not control
        the tolerance of the optimization.

    copy_X : bool, default=True
        If True, X will be copied; else, it may be overwritten.

    positive : bool, default=False
        Restrict coefficients to be &gt;= 0. Be aware that you might want to
        remove fit_intercept which is set True by default.
        Under the positive restriction the model coefficients do not converge
        to the ordinary-least-squares solution for small values of alpha.
        Only coefficients up to the smallest alpha value (``alphas_[alphas_ &gt;
        0.].min()`` when fit_path=True) reached by the stepwise Lars-Lasso
        algorithm are typically in congruence with the solution of the
        coordinate descent Lasso estimator.
        As a consequence using LassoLarsCV only makes sense for problems where
        a sparse solution is expected and/or reached.

    Attributes
    ----------
    coef_ : array-like of shape (n_features,)
        parameter vector (w in the formulation formula)

    intercept_ : float
        independent term in decision function.

    coef_path_ : array-like of shape (n_features, n_alphas)
        the varying values of the coefficients along the path

    alpha_ : float
        the estimated regularization parameter alpha

    alphas_ : array-like of shape (n_alphas,)
        the different values of alpha along the path

    cv_alphas_ : array-like of shape (n_cv_alphas,)
        all the values of alpha along the path for the different folds

    mse_path_ : array-like of shape (n_folds, n_cv_alphas)
        the mean square error on left-out for each fold along the path
        (alpha values given by ``cv_alphas``)

    n_iter_ : array-like or int
        the number of iterations run by Lars with the optimal alpha.

    active_ : list of int
        Indices of active variables at the end of the path.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.linear_model import LassoLarsCV
    &gt;&gt;&gt; from sklearn.datasets import make_regression
    &gt;&gt;&gt; X, y = make_regression(noise=4.0, random_state=0)
    &gt;&gt;&gt; reg = LassoLarsCV(cv=5).fit(X, y)
    &gt;&gt;&gt; reg.score(X, y)
    0.9992...
    &gt;&gt;&gt; reg.alpha_
    0.0484...
    &gt;&gt;&gt; reg.predict(X[:1,])
    array([-77.8723...])

    Notes
    -----

    The object solves the same problem as the LassoCV object. However,
    unlike the LassoCV, it find the relevant alphas values by itself.
    In general, because of this property, it will be more stable.
    However, it is more fragile to heavily multicollinear datasets.

    It is more efficient than the LassoCV if only a small number of
    features are selected compared to the total number, for instance if
    there are very few samples compared to the number of features.

    See Also
    --------
    lars_path, LassoLars, LarsCV, LassoCV
    """</span>

    <span class="identifier">method</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'lasso'</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">500</span><span class="punctuation">,</span>
                 <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">max_n_alphas</span><span class="arithmetic-assignment">=</span><span class="int-literal">1000</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">float</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="punctuation">,</span>
                 <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_intercept</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">verbose</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">normalize</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">precompute</span> <span class="arithmetic-assignment">=</span> <span class="identifier">precompute</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cv</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_n_alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_n_alphas</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_jobs</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">eps</span> <span class="arithmetic-assignment">=</span> <span class="identifier">eps</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy_X</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">positive</span> <span class="arithmetic-assignment">=</span> <span class="identifier">positive</span>
        <span class="comment"># XXX : we don't use super().__init__</span>
        <span class="comment"># to avoid setting n_nonzero_coefs</span>


<span class="keyword">class</span> <span class="identifier">LassoLarsIC</span><span class="grouping">(</span><span class="identifier">LassoLars</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Lasso model fit with Lars using BIC or AIC for model selection

    The optimization objective for Lasso is::

    (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1

    AIC is the Akaike information criterion and BIC is the Bayes
    Information criterion. Such criteria are useful to select the value
    of the regularization parameter by making a trade-off between the
    goodness of fit and the complexity of the model. A good model should
    explain well the data while being simple.

    Read more in the :ref:`User Guide &lt;least_angle_regression&gt;`.

    Parameters
    ----------
    criterion : {'bic' , 'aic'}, default='aic'
        The type of criterion to use.

    fit_intercept : bool, default=True
        whether to calculate the intercept for this model. If set
        to false, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    verbose : bool or int, default=False
        Sets the verbosity amount.

    normalize : bool, default=True
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

    precompute : bool, 'auto' or array-like, default='auto'
        Whether to use a precomputed Gram matrix to speed up
        calculations. If set to ``'auto'`` let us decide. The Gram
        matrix can also be passed as argument.

    max_iter : int, default=500
        Maximum number of iterations to perform. Can be used for
        early stopping.

    eps : float, default=np.finfo(float).eps
        The machine-precision regularization in the computation of the
        Cholesky diagonal factors. Increase this for very ill-conditioned
        systems. Unlike the ``tol`` parameter in some iterative
        optimization-based algorithms, this parameter does not control
        the tolerance of the optimization.

    copy_X : bool, default=True
        If True, X will be copied; else, it may be overwritten.

    positive : bool, default=False
        Restrict coefficients to be &gt;= 0. Be aware that you might want to
        remove fit_intercept which is set True by default.
        Under the positive restriction the model coefficients do not converge
        to the ordinary-least-squares solution for small values of alpha.
        Only coefficients up to the smallest alpha value (``alphas_[alphas_ &gt;
        0.].min()`` when fit_path=True) reached by the stepwise Lars-Lasso
        algorithm are typically in congruence with the solution of the
        coordinate descent Lasso estimator.
        As a consequence using LassoLarsIC only makes sense for problems where
        a sparse solution is expected and/or reached.

    Attributes
    ----------
    coef_ : array-like of shape (n_features,)
        parameter vector (w in the formulation formula)

    intercept_ : float
        independent term in decision function.

    alpha_ : float
        the alpha parameter chosen by the information criterion

    alphas_ : array-like of shape (n_alphas + 1,) or list of such arrays
        Maximum of covariances (in absolute value) at each iteration.
        ``n_alphas`` is either ``max_iter``, ``n_features`` or the
        number of nodes in the path with ``alpha &gt;= alpha_min``, whichever
        is smaller. If a list, it will be of length `n_targets`.

    n_iter_ : int
        number of iterations run by lars_path to find the grid of
        alphas.

    criterion_ : array-like of shape (n_alphas,)
        The value of the information criteria ('aic', 'bic') across all
        alphas. The alpha which has the smallest information criterion is
        chosen. This value is larger by a factor of ``n_samples`` compared to
        Eqns. 2.15 and 2.16 in (Zou et al, 2007).


    Examples
    --------
    &gt;&gt;&gt; from sklearn import linear_model
    &gt;&gt;&gt; reg = linear_model.LassoLarsIC(criterion='bic')
    &gt;&gt;&gt; reg.fit([[-1, 1], [0, 0], [1, 1]], [-1.1111, 0, -1.1111])
    LassoLarsIC(criterion='bic')
    &gt;&gt;&gt; print(reg.coef_)
    [ 0.  -1.11...]

    Notes
    -----
    The estimation of the number of degrees of freedom is given by:

    "On the degrees of freedom of the lasso"
    Hui Zou, Trevor Hastie, and Robert Tibshirani
    Ann. Statist. Volume 35, Number 5 (2007), 2173-2192.

    https://en.wikipedia.org/wiki/Akaike_information_criterion
    https://en.wikipedia.org/wiki/Bayesian_information_criterion

    See Also
    --------
    lars_path, LassoLars, LassoLarsCV
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">criterion</span><span class="arithmetic-assignment">=</span><span class="string-literal">'aic'</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                 <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">500</span><span class="punctuation">,</span>
                 <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">float</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">criterion</span> <span class="arithmetic-assignment">=</span> <span class="identifier">criterion</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_intercept</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">positive</span> <span class="arithmetic-assignment">=</span> <span class="identifier">positive</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">verbose</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">normalize</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy_X</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">precompute</span> <span class="arithmetic-assignment">=</span> <span class="identifier">precompute</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">eps</span> <span class="arithmetic-assignment">=</span> <span class="identifier">eps</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_path</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'multioutput'</span><span class="punctuation">:</span> <span class="bool-literal">False</span><span class="grouping">}</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the model using X, y as training data.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            training data.

        y : array-like of shape (n_samples,)
            target values. Will be cast to X's dtype if necessary

        copy_X : bool, default=None
            If provided, this parameter will override the choice
            of copy_X made at instance creation.
            If ``True``, X will be copied; else, it may be overwritten.

        Returns
        -------
        self : object
            returns an instance of self.
        """</span>
        <span class="keyword">if</span> <span class="identifier">copy_X</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">y_numeric</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">Xmean</span><span class="punctuation">,</span> <span class="identifier">ymean</span><span class="punctuation">,</span> <span class="identifier">Xstd</span> <span class="arithmetic-assignment">=</span> <span class="identifier">LinearModel</span><span class="punctuation">.</span><span class="identifier">_preprocess_data</span><span class="grouping">(</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="grouping">)</span>

        <span class="identifier">Gram</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">precompute</span>

        <span class="identifier">alphas_</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">coef_path_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">lars_path</span><span class="grouping">(</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">Gram</span><span class="arithmetic-assignment">=</span><span class="identifier">Gram</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="identifier">copy_X</span><span class="punctuation">,</span> <span class="identifier">copy_Gram</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">alpha_min</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.0</span><span class="punctuation">,</span>
            <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="string-literal">'lasso'</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
            <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">positive</span><span class="grouping">)</span>

        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">criterion</span> <span class="relational-operator">==</span> <span class="string-literal">'aic'</span><span class="punctuation">:</span>
            <span class="identifier">K</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">2</span>  <span class="comment"># AIC</span>
        <span class="keyword">elif</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">criterion</span> <span class="relational-operator">==</span> <span class="string-literal">'bic'</span><span class="punctuation">:</span>
            <span class="identifier">K</span> <span class="arithmetic-assignment">=</span> <span class="identifier">log</span><span class="grouping">(</span><span class="identifier">n_samples</span><span class="grouping">)</span>  <span class="comment"># BIC</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'criterion should be either bic or aic'</span><span class="grouping">)</span>

        <span class="identifier">R</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span> <span class="arithmetic-operator">-</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">coef_path_</span><span class="grouping">)</span>  <span class="comment"># residuals</span>
        <span class="identifier">mean_squared_error</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="identifier">R</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>
        <span class="identifier">sigma2</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">var</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>

        <span class="identifier">df</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">coef_path_</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">int</span><span class="grouping">)</span>  <span class="comment"># Degrees of freedom</span>
        <span class="keyword">for</span> <span class="identifier">k</span><span class="punctuation">,</span> <span class="identifier">coef</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">coef_path_</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">mask</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">abs</span><span class="grouping">(</span><span class="identifier">coef</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">coef</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span>
            <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">any</span><span class="grouping">(</span><span class="identifier">mask</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">continue</span>
            <span class="comment"># get the number of degrees of freedom equal to:</span>
            <span class="comment"># Xc = X[:, mask]</span>
            <span class="comment"># Trace(Xc * inv(Xc.T, Xc) * Xc.T) ie the number of non-zero coefs</span>
            <span class="identifier">df</span><span class="grouping">[</span><span class="identifier">k</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">mask</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alphas_</span>
        <span class="identifier">eps64</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="string-literal">'float64'</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">criterion_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">n_samples</span> <span class="arithmetic-operator">*</span> <span class="identifier">mean_squared_error</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">sigma2</span> <span class="arithmetic-operator">+</span> <span class="identifier">eps64</span><span class="grouping">)</span> <span class="arithmetic-operator">+</span>
                           <span class="identifier">K</span> <span class="arithmetic-operator">*</span> <span class="identifier">df</span><span class="grouping">)</span>  <span class="comment"># Eqns. 2.15--16 in (Zou et al, 2007)</span>
        <span class="identifier">n_best</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argmin</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">criterion_</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alphas_</span><span class="grouping">[</span><span class="identifier">n_best</span><span class="grouping">]</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coef_path_</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">n_best</span><span class="grouping">]</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_set_intercept</span><span class="grouping">(</span><span class="identifier">Xmean</span><span class="punctuation">,</span> <span class="identifier">ymean</span><span class="punctuation">,</span> <span class="identifier">Xstd</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    </pre>
  </body>
</html>