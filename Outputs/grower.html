<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""
This module contains the TreeGrower class.

TreeGrower builds a regression tree fitting a Newton-Raphson step, based on
the gradients and hessians of the training data.
"""</span>
<span class="comment"># Author: Nicolas Hug</span>

<span class="keyword">from</span> <span class="identifier">heapq</span> <span class="keyword">import</span> <span class="identifier">heappush</span><span class="punctuation">,</span> <span class="identifier">heappop</span>
<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">from</span> <span class="identifier">timeit</span> <span class="keyword">import</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">i</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">r</span> <span class="keyword">as</span> <span class="identifier">time</span>
<span class="keyword">import</span> <span class="identifier">numbers</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">splitting</span> <span class="keyword">import</span> <span class="identifier">Splitter</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">histogram</span> <span class="keyword">import</span> <span class="identifier">HistogramBuilder</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">predictor</span> <span class="keyword">import</span> <span class="identifier">TreePredictor</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">sum_parallel</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">common</span> <span class="keyword">import</span> <span class="identifier">PREDICTOR_RECORD_DTYPE</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">common</span> <span class="keyword">import</span> <span class="identifier">X_BITSET_INNER_DTYPE</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">common</span> <span class="keyword">import</span> <span class="identifier">Y_DTYPE</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">common</span> <span class="keyword">import</span> <span class="identifier">MonotonicConstraint</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_bitset</span> <span class="keyword">import</span> <span class="identifier">set_raw_bitset_from_binned_bitset</span>

<span class="identifier">EPS</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">Y_DTYPE</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">eps</span>  <span class="comment"># to avoid zero division errors</span>


<span class="keyword">class</span> <span class="identifier">TreeNode</span><span class="punctuation">:</span>
    <span class="comment">"""Tree Node class used in TreeGrower.

    This isn't used for prediction purposes, only for training (see
    TreePredictor).

    Parameters
    ----------
    depth : int
        The depth of the node, i.e. its distance from the root.
    sample_indices : ndarray of shape (n_samples_at_node,), dtype=np.uint
        The indices of the samples at the node.
    sum_gradients : float
        The sum of the gradients of the samples at the node.
    sum_hessians : float
        The sum of the hessians of the samples at the node.

    Attributes
    ----------
    depth : int
        The depth of the node, i.e. its distance from the root.
    sample_indices : ndarray of shape (n_samples_at_node,), dtype=np.uint
        The indices of the samples at the node.
    sum_gradients : float
        The sum of the gradients of the samples at the node.
    sum_hessians : float
        The sum of the hessians of the samples at the node.
    split_info : SplitInfo or None
        The result of the split evaluation.
    left_child : TreeNode or None
        The left child of the node. None for leaves.
    right_child : TreeNode or None
        The right child of the node. None for leaves.
    value : float or None
        The value of the leaf, as computed in finalize_leaf(). None for
        non-leaf nodes.
    partition_start : int
        start position of the node's sample_indices in splitter.partition.
    partition_stop : int
        stop position of the node's sample_indices in splitter.partition.
    """</span>

    <span class="identifier">split_info</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
    <span class="identifier">left_child</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
    <span class="identifier">right_child</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
    <span class="identifier">histograms</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>

    <span class="comment"># start and stop indices of the node in the splitter.partition</span>
    <span class="comment"># array. Concretely,</span>
    <span class="comment"># self.sample_indices = view(self.splitter.partition[start:stop])</span>
    <span class="comment"># Please see the comments about splitter.partition and</span>
    <span class="comment"># splitter.split_indices for more info about this design.</span>
    <span class="comment"># These 2 attributes are only used in _update_raw_prediction, because we</span>
    <span class="comment"># need to iterate over the leaves and I don't know how to efficiently</span>
    <span class="comment"># store the sample_indices views because they're all of different sizes.</span>
    <span class="identifier">partition_start</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
    <span class="identifier">partition_stop</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">depth</span><span class="punctuation">,</span> <span class="identifier">sample_indices</span><span class="punctuation">,</span> <span class="identifier">sum_gradients</span><span class="punctuation">,</span>
                 <span class="identifier">sum_hessians</span><span class="punctuation">,</span> <span class="identifier">value</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">depth</span> <span class="arithmetic-assignment">=</span> <span class="identifier">depth</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sample_indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sample_indices</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sample_indices</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sum_gradients</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sum_gradients</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">sum_hessians</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sum_hessians</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">value</span> <span class="arithmetic-assignment">=</span> <span class="identifier">value</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">is_leaf</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">set_children_bounds</span><span class="grouping">(</span><span class="identifier">float</span><span class="grouping">(</span><span class="string-literal">'-inf'), float('+inf'</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">set_children_bounds</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">lower</span><span class="punctuation">,</span> <span class="identifier">upper</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Set children values bounds to respect monotonic constraints."""</span>

        <span class="comment"># These are bounds for the node's *children* values, not the node's</span>
        <span class="comment"># value. The bounds are used in the splitter when considering potential</span>
        <span class="comment"># left and right child.</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">children_lower_bound</span> <span class="arithmetic-assignment">=</span> <span class="identifier">lower</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">children_upper_bound</span> <span class="arithmetic-assignment">=</span> <span class="identifier">upper</span>

    <span class="keyword">def</span> <span class="identifier">__lt__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">other_node</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Comparison for priority queue.

        Nodes with high gain are higher priority than nodes with low gain.

        heapq.heappush only need the '&lt;' operator.
        heapq.heappop take the smallest item first (smaller is higher
        priority).

        Parameters
        ----------
        other_node : TreeNode
            The node to compare with.
        """</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">gain</span> <span class="relational-operator">&gt;</span> <span class="identifier">other_node</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">gain</span>


<span class="keyword">class</span> <span class="identifier">TreeGrower</span><span class="punctuation">:</span>
    <span class="comment">"""Tree grower class used to build a tree.

    The tree is fitted to predict the values of a Newton-Raphson step. The
    splits are considered in a best-first fashion, and the quality of a
    split is defined in splitting._split_gain.

    Parameters
    ----------
    X_binned : ndarray of shape (n_samples, n_features), dtype=np.uint8
        The binned input samples. Must be Fortran-aligned.
    gradients : ndarray of shape (n_samples,)
        The gradients of each training sample. Those are the gradients of the
        loss w.r.t the predictions, evaluated at iteration ``i - 1``.
    hessians : ndarray of shape (n_samples,)
        The hessians of each training sample. Those are the hessians of the
        loss w.r.t the predictions, evaluated at iteration ``i - 1``.
    max_leaf_nodes : int, default=None
        The maximum number of leaves for each tree. If None, there is no
        maximum limit.
    max_depth : int, default=None
        The maximum depth of each tree. The depth of a tree is the number of
        edges to go from the root to the deepest leaf.
        Depth isn't constrained by default.
    min_samples_leaf : int, default=20
        The minimum number of samples per leaf.
    min_gain_to_split : float, default=0.
        The minimum gain needed to split a node. Splits with lower gain will
        be ignored.
    n_bins : int, default=256
        The total number of bins, including the bin for missing values. Used
        to define the shape of the histograms.
    n_bins_non_missing : ndarray, dtype=np.uint32, default=None
        For each feature, gives the number of bins actually used for
        non-missing values. For features with a lot of unique values, this
        is equal to ``n_bins - 1``. If it's an int, all features are
        considered to have the same number of bins. If None, all features
        are considered to have ``n_bins - 1`` bins.
    has_missing_values : bool or ndarray, dtype=bool, default=False
        Whether each feature contains missing values (in the training data).
        If it's a bool, the same value is used for all features.
    is_categorical : ndarray of bool of shape (n_features,), default=None
        Indicates categorical features.
    monotonic_cst : array-like of shape (n_features,), dtype=int, default=None
        Indicates the monotonic constraint to enforce on each feature. -1, 1
        and 0 respectively correspond to a positive constraint, negative
        constraint and no constraint. Read more in the :ref:`User Guide
        &lt;monotonic_cst_gbdt&gt;`.
    l2_regularization : float, default=0.
        The L2 regularization parameter.
    min_hessian_to_split : float, default=1e-3
        The minimum sum of hessians needed in each node. Splits that result in
        at least one child having a sum of hessians less than
        ``min_hessian_to_split`` are discarded.
    shrinkage : float, default=1.
        The shrinkage parameter to apply to the leaves values, also known as
        learning rate.
    """</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X_binned</span><span class="punctuation">,</span> <span class="identifier">gradients</span><span class="punctuation">,</span> <span class="identifier">hessians</span><span class="punctuation">,</span> <span class="identifier">max_leaf_nodes</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">max_depth</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">min_samples_leaf</span><span class="arithmetic-assignment">=</span><span class="int-literal">20</span><span class="punctuation">,</span> <span class="identifier">min_gain_to_split</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">.</span><span class="punctuation">,</span>
                 <span class="identifier">n_bins</span><span class="arithmetic-assignment">=</span><span class="int-literal">256</span><span class="punctuation">,</span> <span class="identifier">n_bins_non_missing</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">has_missing_values</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                 <span class="identifier">is_categorical</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">monotonic_cst</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">l2_regularization</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">.</span><span class="punctuation">,</span> <span class="identifier">min_hessian_to_split</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="punctuation">,</span>
                 <span class="identifier">shrinkage</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">.</span><span class="grouping">)</span><span class="punctuation">:</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_parameters</span><span class="grouping">(</span><span class="identifier">X_binned</span><span class="punctuation">,</span> <span class="identifier">max_leaf_nodes</span><span class="punctuation">,</span> <span class="identifier">max_depth</span><span class="punctuation">,</span>
                                  <span class="identifier">min_samples_leaf</span><span class="punctuation">,</span> <span class="identifier">min_gain_to_split</span><span class="punctuation">,</span>
                                  <span class="identifier">l2_regularization</span><span class="punctuation">,</span> <span class="identifier">min_hessian_to_split</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">n_bins_non_missing</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">n_bins_non_missing</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_bins</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span>

        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">n_bins_non_missing</span><span class="punctuation">,</span> <span class="identifier">numbers</span><span class="punctuation">.</span><span class="identifier">Integral</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">n_bins_non_missing</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span>
                <span class="grouping">[</span><span class="identifier">n_bins_non_missing</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">X_binned</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span>
                <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">uint32</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">n_bins_non_missing</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">n_bins_non_missing</span><span class="punctuation">,</span>
                                            <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">uint32</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">has_missing_values</span><span class="punctuation">,</span> <span class="identifier">bool</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">has_missing_values</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">has_missing_values</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">X_binned</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>
        <span class="identifier">has_missing_values</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">has_missing_values</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">uint8</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">monotonic_cst</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">w</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">o</span><span class="invalid">t</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">s</span><span class="invalid">t</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
            <span class="identifier">monotonic_cst</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">full</span><span class="grouping">(</span><span class="identifier">shape</span><span class="arithmetic-assignment">=</span><span class="identifier">X_binned</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span>
                                    <span class="identifier">fill_value</span><span class="arithmetic-assignment">=</span><span class="identifier">MonotonicConstraint</span><span class="punctuation">.</span><span class="identifier">NO_CST</span><span class="punctuation">,</span>
                                    <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">int8</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">w</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">o</span><span class="invalid">t</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">s</span><span class="invalid">t</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>
            <span class="identifier">monotonic_cst</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">monotonic_cst</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">int8</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="identifier">monotonic_cst</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">!=</span> <span class="identifier">X_binned</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                    <span class="string-literal">"monotonic_cst has shape {} but the input data "</span>
                    <span class="string-literal">"X has {} features."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span>
                        <span class="identifier">monotonic_cst</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X_binned</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>
                    <span class="grouping">)</span>
                <span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">any</span><span class="grouping">(</span><span class="identifier">monotonic_cst</span> <span class="relational-operator">&lt;</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span> <span class="logical-operator">or</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">any</span><span class="grouping">(</span><span class="identifier">monotonic_cst</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                    <span class="string-literal">"monotonic_cst must be None or an array-like of "</span>
                    <span class="string-literal">"-1, 0 or 1."</span>
                    <span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">is_categorical</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">is_categorical</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">shape</span><span class="arithmetic-assignment">=</span><span class="identifier">X_binned</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">uint8</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">is_categorical</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">is_categorical</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">uint8</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">any</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">logical_and</span><span class="grouping">(</span><span class="identifier">is_categorical</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">,</span>
                                 <span class="identifier">monotonic_cst</span> <span class="relational-operator">!=</span> <span class="identifier">MonotonicConstraint</span><span class="punctuation">.</span><span class="identifier">NO_CST</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Categorical features cannot have monotonic "</span>
                             <span class="string-literal">"constraints."</span><span class="grouping">)</span>

        <span class="identifier">hessians_are_constant</span> <span class="arithmetic-assignment">=</span> <span class="identifier">hessians</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">==</span> <span class="int-literal">1</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">histogram_builder</span> <span class="arithmetic-assignment">=</span> <span class="identifier">HistogramBuilder</span><span class="grouping">(</span>
            <span class="identifier">X_binned</span><span class="punctuation">,</span> <span class="identifier">n_bins</span><span class="punctuation">,</span> <span class="identifier">gradients</span><span class="punctuation">,</span> <span class="identifier">hessians</span><span class="punctuation">,</span> <span class="identifier">hessians_are_constant</span><span class="grouping">)</span>
        <span class="identifier">missing_values_bin_idx</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_bins</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">splitter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Splitter</span><span class="grouping">(</span>
            <span class="identifier">X_binned</span><span class="punctuation">,</span> <span class="identifier">n_bins_non_missing</span><span class="punctuation">,</span> <span class="identifier">missing_values_bin_idx</span><span class="punctuation">,</span>
            <span class="identifier">has_missing_values</span><span class="punctuation">,</span> <span class="identifier">is_categorical</span><span class="punctuation">,</span> <span class="identifier">monotonic_cst</span><span class="punctuation">,</span>
            <span class="identifier">l2_regularization</span><span class="punctuation">,</span> <span class="identifier">min_hessian_to_split</span><span class="punctuation">,</span>
            <span class="identifier">min_samples_leaf</span><span class="punctuation">,</span> <span class="identifier">min_gain_to_split</span><span class="punctuation">,</span> <span class="identifier">hessians_are_constant</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_bins_non_missing</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_bins_non_missing</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">missing_values_bin_idx</span> <span class="arithmetic-assignment">=</span> <span class="identifier">missing_values_bin_idx</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_leaf_nodes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_leaf_nodes</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">has_missing_values</span> <span class="arithmetic-assignment">=</span> <span class="identifier">has_missing_values</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">monotonic_cst</span> <span class="arithmetic-assignment">=</span> <span class="identifier">monotonic_cst</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">is_categorical</span> <span class="arithmetic-assignment">=</span> <span class="identifier">is_categorical</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l2_regularization</span> <span class="arithmetic-assignment">=</span> <span class="identifier">l2_regularization</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_binned</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_depth</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_depth</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">min_samples_leaf</span> <span class="arithmetic-assignment">=</span> <span class="identifier">min_samples_leaf</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X_binned</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_binned</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">min_gain_to_split</span> <span class="arithmetic-assignment">=</span> <span class="identifier">min_gain_to_split</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">shrinkage</span> <span class="arithmetic-assignment">=</span> <span class="identifier">shrinkage</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">splittable_nodes</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">finalized_leaves</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">total_find_split_time</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>  <span class="comment"># time spent finding the best splits</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">total_compute_hist_time</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>  <span class="comment"># time spent computing histograms</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">total_apply_split_time</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>  <span class="comment"># time spent splitting nodes</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_categorical_splits</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_intilialize_root</span><span class="grouping">(</span><span class="identifier">gradients</span><span class="punctuation">,</span> <span class="identifier">hessians</span><span class="punctuation">,</span> <span class="identifier">hessians_are_constant</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_nodes</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>

    <span class="keyword">def</span> <span class="identifier">_validate_parameters</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X_binned</span><span class="punctuation">,</span> <span class="identifier">max_leaf_nodes</span><span class="punctuation">,</span> <span class="identifier">max_depth</span><span class="punctuation">,</span>
                             <span class="identifier">min_samples_leaf</span><span class="punctuation">,</span> <span class="identifier">min_gain_to_split</span><span class="punctuation">,</span>
                             <span class="identifier">l2_regularization</span><span class="punctuation">,</span> <span class="identifier">min_hessian_to_split</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Validate parameters passed to __init__.

        Also validate parameters passed to splitter.
        """</span>
        <span class="keyword">if</span> <span class="identifier">X_binned</span><span class="punctuation">.</span><span class="identifier">dtype</span> <span class="relational-operator">!=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">uint8</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">NotImplementedError</span><span class="grouping">(</span>
                <span class="string-literal">"X_binned must be of type uint8."</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">X_binned</span><span class="punctuation">.</span><span class="identifier">flags</span><span class="punctuation">.</span><span class="identifier">f_contiguous</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">"X_binned should be passed as Fortran contiguous "</span>
                <span class="string-literal">"array for maximum efficiency."</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">max_leaf_nodes</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">max_leaf_nodes</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'max_leaf_nodes={} should not be'</span>
                             <span class="string-literal">' smaller than 2'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">max_leaf_nodes</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">max_depth</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">max_depth</span> <span class="relational-operator">&lt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'max_depth={} should not be'</span>
                             <span class="string-literal">' smaller than 1'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">max_depth</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">min_samples_leaf</span> <span class="relational-operator">&lt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'min_samples_leaf={} should '</span>
                             <span class="string-literal">'not be smaller than 1'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">min_samples_leaf</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">min_gain_to_split</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'min_gain_to_split={} '</span>
                             <span class="string-literal">'must be positive.'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">min_gain_to_split</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">l2_regularization</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'l2_regularization={} must be '</span>
                             <span class="string-literal">'positive.'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">l2_regularization</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">min_hessian_to_split</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'min_hessian_to_split={} '</span>
                             <span class="string-literal">'must be positive.'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">min_hessian_to_split</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">grow</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Grow the tree, from root to leaves."""</span>
        <span class="keyword">while</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">splittable_nodes</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">split_next</span><span class="grouping">(</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_apply_shrinkage</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_apply_shrinkage</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Multiply leaves values by shrinkage parameter.

        This must be done at the very end of the growing process. If this were
        done during the growing process e.g. in finalize_leaf(), then a leaf
        would be shrunk but its sibling would potentially not be (if it's a
        non-leaf), which would lead to a wrong computation of the 'middle'
        value needed to enforce the monotonic constraints.
        """</span>
        <span class="keyword">for</span> <span class="identifier">leaf</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">finalized_leaves</span><span class="punctuation">:</span>
            <span class="identifier">leaf</span><span class="punctuation">.</span><span class="identifier">value</span> <span class="arithmetic-assignment">*=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">shrinkage</span>

    <span class="keyword">def</span> <span class="identifier">_intilialize_root</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">gradients</span><span class="punctuation">,</span> <span class="identifier">hessians</span><span class="punctuation">,</span> <span class="identifier">hessians_are_constant</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Initialize root node and finalize it if needed."""</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">X_binned</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">depth</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
        <span class="identifier">sum_gradients</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sum_parallel</span><span class="grouping">(</span><span class="identifier">gradients</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">histogram_builder</span><span class="punctuation">.</span><span class="identifier">hessians_are_constant</span><span class="punctuation">:</span>
            <span class="identifier">sum_hessians</span> <span class="arithmetic-assignment">=</span> <span class="identifier">hessians</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_samples</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">sum_hessians</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sum_parallel</span><span class="grouping">(</span><span class="identifier">hessians</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root</span> <span class="arithmetic-assignment">=</span> <span class="identifier">TreeNode</span><span class="grouping">(</span>
            <span class="identifier">depth</span><span class="arithmetic-assignment">=</span><span class="identifier">depth</span><span class="punctuation">,</span>
            <span class="identifier">sample_indices</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">splitter</span><span class="punctuation">.</span><span class="identifier">partition</span><span class="punctuation">,</span>
            <span class="identifier">sum_gradients</span><span class="arithmetic-assignment">=</span><span class="identifier">sum_gradients</span><span class="punctuation">,</span>
            <span class="identifier">sum_hessians</span><span class="arithmetic-assignment">=</span><span class="identifier">sum_hessians</span><span class="punctuation">,</span>
            <span class="identifier">value</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span>
        <span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root</span><span class="punctuation">.</span><span class="identifier">partition_start</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root</span><span class="punctuation">.</span><span class="identifier">partition_stop</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_samples</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root</span><span class="punctuation">.</span><span class="identifier">n_samples</span> <span class="relational-operator">&lt;</span> <span class="int-literal">2</span> <span class="arithmetic-operator">*</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">min_samples_leaf</span><span class="punctuation">:</span>
            <span class="comment"># Do not even bother computing any splitting statistics.</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_finalize_leaf</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root</span><span class="grouping">)</span>
            <span class="keyword">return</span>
        <span class="keyword">if</span> <span class="identifier">sum_hessians</span> <span class="relational-operator">&lt;</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">splitter</span><span class="punctuation">.</span><span class="identifier">min_hessian_to_split</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_finalize_leaf</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root</span><span class="grouping">)</span>
            <span class="keyword">return</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root</span><span class="punctuation">.</span><span class="identifier">histograms</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">histogram_builder</span><span class="punctuation">.</span><span class="identifier">compute_histograms_brute</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root</span><span class="punctuation">.</span><span class="identifier">sample_indices</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_compute_best_split_and_push</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_compute_best_split_and_push</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">node</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute the best possible split (SplitInfo) of a given node.

        Also push it in the heap of splittable nodes if gain isn't zero.
        The gain of a node is 0 if either all the leaves are pure
        (best gain = 0), or if no split would satisfy the constraints,
        (min_hessians_to_split, min_gain_to_split, min_samples_leaf)
        """</span>

        <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">split_info</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">splitter</span><span class="punctuation">.</span><span class="identifier">find_node_split</span><span class="grouping">(</span>
            <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">histograms</span><span class="punctuation">,</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">sum_gradients</span><span class="punctuation">,</span>
            <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">sum_hessians</span><span class="punctuation">,</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">value</span><span class="punctuation">,</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">children_lower_bound</span><span class="punctuation">,</span>
            <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">children_upper_bound</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">gain</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="punctuation">:</span>  <span class="comment"># no valid split</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_finalize_leaf</span><span class="grouping">(</span><span class="identifier">node</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">heappush</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">splittable_nodes</span><span class="punctuation">,</span> <span class="identifier">node</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">split_next</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Split the node with highest potential gain.

        Returns
        -------
        left : TreeNode
            The resulting left child.
        right : TreeNode
            The resulting right child.
        """</span>
        <span class="comment"># Consider the node with the highest loss reduction (a.k.a. gain)</span>
        <span class="identifier">node</span> <span class="arithmetic-assignment">=</span> <span class="identifier">heappop</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">splittable_nodes</span><span class="grouping">)</span>

        <span class="identifier">tic</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="grouping">(</span><span class="identifier">sample_indices_left</span><span class="punctuation">,</span>
         <span class="identifier">sample_indices_right</span><span class="punctuation">,</span>
         <span class="identifier">right_child_pos</span><span class="grouping">)</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">splitter</span><span class="punctuation">.</span><span class="identifier">split_indices</span><span class="grouping">(</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">,</span>
                                                        <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">sample_indices</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">total_apply_split_time</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">tic</span>

        <span class="identifier">depth</span> <span class="arithmetic-assignment">=</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">depth</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span>
        <span class="identifier">n_leaf_nodes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">finalized_leaves</span><span class="grouping">)</span> <span class="arithmetic-operator">+</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">splittable_nodes</span><span class="grouping">)</span>
        <span class="identifier">n_leaf_nodes</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">2</span>

        <span class="identifier">left_child_node</span> <span class="arithmetic-assignment">=</span> <span class="identifier">TreeNode</span><span class="grouping">(</span><span class="identifier">depth</span><span class="punctuation">,</span>
                                   <span class="identifier">sample_indices_left</span><span class="punctuation">,</span>
                                   <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">sum_gradient_left</span><span class="punctuation">,</span>
                                   <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">sum_hessian_left</span><span class="punctuation">,</span>
                                   <span class="identifier">value</span><span class="arithmetic-assignment">=</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">value_left</span><span class="punctuation">,</span>
                                   <span class="grouping">)</span>
        <span class="identifier">right_child_node</span> <span class="arithmetic-assignment">=</span> <span class="identifier">TreeNode</span><span class="grouping">(</span><span class="identifier">depth</span><span class="punctuation">,</span>
                                    <span class="identifier">sample_indices_right</span><span class="punctuation">,</span>
                                    <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">sum_gradient_right</span><span class="punctuation">,</span>
                                    <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">sum_hessian_right</span><span class="punctuation">,</span>
                                    <span class="identifier">value</span><span class="arithmetic-assignment">=</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">value_right</span><span class="punctuation">,</span>
                                    <span class="grouping">)</span>

        <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">right_child</span> <span class="arithmetic-assignment">=</span> <span class="identifier">right_child_node</span>
        <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">left_child</span> <span class="arithmetic-assignment">=</span> <span class="identifier">left_child_node</span>

        <span class="comment"># set start and stop indices</span>
        <span class="identifier">left_child_node</span><span class="punctuation">.</span><span class="identifier">partition_start</span> <span class="arithmetic-assignment">=</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">partition_start</span>
        <span class="identifier">left_child_node</span><span class="punctuation">.</span><span class="identifier">partition_stop</span> <span class="arithmetic-assignment">=</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">partition_start</span> <span class="arithmetic-operator">+</span> <span class="identifier">right_child_pos</span>
        <span class="identifier">right_child_node</span><span class="punctuation">.</span><span class="identifier">partition_start</span> <span class="arithmetic-assignment">=</span> <span class="identifier">left_child_node</span><span class="punctuation">.</span><span class="identifier">partition_stop</span>
        <span class="identifier">right_child_node</span><span class="punctuation">.</span><span class="identifier">partition_stop</span> <span class="arithmetic-assignment">=</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">partition_stop</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">has_missing_values</span><span class="grouping">[</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">feature_idx</span><span class="grouping">]</span><span class="punctuation">:</span>
            <span class="comment"># If no missing values are encountered at fit time, then samples</span>
            <span class="comment"># with missing values during predict() will go to whichever child</span>
            <span class="comment"># has the most samples.</span>
            <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">missing_go_to_left</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span>
                <span class="identifier">left_child_node</span><span class="punctuation">.</span><span class="identifier">n_samples</span> <span class="relational-operator">&gt;</span> <span class="identifier">right_child_node</span><span class="punctuation">.</span><span class="identifier">n_samples</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_nodes</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">2</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_categorical_splits</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">is_categorical</span>

        <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_leaf_nodes</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span>
                <span class="logical-operator">and</span> <span class="identifier">n_leaf_nodes</span> <span class="relational-operator">==</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_leaf_nodes</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_finalize_leaf</span><span class="grouping">(</span><span class="identifier">left_child_node</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_finalize_leaf</span><span class="grouping">(</span><span class="identifier">right_child_node</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_finalize_splittable_nodes</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="identifier">left_child_node</span><span class="punctuation">,</span> <span class="identifier">right_child_node</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_depth</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">depth</span> <span class="relational-operator">==</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_depth</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_finalize_leaf</span><span class="grouping">(</span><span class="identifier">left_child_node</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_finalize_leaf</span><span class="grouping">(</span><span class="identifier">right_child_node</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="identifier">left_child_node</span><span class="punctuation">,</span> <span class="identifier">right_child_node</span>

        <span class="keyword">if</span> <span class="identifier">left_child_node</span><span class="punctuation">.</span><span class="identifier">n_samples</span> <span class="relational-operator">&lt;</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">min_samples_leaf</span> <span class="arithmetic-operator">*</span> <span class="int-literal">2</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_finalize_leaf</span><span class="grouping">(</span><span class="identifier">left_child_node</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">right_child_node</span><span class="punctuation">.</span><span class="identifier">n_samples</span> <span class="relational-operator">&lt;</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">min_samples_leaf</span> <span class="arithmetic-operator">*</span> <span class="int-literal">2</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_finalize_leaf</span><span class="grouping">(</span><span class="identifier">right_child_node</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">w</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">o</span><span class="invalid">t</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">s</span><span class="invalid">t</span><span class="punctuation">:</span>
            <span class="comment"># Set value bounds for respecting monotonic constraints</span>
            <span class="comment"># See test_nodes_values() for details</span>
            <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">monotonic_cst</span><span class="grouping">[</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">feature_idx</span><span class="grouping">]</span> <span class="relational-operator">==</span>
                    <span class="identifier">MonotonicConstraint</span><span class="punctuation">.</span><span class="identifier">NO_CST</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">lower_left</span> <span class="arithmetic-assignment">=</span> <span class="identifier">lower_right</span> <span class="arithmetic-assignment">=</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">children_lower_bound</span>
                <span class="identifier">upper_left</span> <span class="arithmetic-assignment">=</span> <span class="identifier">upper_right</span> <span class="arithmetic-assignment">=</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">children_upper_bound</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">mid</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">left_child_node</span><span class="punctuation">.</span><span class="identifier">value</span> <span class="arithmetic-operator">+</span> <span class="identifier">right_child_node</span><span class="punctuation">.</span><span class="identifier">value</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="int-literal">2</span>
                <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">monotonic_cst</span><span class="grouping">[</span><span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">feature_idx</span><span class="grouping">]</span> <span class="relational-operator">==</span>
                        <span class="identifier">MonotonicConstraint</span><span class="punctuation">.</span><span class="identifier">POS</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">lower_left</span><span class="punctuation">,</span> <span class="identifier">upper_left</span> <span class="arithmetic-assignment">=</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">children_lower_bound</span><span class="punctuation">,</span> <span class="identifier">mid</span>
                    <span class="identifier">lower_right</span><span class="punctuation">,</span> <span class="identifier">upper_right</span> <span class="arithmetic-assignment">=</span> <span class="identifier">mid</span><span class="punctuation">,</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">children_upper_bound</span>
                <span class="keyword">else</span><span class="punctuation">:</span>  <span class="comment"># NEG</span>
                    <span class="identifier">lower_left</span><span class="punctuation">,</span> <span class="identifier">upper_left</span> <span class="arithmetic-assignment">=</span> <span class="identifier">mid</span><span class="punctuation">,</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">children_upper_bound</span>
                    <span class="identifier">lower_right</span><span class="punctuation">,</span> <span class="identifier">upper_right</span> <span class="arithmetic-assignment">=</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">children_lower_bound</span><span class="punctuation">,</span> <span class="identifier">mid</span>
            <span class="identifier">left_child_node</span><span class="punctuation">.</span><span class="identifier">set_children_bounds</span><span class="grouping">(</span><span class="identifier">lower_left</span><span class="punctuation">,</span> <span class="identifier">upper_left</span><span class="grouping">)</span>
            <span class="identifier">right_child_node</span><span class="punctuation">.</span><span class="identifier">set_children_bounds</span><span class="grouping">(</span><span class="identifier">lower_right</span><span class="punctuation">,</span> <span class="identifier">upper_right</span><span class="grouping">)</span>

        <span class="comment"># Compute histograms of children, and compute their best possible split</span>
        <span class="comment"># (if needed)</span>
        <span class="identifier">should_split_left</span> <span class="arithmetic-assignment">=</span> <span class="logical-operator">not</span> <span class="identifier">left_child_node</span><span class="punctuation">.</span><span class="identifier">is_leaf</span>
        <span class="identifier">should_split_right</span> <span class="arithmetic-assignment">=</span> <span class="logical-operator">not</span> <span class="identifier">right_child_node</span><span class="punctuation">.</span><span class="identifier">is_leaf</span>
        <span class="keyword">if</span> <span class="identifier">should_split_left</span> <span class="logical-operator">or</span> <span class="identifier">should_split_right</span><span class="punctuation">:</span>

            <span class="comment"># We will compute the histograms of both nodes even if one of them</span>
            <span class="comment"># is a leaf, since computing the second histogram is very cheap</span>
            <span class="comment"># (using histogram subtraction).</span>
            <span class="identifier">n_samples_left</span> <span class="arithmetic-assignment">=</span> <span class="identifier">left_child_node</span><span class="punctuation">.</span><span class="identifier">sample_indices</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
            <span class="identifier">n_samples_right</span> <span class="arithmetic-assignment">=</span> <span class="identifier">right_child_node</span><span class="punctuation">.</span><span class="identifier">sample_indices</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
            <span class="keyword">if</span> <span class="identifier">n_samples_left</span> <span class="relational-operator">&lt;</span> <span class="identifier">n_samples_right</span><span class="punctuation">:</span>
                <span class="identifier">smallest_child</span> <span class="arithmetic-assignment">=</span> <span class="identifier">left_child_node</span>
                <span class="identifier">largest_child</span> <span class="arithmetic-assignment">=</span> <span class="identifier">right_child_node</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">smallest_child</span> <span class="arithmetic-assignment">=</span> <span class="identifier">right_child_node</span>
                <span class="identifier">largest_child</span> <span class="arithmetic-assignment">=</span> <span class="identifier">left_child_node</span>

            <span class="comment"># We use the brute O(n_samples) method on the child that has the</span>
            <span class="comment"># smallest number of samples, and the subtraction trick O(n_bins)</span>
            <span class="comment"># on the other one.</span>
            <span class="identifier">tic</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="identifier">smallest_child</span><span class="punctuation">.</span><span class="identifier">histograms</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">histogram_builder</span><span class="punctuation">.</span><span class="identifier">compute_histograms_brute</span><span class="grouping">(</span>
                    <span class="identifier">smallest_child</span><span class="punctuation">.</span><span class="identifier">sample_indices</span><span class="grouping">)</span>
            <span class="identifier">largest_child</span><span class="punctuation">.</span><span class="identifier">histograms</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">histogram_builder</span><span class="punctuation">.</span><span class="identifier">compute_histograms_subtraction</span><span class="grouping">(</span>
                    <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">histograms</span><span class="punctuation">,</span> <span class="identifier">smallest_child</span><span class="punctuation">.</span><span class="identifier">histograms</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">total_compute_hist_time</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">tic</span>

            <span class="identifier">tic</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">should_split_left</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_compute_best_split_and_push</span><span class="grouping">(</span><span class="identifier">left_child_node</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">should_split_right</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_compute_best_split_and_push</span><span class="grouping">(</span><span class="identifier">right_child_node</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">total_find_split_time</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">tic</span>

            <span class="comment"># Release memory used by histograms as they are no longer needed</span>
            <span class="comment"># for leaf nodes since they won't be split.</span>
            <span class="keyword">for</span> <span class="identifier">child</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="identifier">left_child_node</span><span class="punctuation">,</span> <span class="identifier">right_child_node</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">if</span> <span class="identifier">child</span><span class="punctuation">.</span><span class="identifier">is_leaf</span><span class="punctuation">:</span>
                    <span class="keyword">del</span> <span class="identifier">child</span><span class="punctuation">.</span><span class="identifier">histograms</span>

        <span class="comment"># Release memory used by histograms as they are no longer needed for</span>
        <span class="comment"># internal nodes once children histograms have been computed.</span>
        <span class="keyword">del</span> <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">histograms</span>

        <span class="keyword">return</span> <span class="identifier">left_child_node</span><span class="punctuation">,</span> <span class="identifier">right_child_node</span>

    <span class="keyword">def</span> <span class="identifier">_finalize_leaf</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">node</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Make node a leaf of the tree being grown."""</span>

        <span class="identifier">node</span><span class="punctuation">.</span><span class="identifier">is_leaf</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">finalized_leaves</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">node</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_finalize_splittable_nodes</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Transform all splittable nodes into leaves.

        Used when some constraint is met e.g. maximum number of leaves or
        maximum depth."""</span>
        <span class="keyword">while</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">splittable_nodes</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="identifier">node</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">splittable_nodes</span><span class="punctuation">.</span><span class="identifier">pop</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_finalize_leaf</span><span class="grouping">(</span><span class="identifier">node</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">make_predictor</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">binning_thresholds</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Make a TreePredictor object out of the current tree.

        Parameters
        ----------
        binning_thresholds : array-like of floats
            Corresponds to the bin_thresholds_ attribute of the BinMapper.
            For each feature, this stores:

            - the bin frontiers for continuous features
            - the unique raw category values for categorical features

        Returns
        -------
        A TreePredictor object.
        """</span>
        <span class="identifier">predictor_nodes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_nodes</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">PREDICTOR_RECORD_DTYPE</span><span class="grouping">)</span>
        <span class="identifier">binned_left_cat_bitsets</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_categorical_splits</span><span class="punctuation">,</span> <span class="int-literal">8</span><span class="grouping">)</span><span class="punctuation">,</span>
                                           <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X_BITSET_INNER_DTYPE</span><span class="grouping">)</span>
        <span class="identifier">raw_left_cat_bitsets</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_categorical_splits</span><span class="punctuation">,</span> <span class="int-literal">8</span><span class="grouping">)</span><span class="punctuation">,</span>
                                        <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X_BITSET_INNER_DTYPE</span><span class="grouping">)</span>
        <span class="identifier">_fill_predictor_arrays</span><span class="grouping">(</span><span class="identifier">predictor_nodes</span><span class="punctuation">,</span> <span class="identifier">binned_left_cat_bitsets</span><span class="punctuation">,</span>
                               <span class="identifier">raw_left_cat_bitsets</span><span class="punctuation">,</span>
                               <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">root</span><span class="punctuation">,</span> <span class="identifier">binning_thresholds</span><span class="punctuation">,</span>
                               <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_bins_non_missing</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">TreePredictor</span><span class="grouping">(</span><span class="identifier">predictor_nodes</span><span class="punctuation">,</span> <span class="identifier">binned_left_cat_bitsets</span><span class="punctuation">,</span>
                             <span class="identifier">raw_left_cat_bitsets</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">_fill_predictor_arrays</span><span class="grouping">(</span><span class="identifier">predictor_nodes</span><span class="punctuation">,</span> <span class="identifier">binned_left_cat_bitsets</span><span class="punctuation">,</span>
                           <span class="identifier">raw_left_cat_bitsets</span><span class="punctuation">,</span> <span class="identifier">grower_node</span><span class="punctuation">,</span>
                           <span class="identifier">binning_thresholds</span><span class="punctuation">,</span> <span class="identifier">n_bins_non_missing</span><span class="punctuation">,</span>
                           <span class="identifier">next_free_node_idx</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">next_free_bitset_idx</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Helper used in make_predictor to set the TreePredictor fields."""</span>
    <span class="identifier">node</span> <span class="arithmetic-assignment">=</span> <span class="identifier">predictor_nodes</span><span class="grouping">[</span><span class="identifier">next_free_node_idx</span><span class="grouping">]</span>
    <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'count'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">grower_node</span><span class="punctuation">.</span><span class="identifier">n_samples</span>
    <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'depth'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">grower_node</span><span class="punctuation">.</span><span class="identifier">depth</span>
    <span class="keyword">if</span> <span class="identifier">grower_node</span><span class="punctuation">.</span><span class="identifier">split_info</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'gain'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">grower_node</span><span class="punctuation">.</span><span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">gain</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'gain'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span>

    <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'value'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">grower_node</span><span class="punctuation">.</span><span class="identifier">value</span>

    <span class="keyword">if</span> <span class="identifier">grower_node</span><span class="punctuation">.</span><span class="identifier">is_leaf</span><span class="punctuation">:</span>
        <span class="comment"># Leaf node</span>
        <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'is_leaf'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>
        <span class="keyword">return</span> <span class="identifier">next_free_node_idx</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">next_free_bitset_idx</span>

    <span class="identifier">split_info</span> <span class="arithmetic-assignment">=</span> <span class="identifier">grower_node</span><span class="punctuation">.</span><span class="identifier">split_info</span>
    <span class="identifier">feature_idx</span><span class="punctuation">,</span> <span class="identifier">bin_idx</span> <span class="arithmetic-assignment">=</span> <span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">feature_idx</span><span class="punctuation">,</span> <span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">bin_idx</span>
    <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'feature_idx'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">feature_idx</span>
    <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'bin_threshold'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">bin_idx</span>
    <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'missing_go_to_left'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">missing_go_to_left</span>
    <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'is_categorical'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">is_categorical</span>

    <span class="keyword">if</span> <span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">bin_idx</span> <span class="relational-operator">==</span> <span class="identifier">n_bins_non_missing</span><span class="grouping">[</span><span class="identifier">feature_idx</span><span class="grouping">]</span> <span class="arithmetic-operator">-</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="comment"># Split is on the last non-missing bin: it's a "split on nans".</span>
        <span class="comment"># All nans go to the right, the rest go to the left.</span>
        <span class="comment"># Note: for categorical splits, bin_idx is 0 and we rely on the bitset</span>
        <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'num_threshold'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">inf</span>
    <span class="keyword">elif</span> <span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">is_categorical</span><span class="punctuation">:</span>
        <span class="identifier">categories</span> <span class="arithmetic-assignment">=</span> <span class="identifier">binning_thresholds</span><span class="grouping">[</span><span class="identifier">feature_idx</span><span class="grouping">]</span>
        <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'bitset_idx'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">next_free_bitset_idx</span>
        <span class="identifier">binned_left_cat_bitsets</span><span class="grouping">[</span><span class="identifier">next_free_bitset_idx</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span>
            <span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">left_cat_bitset</span><span class="grouping">)</span>
        <span class="identifier">set_raw_bitset_from_binned_bitset</span><span class="grouping">(</span>
            <span class="identifier">raw_left_cat_bitsets</span><span class="grouping">[</span><span class="identifier">next_free_bitset_idx</span><span class="grouping">]</span><span class="punctuation">,</span>
            <span class="identifier">split_info</span><span class="punctuation">.</span><span class="identifier">left_cat_bitset</span><span class="punctuation">,</span> <span class="identifier">categories</span>
        <span class="grouping">)</span>
        <span class="identifier">next_free_bitset_idx</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">1</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'num_threshold'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">binning_thresholds</span><span class="grouping">[</span><span class="identifier">feature_idx</span><span class="grouping">]</span><span class="grouping">[</span><span class="identifier">bin_idx</span><span class="grouping">]</span>

    <span class="identifier">next_free_node_idx</span> <span class="arithmetic-assignment">+=</span> <span class="int-literal">1</span>

    <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'left'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">next_free_node_idx</span>
    <span class="identifier">next_free_node_idx</span><span class="punctuation">,</span> <span class="identifier">next_free_bitset_idx</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_fill_predictor_arrays</span><span class="grouping">(</span>
        <span class="identifier">predictor_nodes</span><span class="punctuation">,</span> <span class="identifier">binned_left_cat_bitsets</span><span class="punctuation">,</span> <span class="identifier">raw_left_cat_bitsets</span><span class="punctuation">,</span>
        <span class="identifier">grower_node</span><span class="punctuation">.</span><span class="identifier">left_child</span><span class="punctuation">,</span> <span class="identifier">binning_thresholds</span><span class="arithmetic-assignment">=</span><span class="identifier">binning_thresholds</span><span class="punctuation">,</span>
        <span class="identifier">n_bins_non_missing</span><span class="arithmetic-assignment">=</span><span class="identifier">n_bins_non_missing</span><span class="punctuation">,</span>
        <span class="identifier">next_free_node_idx</span><span class="arithmetic-assignment">=</span><span class="identifier">next_free_node_idx</span><span class="punctuation">,</span>
        <span class="identifier">next_free_bitset_idx</span><span class="arithmetic-assignment">=</span><span class="identifier">next_free_bitset_idx</span><span class="grouping">)</span>

    <span class="identifier">node</span><span class="grouping">[</span><span class="string-literal">'right'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">next_free_node_idx</span>
    <span class="keyword">return</span> <span class="identifier">_fill_predictor_arrays</span><span class="grouping">(</span>
        <span class="identifier">predictor_nodes</span><span class="punctuation">,</span> <span class="identifier">binned_left_cat_bitsets</span><span class="punctuation">,</span> <span class="identifier">raw_left_cat_bitsets</span><span class="punctuation">,</span>
        <span class="identifier">grower_node</span><span class="punctuation">.</span><span class="identifier">right_child</span><span class="punctuation">,</span> <span class="identifier">binning_thresholds</span><span class="arithmetic-assignment">=</span><span class="identifier">binning_thresholds</span><span class="punctuation">,</span>
        <span class="identifier">n_bins_non_missing</span><span class="arithmetic-assignment">=</span><span class="identifier">n_bins_non_missing</span><span class="punctuation">,</span>
        <span class="identifier">next_free_node_idx</span><span class="arithmetic-assignment">=</span><span class="identifier">next_free_node_idx</span><span class="punctuation">,</span>
        <span class="identifier">next_free_bitset_idx</span><span class="arithmetic-assignment">=</span><span class="identifier">next_free_bitset_idx</span><span class="grouping">)</span>

    </pre>
  </body>
</html>