<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""Fast Gradient Boosting decision trees for classification and regression."""</span>
<span class="comment"># Author: Nicolas Hug</span>

<span class="keyword">from</span> <span class="identifier">abc</span> <span class="keyword">import</span> <span class="identifier">ABC</span><span class="punctuation">,</span> <span class="identifier">abstractmethod</span>
<span class="keyword">from</span> <span class="identifier">functools</span> <span class="keyword">import</span> <span class="identifier">partial</span>
<span class="keyword">import</span> <span class="identifier">warnings</span>

<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">from</span> <span class="identifier">timeit</span> <span class="keyword">import</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">i</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">r</span> <span class="keyword">as</span> <span class="identifier">time</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="grouping">(</span><span class="identifier">BaseEstimator</span><span class="punctuation">,</span> <span class="identifier">RegressorMixin</span><span class="punctuation">,</span> <span class="invalid">C</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">M</span><span class="invalid">i</span><span class="invalid">x</span><span class="invalid">i</span><span class="invalid">n</span><span class="punctuation">,</span>
                     <span class="identifier">is_classifier</span><span class="grouping">)</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">check_random_state</span><span class="punctuation">,</span> <span class="identifier">resample</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="grouping">(</span><span class="identifier">check_is_fitted</span><span class="punctuation">,</span>
                                 <span class="identifier">check_consistent_length</span><span class="punctuation">,</span>
                                 <span class="identifier">_check_sample_weight</span><span class="grouping">)</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">multiclass</span> <span class="keyword">import</span> <span class="identifier">check_classification_targets</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">metrics</span> <span class="keyword">import</span> <span class="identifier">check_scoring</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">model_selection</span> <span class="keyword">import</span> <span class="identifier">train_test_split</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">preprocessing</span> <span class="keyword">import</span> <span class="identifier">LabelEncoder</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_gradient_boosting</span> <span class="keyword">import</span> <span class="identifier">_update_raw_predictions</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">common</span> <span class="keyword">import</span> <span class="identifier">Y_DTYPE</span><span class="punctuation">,</span> <span class="identifier">X_DTYPE</span><span class="punctuation">,</span> <span class="identifier">X_BINNED_DTYPE</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">binning</span> <span class="keyword">import</span> <span class="identifier">_BinMapper</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">grower</span> <span class="keyword">import</span> <span class="identifier">TreeGrower</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">loss</span> <span class="keyword">import</span> <span class="identifier">_LOSSES</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">loss</span> <span class="keyword">import</span> <span class="identifier">BaseLoss</span>


<span class="keyword">class</span> <span class="identifier">BaseHistGradientBoosting</span><span class="grouping">(</span><span class="identifier">BaseEstimator</span><span class="punctuation">,</span> <span class="identifier">ABC</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Base class for histogram-based gradient boosting estimators."""</span>

    <span class="punctuation">@</span><span class="identifier">abstractmethod</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">loss</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">learning_rate</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">max_leaf_nodes</span><span class="punctuation">,</span>
                 <span class="identifier">max_depth</span><span class="punctuation">,</span> <span class="identifier">min_samples_leaf</span><span class="punctuation">,</span> <span class="identifier">l2_regularization</span><span class="punctuation">,</span> <span class="identifier">max_bins</span><span class="punctuation">,</span>
                 <span class="identifier">categorical_features</span><span class="punctuation">,</span> <span class="identifier">monotonic_cst</span><span class="punctuation">,</span>
                 <span class="identifier">warm_start</span><span class="punctuation">,</span> <span class="identifier">early_stopping</span><span class="punctuation">,</span> <span class="identifier">scoring</span><span class="punctuation">,</span>
                 <span class="identifier">validation_fraction</span><span class="punctuation">,</span> <span class="identifier">n_iter_no_change</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="punctuation">,</span>
                 <span class="identifier">random_state</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">loss</span> <span class="arithmetic-assignment">=</span> <span class="identifier">loss</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">learning_rate</span> <span class="arithmetic-assignment">=</span> <span class="identifier">learning_rate</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_leaf_nodes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_leaf_nodes</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_depth</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_depth</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">min_samples_leaf</span> <span class="arithmetic-assignment">=</span> <span class="identifier">min_samples_leaf</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l2_regularization</span> <span class="arithmetic-assignment">=</span> <span class="identifier">l2_regularization</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_bins</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_bins</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">monotonic_cst</span> <span class="arithmetic-assignment">=</span> <span class="identifier">monotonic_cst</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">categorical_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">categorical_features</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">warm_start</span> <span class="arithmetic-assignment">=</span> <span class="identifier">warm_start</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">early_stopping</span> <span class="arithmetic-assignment">=</span> <span class="identifier">early_stopping</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span> <span class="arithmetic-assignment">=</span> <span class="identifier">scoring</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_fraction</span> <span class="arithmetic-assignment">=</span> <span class="identifier">validation_fraction</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_no_change</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_iter_no_change</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span> <span class="arithmetic-assignment">=</span> <span class="identifier">tol</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">verbose</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>

    <span class="keyword">def</span> <span class="identifier">_validate_parameters</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Validate parameters passed to __init__.

        The parameters that are directly passed to the grower are checked in
        TreeGrower."""</span>

        <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">loss</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_VALID_LOSSES</span> <span class="logical-operator">and</span>
                <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">loss</span><span class="punctuation">,</span> <span class="identifier">BaseLoss</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">"Loss {} is not supported for {}. Accepted losses: "</span>
                <span class="string-literal">"{}."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">loss</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__class__</span><span class="punctuation">.</span><span class="identifier">__name__</span><span class="punctuation">,</span>
                             <span class="string-literal">', '</span><span class="punctuation">.</span><span class="identifier">join</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_VALID_LOSSES</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">learning_rate</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'learning_rate={} must '</span>
                             <span class="string-literal">'be strictly positive'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">learning_rate</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="relational-operator">&lt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'max_iter={} must not be smaller '</span>
                             <span class="string-literal">'than 1.'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_no_change</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'n_iter_no_change={} must be '</span>
                             <span class="string-literal">'positive.'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_no_change</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_fraction</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_fraction</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">'validation_fraction={} must be strictly '</span>
                <span class="string-literal">'positive, or None.'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_fraction</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'tol={} '</span>
                             <span class="string-literal">'must not be smaller than 0.'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="grouping">(</span><span class="int-literal">2</span> <span class="relational-operator">&lt;=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_bins</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">255</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'max_bins={} should be no smaller than 2 '</span>
                             <span class="string-literal">'and no larger than 255.'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_bins</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">monotonic_cst</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_trees_per_iteration_</span> <span class="relational-operator">!=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">'monotonic constraints are not supported for '</span>
                <span class="string-literal">'multiclass classification.'</span>
                <span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_check_categories</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Check and validate categorical features in X

        Return
        ------
        is_categorical : ndarray of shape (n_features,) or None, dtype=bool
            Indicates whether a feature is categorical. If no feature is
            categorical, this is None.
        known_categories : list of size n_features or None
            The list contains, for each feature:
                - an array of shape (n_categories,) with the unique cat values
                - None if the feature is not categorical
            None if no feature is categorical.
        """</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">categorical_features</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="none-literal">None</span><span class="punctuation">,</span> <span class="none-literal">None</span>

        <span class="identifier">categorical_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">categorical_features</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">categorical_features</span><span class="punctuation">.</span><span class="identifier">size</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="none-literal">None</span><span class="punctuation">,</span> <span class="none-literal">None</span>

        <span class="keyword">if</span> <span class="identifier">categorical_features</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">.</span><span class="identifier">kind</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="string-literal">'i', 'b'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"categorical_features must be an array-like of "</span>
                             <span class="string-literal">"bools or array-like of ints."</span><span class="grouping">)</span>

        <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>

        <span class="comment"># check for categorical features as indices</span>
        <span class="keyword">if</span> <span class="identifier">categorical_features</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">.</span><span class="identifier">kind</span> <span class="relational-operator">==</span> <span class="string-literal">'i'</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">max</span><span class="grouping">(</span><span class="identifier">categorical_features</span><span class="grouping">)</span> <span class="relational-operator">&gt;=</span> <span class="identifier">n_features</span>
                    <span class="logical-operator">or</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">min</span><span class="grouping">(</span><span class="identifier">categorical_features</span><span class="grouping">)</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"categorical_features set as integer "</span>
                                 <span class="string-literal">"indices must be in [0, n_features - 1]"</span><span class="grouping">)</span>
            <span class="identifier">is_categorical</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">n_features</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">bool</span><span class="grouping">)</span>
            <span class="identifier">is_categorical</span><span class="grouping">[</span><span class="identifier">categorical_features</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">categorical_features</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">!=</span> <span class="identifier">n_features</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"categorical_features set as a boolean mask "</span>
                                 <span class="string-literal">"must have shape (n_features,), got: "</span>
                                 <span class="identifier">f</span><span class="string-literal">"{categorical_features.shape}"</span><span class="grouping">)</span>
            <span class="identifier">is_categorical</span> <span class="arithmetic-assignment">=</span> <span class="identifier">categorical_features</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">any</span><span class="grouping">(</span><span class="identifier">is_categorical</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="none-literal">None</span><span class="punctuation">,</span> <span class="none-literal">None</span>

        <span class="comment"># compute the known categories in the training data. We need to do</span>
        <span class="comment"># that here instead of in the BinMapper because in case of early</span>
        <span class="comment"># stopping, the mapper only gets a fraction of the training data.</span>
        <span class="identifier">known_categories</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>

        <span class="keyword">for</span> <span class="identifier">f_idx</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">is_categorical</span><span class="grouping">[</span><span class="identifier">f_idx</span><span class="grouping">]</span><span class="punctuation">:</span>
                <span class="identifier">categories</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">unique</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">f_idx</span><span class="grouping">]</span><span class="grouping">)</span>
                <span class="identifier">missing</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">isnan</span><span class="grouping">(</span><span class="identifier">categories</span><span class="grouping">)</span>
                <span class="keyword">if</span> <span class="identifier">missing</span><span class="punctuation">.</span><span class="identifier">any</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">categories</span> <span class="arithmetic-assignment">=</span> <span class="identifier">categories</span><span class="grouping">[</span><span class="bitwise-operator">~</span><span class="identifier">missing</span><span class="grouping">]</span>

                <span class="keyword">if</span> <span class="identifier">categories</span><span class="punctuation">.</span><span class="identifier">size</span> <span class="relational-operator">&gt;</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_bins</span><span class="punctuation">:</span>
                    <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                        <span class="identifier">f</span><span class="string-literal">"Categorical feature at index {f_idx} is "</span>
                        <span class="identifier">f</span><span class="string-literal">"expected to have a "</span>
                        <span class="identifier">f</span><span class="string-literal">"cardinality &lt;= {self.max_bins}"</span>
                    <span class="grouping">)</span>

                <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">categories</span> <span class="relational-operator">&gt;=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_bins</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">any</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                        <span class="identifier">f</span><span class="string-literal">"Categorical feature at index {f_idx} is "</span>
                        <span class="identifier">f</span><span class="string-literal">"expected to be encoded with "</span>
                        <span class="identifier">f</span><span class="string-literal">"values &lt; {self.max_bins}"</span>
                    <span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">categories</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
            <span class="identifier">known_categories</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">categories</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">is_categorical</span><span class="punctuation">,</span> <span class="identifier">known_categories</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the gradient boosting model.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            The input samples.

        y : array-like of shape (n_samples,)
            Target values.

        sample_weight : array-like of shape (n_samples,) default=None
            Weights of training data.

            .. versionadded:: 0.23

        Returns
        -------
        self : object
        """</span>
        <span class="identifier">fit_start_time</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">acc_find_split_time</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>  <span class="comment"># time spent finding the best splits</span>
        <span class="identifier">acc_apply_split_time</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>  <span class="comment"># time spent splitting nodes</span>
        <span class="identifier">acc_compute_hist_time</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>  <span class="comment"># time spent computing histograms</span>
        <span class="comment"># time spent predicting X for gradient and hessians update</span>
        <span class="identifier">acc_prediction_time</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">X_DTYPE</span><span class="grouping">]</span><span class="punctuation">,</span>
                                   <span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">a</span><span class="invalid">l</span><span class="invalid">l</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_encode_y</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="identifier">check_consistent_length</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>
        <span class="comment"># Do not create unit sample weights by default to later skip some</span>
        <span class="comment"># computation</span>
        <span class="keyword">if</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_sample_weight</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span>
                                                 <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="grouping">)</span>
            <span class="comment"># TODO: remove when PDP suports sample weights</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_fitted_with_sw</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>

        <span class="identifier">rng</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span>

        <span class="comment"># When warm starting, we want to re-use the same seed that was used</span>
        <span class="comment"># the first time fit was called (e.g. for subsampling or for the</span>
        <span class="comment"># train/val split).</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">warm_start</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_is_fitted</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_random_seed</span> <span class="arithmetic-assignment">=</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">randint</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">iinfo</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">uint32</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">max</span><span class="punctuation">,</span>
                                            <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="string-literal">'u8'</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_parameters</span><span class="grouping">(</span><span class="grouping">)</span>

        <span class="comment"># used for validation in predict</span>
        <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">is_categorical_</span><span class="punctuation">,</span> <span class="identifier">known_categories</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_categories</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

        <span class="comment"># we need this stateful variable to tell raw_predict() that it was</span>
        <span class="comment"># called from fit() (this current method), and that the data it has</span>
        <span class="comment"># received is pre-binned.</span>
        <span class="comment"># predicting is faster on pre-binned data, so we want early stopping</span>
        <span class="comment"># predictions to be made on pre-binned data. Unfortunately the _scorer</span>
        <span class="comment"># can only call predict() or predict_proba(), not raw_predict(), and</span>
        <span class="comment"># there's no way to tell the scorer that it needs to predict binned</span>
        <span class="comment"># data.</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_in_fit</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>

        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">loss</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_loss</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_get_loss</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">loss</span><span class="punctuation">,</span> <span class="identifier">BaseLoss</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_loss</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">loss</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">early_stopping</span> <span class="relational-operator">==</span> <span class="string-literal">'auto'</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">do_early_stopping_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_samples</span> <span class="relational-operator">&gt;</span> <span class="int-literal">10000</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">do_early_stopping_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">early_stopping</span>

        <span class="comment"># create validation data if needed</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_use_validation_data</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_fraction</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">do_early_stopping_</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_use_validation_data</span><span class="punctuation">:</span>
            <span class="comment"># stratify for classification</span>
            <span class="identifier">stratify</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span> <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_loss</span><span class="punctuation">,</span> <span class="string-literal">'predict_proba'</span><span class="grouping">)</span> <span class="keyword">else</span> <span class="none-literal">None</span>

            <span class="comment"># Save the state of the RNG for the training and validation split.</span>
            <span class="comment"># This is needed in order to have the same split when using</span>
            <span class="comment"># warm starting.</span>

            <span class="keyword">if</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                <span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">X_val</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">y_val</span> <span class="arithmetic-assignment">=</span> <span class="identifier">train_test_split</span><span class="grouping">(</span>
                    <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">test_size</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_fraction</span><span class="punctuation">,</span>
                    <span class="identifier">stratify</span><span class="arithmetic-assignment">=</span><span class="identifier">stratify</span><span class="punctuation">,</span>
                    <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_random_seed</span><span class="grouping">)</span>
                <span class="identifier">sample_weight_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sample_weight_val</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="comment"># TODO: incorporate sample_weight in sampling here, as well as</span>
                <span class="comment"># stratify</span>
                <span class="grouping">(</span><span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">X_val</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">y_val</span><span class="punctuation">,</span> <span class="identifier">sample_weight_train</span><span class="punctuation">,</span>
                 <span class="identifier">sample_weight_val</span><span class="grouping">)</span> <span class="arithmetic-assignment">=</span> <span class="identifier">train_test_split</span><span class="grouping">(</span>
                    <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">test_size</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_fraction</span><span class="punctuation">,</span>
                    <span class="identifier">stratify</span><span class="arithmetic-assignment">=</span><span class="identifier">stratify</span><span class="punctuation">,</span>
                    <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_random_seed</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">sample_weight_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span>
            <span class="identifier">X_val</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y_val</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sample_weight_val</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>

        <span class="comment"># Bin the data</span>
        <span class="comment"># For ease of use of the API, the user-facing GBDT classes accept the</span>
        <span class="comment"># parameter max_bins, which doesn't take into account the bin for</span>
        <span class="comment"># missing values (which is always allocated). However, since max_bins</span>
        <span class="comment"># isn't the true maximal number of bins, all other private classes</span>
        <span class="comment"># (binmapper, histbuilder...) accept n_bins instead, which is the</span>
        <span class="comment"># actual total number of bins. Everywhere in the code, the</span>
        <span class="comment"># convention is that n_bins == max_bins + 1</span>
        <span class="identifier">n_bins</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_bins</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span>  <span class="comment"># + 1 for missing values</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_bin_mapper</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_BinMapper</span><span class="grouping">(</span>
            <span class="identifier">n_bins</span><span class="arithmetic-assignment">=</span><span class="identifier">n_bins</span><span class="punctuation">,</span>
            <span class="identifier">is_categorical</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">is_categorical_</span><span class="punctuation">,</span>
            <span class="identifier">known_categories</span><span class="arithmetic-assignment">=</span><span class="identifier">known_categories</span><span class="punctuation">,</span>
            <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_random_seed</span><span class="grouping">)</span>
        <span class="identifier">X_binned_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_bin_data</span><span class="grouping">(</span><span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">is_training_data</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">X_val</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">X_binned_val</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_bin_data</span><span class="grouping">(</span><span class="identifier">X_val</span><span class="punctuation">,</span> <span class="identifier">is_training_data</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">X_binned_val</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>

        <span class="comment"># Uses binned data to check for missing values</span>
        <span class="identifier">has_missing_values</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span>
            <span class="identifier">X_binned_train</span> <span class="relational-operator">==</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_bin_mapper</span><span class="punctuation">.</span><span class="identifier">missing_values_bin_idx_</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">any</span><span class="grouping">(</span>
                <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">uint8</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
            <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"Fitting gradient boosted rounds:"</span><span class="grouping">)</span>

        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_binned_train</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

        <span class="comment"># First time calling fit, or no warm start</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_is_fitted</span><span class="grouping">(</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">warm_start</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># Clear random state and score attributes</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_clear_state</span><span class="grouping">(</span><span class="grouping">)</span>

            <span class="comment"># initialize raw_predictions: those are the accumulated values</span>
            <span class="comment"># predicted by the trees for the training data. raw_predictions has</span>
            <span class="comment"># shape (n_trees_per_iteration, n_samples) where</span>
            <span class="comment"># n_trees_per_iterations is n_classes in multiclass classification,</span>
            <span class="comment"># else 1.</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_baseline_prediction</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_loss</span><span class="punctuation">.</span><span class="identifier">get_baseline_prediction</span><span class="grouping">(</span>
                <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">sample_weight_train</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_trees_per_iteration_</span>
            <span class="grouping">)</span>
            <span class="identifier">raw_predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span>
                <span class="identifier">shape</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_trees_per_iteration_</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="grouping">)</span><span class="punctuation">,</span>
                <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_baseline_prediction</span><span class="punctuation">.</span><span class="identifier">dtype</span>
            <span class="grouping">)</span>
            <span class="identifier">raw_predictions</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_baseline_prediction</span>

            <span class="comment"># predictors is a matrix (list of lists) of TreePredictor objects</span>
            <span class="comment"># with shape (n_iter_, n_trees_per_iteration)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_predictors</span> <span class="arithmetic-assignment">=</span> <span class="identifier">predictors</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>

            <span class="comment"># Initialize structures and attributes related to early stopping</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_scorer</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>  <span class="comment"># set if scoring != loss</span>
            <span class="identifier">raw_predictions_val</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>  <span class="comment"># set if scoring == loss and use val</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">train_score_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_score_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>

            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">do_early_stopping_</span><span class="punctuation">:</span>
                <span class="comment"># populate train_score and validation_score with the</span>
                <span class="comment"># predictions of the initial model (before the first tree)</span>

                <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span> <span class="relational-operator">==</span> <span class="string-literal">'loss'</span><span class="punctuation">:</span>
                    <span class="comment"># we're going to compute scoring w.r.t the loss. As losses</span>
                    <span class="comment"># take raw predictions as input (unlike the scorers), we</span>
                    <span class="comment"># can optimize a bit and avoid repeating computing the</span>
                    <span class="comment"># predictions of the previous trees. We'll re-use</span>
                    <span class="comment"># raw_predictions (as it's needed for training anyway) for</span>
                    <span class="comment"># evaluating the training loss, and create</span>
                    <span class="comment"># raw_predictions_val for storing the raw predictions of</span>
                    <span class="comment"># the validation data.</span>

                    <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_use_validation_data</span><span class="punctuation">:</span>
                        <span class="identifier">raw_predictions_val</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span>
                            <span class="identifier">shape</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_trees_per_iteration_</span><span class="punctuation">,</span>
                                   <span class="identifier">X_binned_val</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">,</span>
                            <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_baseline_prediction</span><span class="punctuation">.</span><span class="identifier">dtype</span>
                        <span class="grouping">)</span>

                        <span class="identifier">raw_predictions_val</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_baseline_prediction</span>

                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_early_stopping_loss</span><span class="grouping">(</span><span class="identifier">raw_predictions</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span>
                                                    <span class="identifier">sample_weight_train</span><span class="punctuation">,</span>
                                                    <span class="identifier">raw_predictions_val</span><span class="punctuation">,</span> <span class="identifier">y_val</span><span class="punctuation">,</span>
                                                    <span class="identifier">sample_weight_val</span><span class="grouping">)</span>
                <span class="keyword">else</span><span class="punctuation">:</span>
                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_scorer</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_scoring</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span><span class="grouping">)</span>
                    <span class="comment"># _scorer is a callable with signature (est, X, y) and</span>
                    <span class="comment"># calls est.predict() or est.predict_proba() depending on</span>
                    <span class="comment"># its nature.</span>
                    <span class="comment"># Unfortunately, each call to _scorer() will compute</span>
                    <span class="comment"># the predictions of all the trees. So we use a subset of</span>
                    <span class="comment"># the training set to compute train scores.</span>

                    <span class="comment"># Compute the subsample set</span>
                    <span class="grouping">(</span><span class="identifier">X_binned_small_train</span><span class="punctuation">,</span>
                     <span class="identifier">y_small_train</span><span class="punctuation">,</span>
                     <span class="identifier">sample_weight_small_train</span><span class="grouping">)</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_get_small_trainset</span><span class="grouping">(</span>
                        <span class="identifier">X_binned_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">sample_weight_train</span><span class="punctuation">,</span>
                        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_random_seed</span><span class="grouping">)</span>

                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_early_stopping_scorer</span><span class="grouping">(</span>
                        <span class="identifier">X_binned_small_train</span><span class="punctuation">,</span> <span class="identifier">y_small_train</span><span class="punctuation">,</span>
                        <span class="identifier">sample_weight_small_train</span><span class="punctuation">,</span>
                        <span class="identifier">X_binned_val</span><span class="punctuation">,</span> <span class="identifier">y_val</span><span class="punctuation">,</span> <span class="identifier">sample_weight_val</span><span class="punctuation">,</span>
                    <span class="grouping">)</span>
            <span class="identifier">begin_at_stage</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span>

        <span class="comment"># warm start: this is not the first time fit was called</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># Check that the maximum number of iterations is not smaller</span>
            <span class="comment"># than the number of iterations from the previous fit</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="relational-operator">&lt;</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                    <span class="string-literal">'max_iter=%d must be larger than or equal to '</span>
                    <span class="string-literal">'n_iter_=%d when warm_start==True'</span>
                    <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span><span class="grouping">)</span>
                <span class="grouping">)</span>

            <span class="comment"># Convert array attributes to lists</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">train_score_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">train_score_</span><span class="punctuation">.</span><span class="identifier">tolist</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_score_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_score_</span><span class="punctuation">.</span><span class="identifier">tolist</span><span class="grouping">(</span><span class="grouping">)</span>

            <span class="comment"># Compute raw predictions</span>
            <span class="identifier">raw_predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_raw_predict</span><span class="grouping">(</span><span class="identifier">X_binned_train</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">do_early_stopping_</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_use_validation_data</span><span class="punctuation">:</span>
                <span class="identifier">raw_predictions_val</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_raw_predict</span><span class="grouping">(</span><span class="identifier">X_binned_val</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">raw_predictions_val</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>

            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">do_early_stopping_</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span> <span class="relational-operator">!=</span> <span class="string-literal">'loss'</span><span class="punctuation">:</span>
                <span class="comment"># Compute the subsample set</span>
                <span class="grouping">(</span><span class="identifier">X_binned_small_train</span><span class="punctuation">,</span>
                 <span class="identifier">y_small_train</span><span class="punctuation">,</span>
                 <span class="identifier">sample_weight_small_train</span><span class="grouping">)</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_get_small_trainset</span><span class="grouping">(</span>
                    <span class="identifier">X_binned_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">sample_weight_train</span><span class="punctuation">,</span>
                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_random_seed</span><span class="grouping">)</span>

            <span class="comment"># Get the predictors from the previous fit</span>
            <span class="identifier">predictors</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_predictors</span>

            <span class="identifier">begin_at_stage</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span>

        <span class="comment"># initialize gradients and hessians (empty arrays).</span>
        <span class="comment"># shape = (n_trees_per_iteration, n_samples).</span>
        <span class="identifier">gradients</span><span class="punctuation">,</span> <span class="identifier">hessians</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_loss</span><span class="punctuation">.</span><span class="identifier">init_gradients_and_hessians</span><span class="grouping">(</span>
            <span class="identifier">n_samples</span><span class="arithmetic-assignment">=</span><span class="identifier">n_samples</span><span class="punctuation">,</span>
            <span class="identifier">prediction_dim</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_trees_per_iteration_</span><span class="punctuation">,</span>
            <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight_train</span>
        <span class="grouping">)</span>

        <span class="keyword">for</span> <span class="identifier">iteration</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">begin_at_stage</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="grouping">)</span><span class="punctuation">:</span>

            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
                <span class="identifier">iteration_start_time</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"[{}/{}] "</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">iteration</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="grouping">)</span><span class="punctuation">,</span>
                      <span class="identifier">end</span><span class="arithmetic-assignment">=</span><span class="string-literal">''</span><span class="punctuation">,</span> <span class="identifier">flush</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

            <span class="comment"># Update gradients and hessians, inplace</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_loss</span><span class="punctuation">.</span><span class="identifier">update_gradients_and_hessians</span><span class="grouping">(</span><span class="identifier">gradients</span><span class="punctuation">,</span> <span class="identifier">hessians</span><span class="punctuation">,</span>
                                                     <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">raw_predictions</span><span class="punctuation">,</span>
                                                     <span class="identifier">sample_weight_train</span><span class="grouping">)</span>

            <span class="comment"># Append a list since there may be more than 1 predictor per iter</span>
            <span class="identifier">predictors</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="grouping">[</span><span class="grouping">]</span><span class="grouping">)</span>

            <span class="comment"># Build `n_trees_per_iteration` trees.</span>
            <span class="keyword">for</span> <span class="identifier">k</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_trees_per_iteration_</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">grower</span> <span class="arithmetic-assignment">=</span> <span class="identifier">TreeGrower</span><span class="grouping">(</span>
                    <span class="identifier">X_binned_train</span><span class="punctuation">,</span> <span class="identifier">gradients</span><span class="grouping">[</span><span class="identifier">k</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">hessians</span><span class="grouping">[</span><span class="identifier">k</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span><span class="punctuation">,</span>
                    <span class="identifier">n_bins</span><span class="arithmetic-assignment">=</span><span class="identifier">n_bins</span><span class="punctuation">,</span>
                    <span class="identifier">n_bins_non_missing</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_bin_mapper</span><span class="punctuation">.</span><span class="identifier">n_bins_non_missing_</span><span class="punctuation">,</span>
                    <span class="identifier">has_missing_values</span><span class="arithmetic-assignment">=</span><span class="identifier">has_missing_values</span><span class="punctuation">,</span>
                    <span class="identifier">is_categorical</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">is_categorical_</span><span class="punctuation">,</span>
                    <span class="identifier">monotonic_cst</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">monotonic_cst</span><span class="punctuation">,</span>
                    <span class="identifier">max_leaf_nodes</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_leaf_nodes</span><span class="punctuation">,</span>
                    <span class="identifier">max_depth</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_depth</span><span class="punctuation">,</span>
                    <span class="identifier">min_samples_leaf</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">min_samples_leaf</span><span class="punctuation">,</span>
                    <span class="identifier">l2_regularization</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l2_regularization</span><span class="punctuation">,</span>
                    <span class="identifier">shrinkage</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">learning_rate</span><span class="grouping">)</span>
                <span class="identifier">grower</span><span class="punctuation">.</span><span class="identifier">grow</span><span class="grouping">(</span><span class="grouping">)</span>

                <span class="identifier">acc_apply_split_time</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">grower</span><span class="punctuation">.</span><span class="identifier">total_apply_split_time</span>
                <span class="identifier">acc_find_split_time</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">grower</span><span class="punctuation">.</span><span class="identifier">total_find_split_time</span>
                <span class="identifier">acc_compute_hist_time</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">grower</span><span class="punctuation">.</span><span class="identifier">total_compute_hist_time</span>

                <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_loss</span><span class="punctuation">.</span><span class="identifier">need_update_leaves_values</span><span class="punctuation">:</span>
                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_loss</span><span class="punctuation">.</span><span class="identifier">update_leaves_values</span><span class="grouping">(</span><span class="identifier">grower</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span>
                                                    <span class="identifier">raw_predictions</span><span class="grouping">[</span><span class="identifier">k</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span><span class="punctuation">,</span>
                                                    <span class="identifier">sample_weight_train</span><span class="grouping">)</span>

                <span class="identifier">predictor</span> <span class="arithmetic-assignment">=</span> <span class="identifier">grower</span><span class="punctuation">.</span><span class="identifier">make_predictor</span><span class="grouping">(</span>
                    <span class="identifier">binning_thresholds</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_bin_mapper</span><span class="punctuation">.</span><span class="identifier">bin_thresholds_</span>
                <span class="grouping">)</span>
                <span class="identifier">predictors</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">predictor</span><span class="grouping">)</span>

                <span class="comment"># Update raw_predictions with the predictions of the newly</span>
                <span class="comment"># created tree.</span>
                <span class="identifier">tic_pred</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
                <span class="identifier">_update_raw_predictions</span><span class="grouping">(</span><span class="identifier">raw_predictions</span><span class="grouping">[</span><span class="identifier">k</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">grower</span><span class="grouping">)</span>
                <span class="identifier">toc_pred</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
                <span class="identifier">acc_prediction_time</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">toc_pred</span> <span class="arithmetic-operator">-</span> <span class="identifier">tic_pred</span>

            <span class="identifier">should_early_stop</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">do_early_stopping_</span><span class="punctuation">:</span>
                <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span> <span class="relational-operator">==</span> <span class="string-literal">'loss'</span><span class="punctuation">:</span>
                    <span class="comment"># Update raw_predictions_val with the newest tree(s)</span>
                    <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_use_validation_data</span><span class="punctuation">:</span>
                        <span class="keyword">for</span> <span class="identifier">k</span><span class="punctuation">,</span> <span class="identifier">pred</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_predictors</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">:</span>
                            <span class="identifier">raw_predictions_val</span><span class="grouping">[</span><span class="identifier">k</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="grouping">(</span>
                                <span class="identifier">pred</span><span class="punctuation">.</span><span class="identifier">predict_binned</span><span class="grouping">(</span>
                                    <span class="identifier">X_binned_val</span><span class="punctuation">,</span>
                                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_bin_mapper</span><span class="punctuation">.</span><span class="identifier">missing_values_bin_idx_</span>
                                <span class="grouping">)</span>
                            <span class="grouping">)</span>

                    <span class="identifier">should_early_stop</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_early_stopping_loss</span><span class="grouping">(</span>
                        <span class="identifier">raw_predictions</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">sample_weight_train</span><span class="punctuation">,</span>
                        <span class="identifier">raw_predictions_val</span><span class="punctuation">,</span> <span class="identifier">y_val</span><span class="punctuation">,</span> <span class="identifier">sample_weight_val</span>
                    <span class="grouping">)</span>

                <span class="keyword">else</span><span class="punctuation">:</span>
                    <span class="identifier">should_early_stop</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_early_stopping_scorer</span><span class="grouping">(</span>
                        <span class="identifier">X_binned_small_train</span><span class="punctuation">,</span> <span class="identifier">y_small_train</span><span class="punctuation">,</span>
                        <span class="identifier">sample_weight_small_train</span><span class="punctuation">,</span>
                        <span class="identifier">X_binned_val</span><span class="punctuation">,</span> <span class="identifier">y_val</span><span class="punctuation">,</span> <span class="identifier">sample_weight_val</span>
                    <span class="grouping">)</span>

            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_print_iteration_stats</span><span class="grouping">(</span><span class="identifier">iteration_start_time</span><span class="grouping">)</span>

            <span class="comment"># maybe we could also early stop if all the trees are stumps?</span>
            <span class="keyword">if</span> <span class="identifier">should_early_stop</span><span class="punctuation">:</span>
                <span class="keyword">break</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
            <span class="identifier">duration</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">fit_start_time</span>
            <span class="identifier">n_total_leaves</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sum</span><span class="grouping">(</span>
                <span class="identifier">predictor</span><span class="punctuation">.</span><span class="identifier">get_n_leaf_nodes</span><span class="grouping">(</span><span class="grouping">)</span>
                <span class="keyword">for</span> <span class="identifier">predictors_at_ith_iteration</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_predictors</span>
                <span class="keyword">for</span> <span class="identifier">predictor</span> <span class="relational-operator">in</span> <span class="identifier">predictors_at_ith_iteration</span>
            <span class="grouping">)</span>
            <span class="identifier">n_predictors</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sum</span><span class="grouping">(</span>
                <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">predictors_at_ith_iteration</span><span class="grouping">)</span>
                <span class="keyword">for</span> <span class="identifier">predictors_at_ith_iteration</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_predictors</span><span class="grouping">)</span>
            <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"Fit {} trees in {:.3f} s, ({} total leaves)"</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span>
                <span class="identifier">n_predictors</span><span class="punctuation">,</span> <span class="identifier">duration</span><span class="punctuation">,</span> <span class="identifier">n_total_leaves</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"{:&lt;32} {:.3f}s"</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="string-literal">'Time spent computing histograms:'</span><span class="punctuation">,</span>
                                          <span class="identifier">acc_compute_hist_time</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"{:&lt;32} {:.3f}s"</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="string-literal">'Time spent finding best splits:'</span><span class="punctuation">,</span>
                                          <span class="identifier">acc_find_split_time</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"{:&lt;32} {:.3f}s"</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="string-literal">'Time spent applying splits:'</span><span class="punctuation">,</span>
                                          <span class="identifier">acc_apply_split_time</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"{:&lt;32} {:.3f}s"</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="string-literal">'Time spent predicting:'</span><span class="punctuation">,</span>
                                          <span class="identifier">acc_prediction_time</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">train_score_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">train_score_</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_score_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_score_</span><span class="grouping">)</span>
        <span class="keyword">del</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_in_fit</span>  <span class="comment"># hard delete so we're sure it can't be used anymore</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">'_predictors'</span><span class="punctuation">,</span> <span class="grouping">[</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span>

    <span class="keyword">def</span> <span class="identifier">_clear_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Clear the state of the gradient boosting model."""</span>
        <span class="keyword">for</span> <span class="identifier">var</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="string-literal">'train_score_', 'validation_score_'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">var</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">t</span><span class="invalid">r</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">var</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_get_small_trainset</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X_binned_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">sample_weight_train</span><span class="punctuation">,</span>
                            <span class="identifier">seed</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute the indices of the subsample set and return this set.

        For efficiency, we need to subsample the training set to compute scores
        with scorers.
        """</span>
        <span class="comment"># TODO: incorporate sample_weights here in `resample`</span>
        <span class="identifier">subsample_size</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">10000</span>
        <span class="keyword">if</span> <span class="identifier">X_binned_train</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">&gt;</span> <span class="identifier">subsample_size</span><span class="punctuation">:</span>
            <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">arange</span><span class="grouping">(</span><span class="identifier">X_binned_train</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="identifier">stratify</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y_train</span> <span class="keyword">if</span> <span class="identifier">is_classifier</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span> <span class="keyword">else</span> <span class="none-literal">None</span>
            <span class="identifier">indices</span> <span class="arithmetic-assignment">=</span> <span class="identifier">resample</span><span class="grouping">(</span><span class="identifier">indices</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="arithmetic-assignment">=</span><span class="identifier">subsample_size</span><span class="punctuation">,</span>
                               <span class="identifier">replace</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">seed</span><span class="punctuation">,</span>
                               <span class="identifier">stratify</span><span class="arithmetic-assignment">=</span><span class="identifier">stratify</span><span class="grouping">)</span>
            <span class="identifier">X_binned_small_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_binned_train</span><span class="grouping">[</span><span class="identifier">indices</span><span class="grouping">]</span>
            <span class="identifier">y_small_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y_train</span><span class="grouping">[</span><span class="identifier">indices</span><span class="grouping">]</span>
            <span class="keyword">if</span> <span class="identifier">sample_weight_train</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                <span class="identifier">sample_weight_small_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sample_weight_train</span><span class="grouping">[</span><span class="identifier">indices</span><span class="grouping">]</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">sample_weight_small_train</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
            <span class="identifier">X_binned_small_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">i</span><span class="invalid">g</span><span class="invalid">u</span><span class="invalid">o</span><span class="invalid">u</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">X_binned_small_train</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="grouping">(</span><span class="identifier">X_binned_small_train</span><span class="punctuation">,</span> <span class="identifier">y_small_train</span><span class="punctuation">,</span>
                    <span class="identifier">sample_weight_small_train</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">X_binned_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">sample_weight_train</span>

    <span class="keyword">def</span> <span class="identifier">_check_early_stopping_scorer</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X_binned_small_train</span><span class="punctuation">,</span> <span class="identifier">y_small_train</span><span class="punctuation">,</span>
                                     <span class="identifier">sample_weight_small_train</span><span class="punctuation">,</span>
                                     <span class="identifier">X_binned_val</span><span class="punctuation">,</span> <span class="identifier">y_val</span><span class="punctuation">,</span> <span class="identifier">sample_weight_val</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Check if fitting should be early-stopped based on scorer.

        Scores are computed on validation data or on training data.
        """</span>
        <span class="keyword">if</span> <span class="identifier">is_classifier</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">y_small_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="identifier">y_small_train</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">int</span><span class="grouping">)</span><span class="grouping">]</span>

        <span class="keyword">if</span> <span class="identifier">sample_weight_small_train</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">train_score_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_scorer</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X_binned_small_train</span><span class="punctuation">,</span> <span class="identifier">y_small_train</span><span class="grouping">)</span>
            <span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">train_score_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_scorer</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X_binned_small_train</span><span class="punctuation">,</span> <span class="identifier">y_small_train</span><span class="punctuation">,</span>
                             <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight_small_train</span><span class="grouping">)</span>
            <span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_use_validation_data</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">is_classifier</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">y_val</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="identifier">y_val</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">int</span><span class="grouping">)</span><span class="grouping">]</span>
            <span class="keyword">if</span> <span class="identifier">sample_weight_val</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_score_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span>
                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_scorer</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X_binned_val</span><span class="punctuation">,</span> <span class="identifier">y_val</span><span class="grouping">)</span>
                <span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_score_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span>
                    <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_scorer</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X_binned_val</span><span class="punctuation">,</span> <span class="identifier">y_val</span><span class="punctuation">,</span>
                                 <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight_val</span><span class="grouping">)</span>
                <span class="grouping">)</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_should_stop</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_score_</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_should_stop</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">train_score_</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_check_early_stopping_loss</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span>
                                   <span class="identifier">raw_predictions</span><span class="punctuation">,</span>
                                   <span class="identifier">y_train</span><span class="punctuation">,</span>
                                   <span class="identifier">sample_weight_train</span><span class="punctuation">,</span>
                                   <span class="identifier">raw_predictions_val</span><span class="punctuation">,</span>
                                   <span class="identifier">y_val</span><span class="punctuation">,</span>
                                   <span class="identifier">sample_weight_val</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Check if fitting should be early-stopped based on loss.

        Scores are computed on validation data or on training data.
        """</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">train_score_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span>
            <span class="arithmetic-operator">-</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_loss</span><span class="grouping">(</span><span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">raw_predictions</span><span class="punctuation">,</span> <span class="identifier">sample_weight_train</span><span class="grouping">)</span>
        <span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_use_validation_data</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_score_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span>
                <span class="arithmetic-operator">-</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_loss</span><span class="grouping">(</span><span class="identifier">y_val</span><span class="punctuation">,</span> <span class="identifier">raw_predictions_val</span><span class="punctuation">,</span> <span class="identifier">sample_weight_val</span><span class="grouping">)</span>
            <span class="grouping">)</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_should_stop</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_score_</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_should_stop</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">train_score_</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_should_stop</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">scores</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""
        Return True (do early stopping) if the last n scores aren't better
        than the (n-1)th-to-last score, up to some tolerance.
        """</span>
        <span class="identifier">reference_position</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_no_change</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span>
        <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">scores</span><span class="grouping">)</span> <span class="relational-operator">&lt;</span> <span class="identifier">reference_position</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="bool-literal">False</span>

        <span class="comment"># A higher score is always better. Higher tol means that it will be</span>
        <span class="comment"># harder for subsequent iteration to be considered an improvement upon</span>
        <span class="comment"># the reference score, and therefore it is more likely to early stop</span>
        <span class="comment"># because of the lack of significant improvement.</span>
        <span class="identifier">reference_score</span> <span class="arithmetic-assignment">=</span> <span class="identifier">scores</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="identifier">reference_position</span><span class="grouping">]</span> <span class="arithmetic-operator">+</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span>
        <span class="identifier">recent_scores</span> <span class="arithmetic-assignment">=</span> <span class="identifier">scores</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="identifier">reference_position</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">:</span><span class="grouping">]</span>
        <span class="identifier">recent_improvements</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">score</span> <span class="relational-operator">&gt;</span> <span class="identifier">reference_score</span>
                               <span class="keyword">for</span> <span class="identifier">score</span> <span class="relational-operator">in</span> <span class="identifier">recent_scores</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="logical-operator">not</span> <span class="identifier">any</span><span class="grouping">(</span><span class="identifier">recent_improvements</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_bin_data</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">is_training_data</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Bin data X.

        If is_training_data, then fit the _bin_mapper attribute.
        Else, the binned data is converted to a C-contiguous array.
        """</span>

        <span class="identifier">description</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'training' if is_training_data else 'validation'</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
            <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"Binning {:.3f} GB of {} data: "</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">nbytes</span> <span class="arithmetic-operator">/</span> <span class="float-literal">1e9</span><span class="punctuation">,</span> <span class="identifier">description</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">end</span><span class="arithmetic-assignment">=</span><span class="string-literal">""</span><span class="punctuation">,</span> <span class="identifier">flush</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">tic</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">is_training_data</span><span class="punctuation">:</span>
            <span class="identifier">X_binned</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_bin_mapper</span><span class="punctuation">.</span><span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>  <span class="comment"># F-aligned array</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">X_binned</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_bin_mapper</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>  <span class="comment"># F-aligned array</span>
            <span class="comment"># We convert the array to C-contiguous since predicting is faster</span>
            <span class="comment"># with this layout (training is faster on F-arrays though)</span>
            <span class="identifier">X_binned</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">i</span><span class="invalid">g</span><span class="invalid">u</span><span class="invalid">o</span><span class="invalid">u</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">X_binned</span><span class="grouping">)</span>
        <span class="identifier">toc</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">:</span>
            <span class="identifier">duration</span> <span class="arithmetic-assignment">=</span> <span class="identifier">toc</span> <span class="arithmetic-operator">-</span> <span class="identifier">tic</span>
            <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"{:.3f} s"</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">duration</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">X_binned</span>

    <span class="keyword">def</span> <span class="identifier">_print_iteration_stats</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">iteration_start_time</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Print info about the current fitting iteration."""</span>
        <span class="identifier">log_msg</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">''</span>

        <span class="identifier">predictors_of_ith_iteration</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span>
            <span class="identifier">predictors_list</span> <span class="keyword">for</span> <span class="identifier">predictors_list</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_predictors</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span>
            <span class="keyword">if</span> <span class="identifier">predictors_list</span>
        <span class="grouping">]</span>
        <span class="identifier">n_trees</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">predictors_of_ith_iteration</span><span class="grouping">)</span>
        <span class="identifier">max_depth</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max</span><span class="grouping">(</span><span class="identifier">predictor</span><span class="punctuation">.</span><span class="identifier">get_max_depth</span><span class="grouping">(</span><span class="grouping">)</span>
                        <span class="keyword">for</span> <span class="identifier">predictor</span> <span class="relational-operator">in</span> <span class="identifier">predictors_of_ith_iteration</span><span class="grouping">)</span>
        <span class="identifier">n_leaves</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">predictor</span><span class="punctuation">.</span><span class="identifier">get_n_leaf_nodes</span><span class="grouping">(</span><span class="grouping">)</span>
                       <span class="keyword">for</span> <span class="identifier">predictor</span> <span class="relational-operator">in</span> <span class="identifier">predictors_of_ith_iteration</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">n_trees</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">log_msg</span> <span class="arithmetic-assignment">+=</span> <span class="grouping">(</span><span class="string-literal">"{} tree, {} leaves, "</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">n_trees</span><span class="punctuation">,</span> <span class="identifier">n_leaves</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">log_msg</span> <span class="arithmetic-assignment">+=</span> <span class="grouping">(</span><span class="string-literal">"{} trees, {} leaves "</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">n_trees</span><span class="punctuation">,</span> <span class="identifier">n_leaves</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">log_msg</span> <span class="arithmetic-assignment">+=</span> <span class="grouping">(</span><span class="string-literal">"({} on avg), "</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">int</span><span class="grouping">(</span><span class="identifier">n_leaves</span> <span class="arithmetic-operator">/</span> <span class="identifier">n_trees</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">log_msg</span> <span class="arithmetic-assignment">+=</span> <span class="string-literal">"max depth = {}, "</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">max_depth</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">do_early_stopping_</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span> <span class="relational-operator">==</span> <span class="string-literal">'loss'</span><span class="punctuation">:</span>
                <span class="identifier">factor</span> <span class="arithmetic-assignment">=</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span>  <span class="comment"># score_ arrays contain the negative loss</span>
                <span class="identifier">name</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'loss'</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">factor</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>
                <span class="identifier">name</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'score'</span>
            <span class="identifier">log_msg</span> <span class="arithmetic-assignment">+=</span> <span class="string-literal">"train {}: {:.5f}, "</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">factor</span> <span class="arithmetic-operator">*</span>
                                                   <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">train_score_</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_use_validation_data</span><span class="punctuation">:</span>
                <span class="identifier">log_msg</span> <span class="arithmetic-assignment">+=</span> <span class="string-literal">"val {}: {:.5f}, "</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span>
                    <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">factor</span> <span class="arithmetic-operator">*</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">validation_score_</span><span class="grouping">[</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="identifier">iteration_time</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span> <span class="arithmetic-operator">-</span> <span class="identifier">iteration_start_time</span>
        <span class="identifier">log_msg</span> <span class="arithmetic-assignment">+=</span> <span class="string-literal">"in {:0.3f}s"</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">iteration_time</span><span class="grouping">)</span>

        <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">log_msg</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_raw_predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Return the sum of the leaves values over all predictors.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            The input samples.

        Returns
        -------
        raw_predictions : array, shape (n_trees_per_iteration, n_samples)
            The raw predicted values.
        """</span>
        <span class="identifier">is_binned</span> <span class="arithmetic-assignment">=</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">'_in_fit'</span><span class="punctuation">,</span> <span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">dtype</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_BINNED_DTYPE</span> <span class="keyword">if</span> <span class="identifier">is_binned</span> <span class="keyword">else</span> <span class="identifier">X_DTYPE</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">dtype</span><span class="punctuation">,</span> <span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">a</span><span class="invalid">l</span><span class="invalid">l</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                                <span class="identifier">reset</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="relational-operator">!=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_features</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">'X has {} features but this estimator was trained with '</span>
                <span class="string-literal">'{} features.'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_features</span><span class="grouping">)</span>
            <span class="grouping">)</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">raw_predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span>
            <span class="identifier">shape</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_trees_per_iteration_</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="grouping">)</span><span class="punctuation">,</span>
            <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_baseline_prediction</span><span class="punctuation">.</span><span class="identifier">dtype</span>
        <span class="grouping">)</span>
        <span class="identifier">raw_predictions</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_baseline_prediction</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_predict_iterations</span><span class="grouping">(</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_predictors</span><span class="punctuation">,</span> <span class="identifier">raw_predictions</span><span class="punctuation">,</span> <span class="identifier">is_binned</span>
        <span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">raw_predictions</span>

    <span class="keyword">def</span> <span class="identifier">_predict_iterations</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">predictors</span><span class="punctuation">,</span> <span class="identifier">raw_predictions</span><span class="punctuation">,</span> <span class="identifier">is_binned</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Add the predictions of the predictors to raw_predictions."""</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">is_binned</span><span class="punctuation">:</span>
            <span class="identifier">known_cat_bitsets</span><span class="punctuation">,</span> <span class="identifier">f_idx_map</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_bin_mapper</span><span class="punctuation">.</span><span class="identifier">make_known_categories_bitsets</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">for</span> <span class="identifier">predictors_of_ith_iteration</span> <span class="relational-operator">in</span> <span class="identifier">predictors</span><span class="punctuation">:</span>
            <span class="keyword">for</span> <span class="identifier">k</span><span class="punctuation">,</span> <span class="identifier">predictor</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">predictors_of_ith_iteration</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">if</span> <span class="identifier">is_binned</span><span class="punctuation">:</span>
                    <span class="identifier">predict</span> <span class="arithmetic-assignment">=</span> <span class="identifier">partial</span><span class="grouping">(</span>
                        <span class="identifier">predictor</span><span class="punctuation">.</span><span class="identifier">predict_binned</span><span class="punctuation">,</span>
                        <span class="identifier">missing_values_bin_idx</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_bin_mapper</span><span class="punctuation">.</span><span class="identifier">missing_values_bin_idx_</span>  <span class="comment"># noqa</span>
                    <span class="grouping">)</span>
                <span class="keyword">else</span><span class="punctuation">:</span>
                    <span class="identifier">predict</span> <span class="arithmetic-assignment">=</span> <span class="identifier">partial</span><span class="grouping">(</span>
                        <span class="identifier">predictor</span><span class="punctuation">.</span><span class="identifier">predict</span><span class="punctuation">,</span>
                        <span class="identifier">known_cat_bitsets</span><span class="arithmetic-assignment">=</span><span class="identifier">known_cat_bitsets</span><span class="punctuation">,</span>
                        <span class="identifier">f_idx_map</span><span class="arithmetic-assignment">=</span><span class="identifier">f_idx_map</span><span class="grouping">)</span>
                <span class="identifier">raw_predictions</span><span class="grouping">[</span><span class="identifier">k</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_staged_raw_predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute raw predictions of ``X`` for each iteration.

        This method allows monitoring (i.e. determine error on testing set)
        after each stage.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            The input samples.

        Yields
        -------
        raw_predictions : generator of ndarray of shape \
            (n_trees_per_iteration, n_samples)
            The raw predictions of the input samples. The order of the
            classes corresponds to that in the attribute :term:`classes_`.
        """</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X_DTYPE</span><span class="punctuation">,</span> <span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">a</span><span class="invalid">l</span><span class="invalid">l</span><span class="invalid">_</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                                <span class="identifier">reset</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="relational-operator">!=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_features</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span>
                <span class="string-literal">'X has {} features but this estimator was trained with '</span>
                <span class="string-literal">'{} features.'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_n_features</span><span class="grouping">)</span>
            <span class="grouping">)</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="identifier">raw_predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span>
            <span class="identifier">shape</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_trees_per_iteration_</span><span class="punctuation">,</span> <span class="identifier">n_samples</span><span class="grouping">)</span><span class="punctuation">,</span>
            <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_baseline_prediction</span><span class="punctuation">.</span><span class="identifier">dtype</span>
        <span class="grouping">)</span>
        <span class="identifier">raw_predictions</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_baseline_prediction</span>
        <span class="keyword">for</span> <span class="identifier">iteration</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_predictors</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_predict_iterations</span><span class="grouping">(</span>
                <span class="identifier">X</span><span class="punctuation">,</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_predictors</span><span class="grouping">[</span><span class="identifier">iteration</span><span class="punctuation">:</span><span class="identifier">iteration</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span>
                <span class="identifier">raw_predictions</span><span class="punctuation">,</span>
                <span class="identifier">is_binned</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span>
            <span class="grouping">)</span>
            <span class="keyword">yield</span> <span class="identifier">raw_predictions</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_compute_partial_dependence_recursion</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">grid</span><span class="punctuation">,</span> <span class="identifier">target_features</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fast partial dependence computation.

        Parameters
        ----------
        grid : ndarray, shape (n_samples, n_target_features)
            The grid points on which the partial dependence should be
            evaluated.
        target_features : ndarray, shape (n_target_features)
            The set of target features for which the partial dependence
            should be evaluated.

        Returns
        -------
        averaged_predictions : ndarray, shape \
                (n_trees_per_iteration, n_samples)
            The value of the partial dependence function on each grid point.
        """</span>

        <span class="keyword">if</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">'_fitted_with_sw'</span><span class="punctuation">,</span> <span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">NotImplementedError</span><span class="grouping">(</span><span class="string-literal">"{} does not support partial dependence "</span>
                                      <span class="string-literal">"plots with the 'recursion' method when "</span>
                                      <span class="string-literal">"sample weights were given during fit "</span>
                                      <span class="string-literal">"time."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__class__</span><span class="punctuation">.</span><span class="identifier">__name__</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">grid</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">grid</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X_DTYPE</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'C'</span><span class="grouping">)</span>
        <span class="identifier">averaged_predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span>
            <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_trees_per_iteration_</span><span class="punctuation">,</span> <span class="identifier">grid</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">Y_DTYPE</span><span class="grouping">)</span>

        <span class="keyword">for</span> <span class="identifier">predictors_of_ith_iteration</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_predictors</span><span class="punctuation">:</span>
            <span class="keyword">for</span> <span class="identifier">k</span><span class="punctuation">,</span> <span class="identifier">predictor</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">predictors_of_ith_iteration</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">predictor</span><span class="punctuation">.</span><span class="identifier">compute_partial_dependence</span><span class="grouping">(</span><span class="identifier">grid</span><span class="punctuation">,</span> <span class="identifier">target_features</span><span class="punctuation">,</span>
                                                     <span class="identifier">averaged_predictions</span><span class="grouping">[</span><span class="identifier">k</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="comment"># Note that the learning rate is already accounted for in the leaves</span>
        <span class="comment"># values.</span>

        <span class="keyword">return</span> <span class="identifier">averaged_predictions</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'allow_nan'</span><span class="punctuation">:</span> <span class="bool-literal">True</span><span class="grouping">}</span>

    <span class="punctuation">@</span><span class="identifier">abstractmethod</span>
    <span class="keyword">def</span> <span class="identifier">_get_loss</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">pass</span>

    <span class="punctuation">@</span><span class="identifier">abstractmethod</span>
    <span class="keyword">def</span> <span class="identifier">_encode_y</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">pass</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">n_iter_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_predictors</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">HistGradientBoostingRegressor</span><span class="grouping">(</span><span class="identifier">RegressorMixin</span><span class="punctuation">,</span> <span class="identifier">BaseHistGradientBoosting</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Histogram-based Gradient Boosting Regression Tree.

    This estimator is much faster than
    :class:`GradientBoostingRegressor&lt;sklearn.ensemble.GradientBoostingRegressor&gt;`
    for big datasets (n_samples &gt;= 10 000).

    This estimator has native support for missing values (NaNs). During
    training, the tree grower learns at each split point whether samples
    with missing values should go to the left or right child, based on the
    potential gain. When predicting, samples with missing values are
    assigned to the left or right child consequently. If no missing values
    were encountered for a given feature during training, then samples with
    missing values are mapped to whichever child has the most samples.

    This implementation is inspired by
    `LightGBM &lt;https://github.com/Microsoft/LightGBM&gt;`_.

    Read more in the :ref:`User Guide &lt;histogram_based_gradient_boosting&gt;`.

    .. versionadded:: 0.21

    Parameters
    ----------
    loss : {'squared_error', 'least_squares', 'absolute_error', \
            'least_absolute_deviation', 'poisson'}, default='squared_error'
        The loss function to use in the boosting process. Note that the
        "least squares" and "poisson" losses actually implement
        "half least squares loss" and "half poisson deviance" to simplify the
        computation of the gradient. Furthermore, "poisson" loss internally
        uses a log-link and requires ``y &gt;= 0``

        .. versionchanged:: 0.23
           Added option 'poisson'.

        .. deprecated:: 1.0
            The loss 'least_squares' was deprecated in v1.0 and will be removed
            in version 1.2. Use `loss='squared_error'` which is equivalent.

        .. deprecated:: 1.0
            The loss 'least_absolute_deviation' was deprecated in v1.0 and will
            be removed in version 1.2. Use `loss='absolute_error'` which is
            equivalent.

    learning_rate : float, default=0.1
        The learning rate, also known as *shrinkage*. This is used as a
        multiplicative factor for the leaves values. Use ``1`` for no
        shrinkage.
    max_iter : int, default=100
        The maximum number of iterations of the boosting process, i.e. the
        maximum number of trees.
    max_leaf_nodes : int or None, default=31
        The maximum number of leaves for each tree. Must be strictly greater
        than 1. If None, there is no maximum limit.
    max_depth : int or None, default=None
        The maximum depth of each tree. The depth of a tree is the number of
        edges to go from the root to the deepest leaf.
        Depth isn't constrained by default.
    min_samples_leaf : int, default=20
        The minimum number of samples per leaf. For small datasets with less
        than a few hundred samples, it is recommended to lower this value
        since only very shallow trees would be built.
    l2_regularization : float, default=0
        The L2 regularization parameter. Use ``0`` for no regularization
        (default).
    max_bins : int, default=255
        The maximum number of bins to use for non-missing values. Before
        training, each feature of the input array `X` is binned into
        integer-valued bins, which allows for a much faster training stage.
        Features with a small number of unique values may use less than
        ``max_bins`` bins. In addition to the ``max_bins`` bins, one more bin
        is always reserved for missing values. Must be no larger than 255.
    categorical_features : array-like of {bool, int} of shape (n_features) \
            or shape (n_categorical_features,), default=None.
        Indicates the categorical features.

        - None : no feature will be considered categorical.
        - boolean array-like : boolean mask indicating categorical features.
        - integer array-like : integer indices indicating categorical
          features.

        For each categorical feature, there must be at most `max_bins` unique
        categories, and each categorical value must be in [0, max_bins -1].

        Read more in the :ref:`User Guide &lt;categorical_support_gbdt&gt;`.

        .. versionadded:: 0.24

    monotonic_cst : array-like of int of shape (n_features), default=None
        Indicates the monotonic constraint to enforce on each feature. -1, 1
        and 0 respectively correspond to a negative constraint, positive
        constraint and no constraint. Read more in the :ref:`User Guide
        &lt;monotonic_cst_gbdt&gt;`.

        .. versionadded:: 0.23

    warm_start : bool, default=False
        When set to ``True``, reuse the solution of the previous call to fit
        and add more estimators to the ensemble. For results to be valid, the
        estimator should be re-trained on the same data only.
        See :term:`the Glossary &lt;warm_start&gt;`.
    early_stopping : 'auto' or bool, default='auto'
        If 'auto', early stopping is enabled if the sample size is larger than
        10000. If True, early stopping is enabled, otherwise early stopping is
        disabled.

        .. versionadded:: 0.23

    scoring : str or callable or None, default='loss'
        Scoring parameter to use for early stopping. It can be a single
        string (see :ref:`scoring_parameter`) or a callable (see
        :ref:`scoring`). If None, the estimator's default scorer is used. If
        ``scoring='loss'``, early stopping is checked w.r.t the loss value.
        Only used if early stopping is performed.
    validation_fraction : int or float or None, default=0.1
        Proportion (or absolute size) of training data to set aside as
        validation data for early stopping. If None, early stopping is done on
        the training data. Only used if early stopping is performed.
    n_iter_no_change : int, default=10
        Used to determine when to "early stop". The fitting process is
        stopped when none of the last ``n_iter_no_change`` scores are better
        than the ``n_iter_no_change - 1`` -th-to-last one, up to some
        tolerance. Only used if early stopping is performed.
    tol : float, default=1e-7
        The absolute tolerance to use when comparing scores during early
        stopping. The higher the tolerance, the more likely we are to early
        stop: higher tolerance means that it will be harder for subsequent
        iterations to be considered an improvement upon the reference score.
    verbose : int, default=0
        The verbosity level. If not zero, print some information about the
        fitting process.
    random_state : int, RandomState instance or None, default=None
        Pseudo-random number generator to control the subsampling in the
        binning process, and the train/validation data split if early stopping
        is enabled.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    Attributes
    ----------
    do_early_stopping_ : bool
        Indicates whether early stopping is used during training.
    n_iter_ : int
        The number of iterations as selected by early stopping, depending on
        the `early_stopping` parameter. Otherwise it corresponds to max_iter.
    n_trees_per_iteration_ : int
        The number of tree that are built at each iteration. For regressors,
        this is always 1.
    train_score_ : ndarray, shape (n_iter_+1,)
        The scores at each iteration on the training data. The first entry
        is the score of the ensemble before the first iteration. Scores are
        computed according to the ``scoring`` parameter. If ``scoring`` is
        not 'loss', scores are computed on a subset of at most 10 000
        samples. Empty if no early stopping.
    validation_score_ : ndarray, shape (n_iter_+1,)
        The scores at each iteration on the held-out validation data. The
        first entry is the score of the ensemble before the first iteration.
        Scores are computed according to the ``scoring`` parameter. Empty if
        no early stopping or if ``validation_fraction`` is None.
    is_categorical_ : ndarray, shape (n_features, ) or None
        Boolean mask for the categorical features. ``None`` if there are no
        categorical features.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.ensemble import HistGradientBoostingRegressor
    &gt;&gt;&gt; from sklearn.datasets import load_diabetes
    &gt;&gt;&gt; X, y = load_diabetes(return_X_y=True)
    &gt;&gt;&gt; est = HistGradientBoostingRegressor().fit(X, y)
    &gt;&gt;&gt; est.score(X, y)
    0.92...
    """</span>

    <span class="identifier">_VALID_LOSSES</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="string-literal">'squared_error', 'least_squares', 'absolute_error'</span><span class="punctuation">,</span>
                     <span class="string-literal">'least_absolute_deviation', 'poisson'</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">loss</span><span class="arithmetic-assignment">=</span><span class="string-literal">'squared_error'</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">learning_rate</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.1</span><span class="punctuation">,</span>
                 <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">100</span><span class="punctuation">,</span> <span class="identifier">max_leaf_nodes</span><span class="arithmetic-assignment">=</span><span class="int-literal">31</span><span class="punctuation">,</span> <span class="identifier">max_depth</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">min_samples_leaf</span><span class="arithmetic-assignment">=</span><span class="int-literal">20</span><span class="punctuation">,</span> <span class="identifier">l2_regularization</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">.</span><span class="punctuation">,</span> <span class="identifier">max_bins</span><span class="arithmetic-assignment">=</span><span class="int-literal">255</span><span class="punctuation">,</span>
                 <span class="identifier">categorical_features</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">monotonic_cst</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">warm_start</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">early_stopping</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span>
                 <span class="identifier">scoring</span><span class="arithmetic-assignment">=</span><span class="string-literal">'loss'</span><span class="punctuation">,</span> <span class="identifier">validation_fraction</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.1</span><span class="punctuation">,</span>
                 <span class="identifier">n_iter_no_change</span><span class="arithmetic-assignment">=</span><span class="int-literal">10</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-7</span><span class="punctuation">,</span>
                 <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="identifier">HistGradientBoostingRegressor</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">loss</span><span class="arithmetic-assignment">=</span><span class="identifier">loss</span><span class="punctuation">,</span> <span class="identifier">learning_rate</span><span class="arithmetic-assignment">=</span><span class="identifier">learning_rate</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
            <span class="identifier">max_leaf_nodes</span><span class="arithmetic-assignment">=</span><span class="identifier">max_leaf_nodes</span><span class="punctuation">,</span> <span class="identifier">max_depth</span><span class="arithmetic-assignment">=</span><span class="identifier">max_depth</span><span class="punctuation">,</span>
            <span class="identifier">min_samples_leaf</span><span class="arithmetic-assignment">=</span><span class="identifier">min_samples_leaf</span><span class="punctuation">,</span>
            <span class="identifier">l2_regularization</span><span class="arithmetic-assignment">=</span><span class="identifier">l2_regularization</span><span class="punctuation">,</span> <span class="identifier">max_bins</span><span class="arithmetic-assignment">=</span><span class="identifier">max_bins</span><span class="punctuation">,</span>
            <span class="identifier">monotonic_cst</span><span class="arithmetic-assignment">=</span><span class="identifier">monotonic_cst</span><span class="punctuation">,</span>
            <span class="identifier">categorical_features</span><span class="arithmetic-assignment">=</span><span class="identifier">categorical_features</span><span class="punctuation">,</span>
            <span class="identifier">early_stopping</span><span class="arithmetic-assignment">=</span><span class="identifier">early_stopping</span><span class="punctuation">,</span>
            <span class="identifier">warm_start</span><span class="arithmetic-assignment">=</span><span class="identifier">warm_start</span><span class="punctuation">,</span> <span class="identifier">scoring</span><span class="arithmetic-assignment">=</span><span class="identifier">scoring</span><span class="punctuation">,</span>
            <span class="identifier">validation_fraction</span><span class="arithmetic-assignment">=</span><span class="identifier">validation_fraction</span><span class="punctuation">,</span>
            <span class="identifier">n_iter_no_change</span><span class="arithmetic-assignment">=</span><span class="identifier">n_iter_no_change</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="punctuation">,</span>
            <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Predict values for X.

        Parameters
        ----------
        X : array-like, shape (n_samples, n_features)
            The input samples.

        Returns
        -------
        y : ndarray, shape (n_samples,)
            The predicted values.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="comment"># Return inverse link of raw predictions after converting</span>
        <span class="comment"># shape (n_samples, 1) to (n_samples,)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_loss</span><span class="punctuation">.</span><span class="identifier">inverse_link_function</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_raw_predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">staged_predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Predict regression target for each iteration

        This method allows monitoring (i.e. determine error on testing set)
        after each stage.

        .. versionadded:: 0.24

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            The input samples.

        Yields
        -------
        y : generator of ndarray of shape (n_samples,)
            The predicted values of the input samples, for each iteration.
        """</span>
        <span class="keyword">for</span> <span class="identifier">raw_predictions</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_staged_raw_predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">yield</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_loss</span><span class="punctuation">.</span><span class="identifier">inverse_link_function</span><span class="grouping">(</span><span class="identifier">raw_predictions</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_encode_y</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># Just convert y to the expected dtype</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_trees_per_iteration_</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">Y_DTYPE</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">loss</span> <span class="relational-operator">==</span> <span class="string-literal">'poisson'</span><span class="punctuation">:</span>
            <span class="comment"># Ensure y &gt;= 0 and sum(y) &gt; 0</span>
            <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">all</span><span class="grouping">(</span><span class="identifier">y</span> <span class="relational-operator">&gt;=</span> <span class="int-literal">0</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"loss='poisson' requires non-negative y and "</span>
                                 <span class="string-literal">"sum(y) &gt; 0."</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">y</span>

    <span class="keyword">def</span> <span class="identifier">_get_loss</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># TODO: Remove in v1.2</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">loss</span> <span class="relational-operator">==</span> <span class="string-literal">"least_squares"</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span>
                <span class="string-literal">"The loss 'least_squares' was deprecated in v1.0 and will be "</span>
                <span class="string-literal">"removed in version 1.2. Use 'squared_error' which is "</span>
                <span class="string-literal">"equivalent."</span><span class="punctuation">,</span>
                <span class="identifier">FutureWarning</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="identifier">_LOSSES</span><span class="grouping">[</span><span class="string-literal">"squared_error"</span><span class="grouping">]</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">loss</span> <span class="relational-operator">==</span> <span class="string-literal">"least_absolute_deviation"</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span>
                <span class="string-literal">"The loss 'least_absolute_deviation' was deprecated in v1.0 "</span>
                <span class="string-literal">" and will be removed in version 1.2. Use 'absolute_error' "</span>
                <span class="string-literal">"which is equivalent."</span><span class="punctuation">,</span>
                <span class="identifier">FutureWarning</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="identifier">_LOSSES</span><span class="grouping">[</span><span class="string-literal">"absolute_error"</span><span class="grouping">]</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">_LOSSES</span><span class="grouping">[</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">loss</span><span class="grouping">]</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">HistGradientBoostingClassifier</span><span class="grouping">(</span><span class="invalid">C</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">M</span><span class="invalid">i</span><span class="invalid">x</span><span class="invalid">i</span><span class="invalid">n</span><span class="punctuation">,</span>
                                     <span class="identifier">BaseHistGradientBoosting</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Histogram-based Gradient Boosting Classification Tree.

    This estimator is much faster than
    :class:`GradientBoostingClassifier&lt;sklearn.ensemble.GradientBoostingClassifier&gt;`
    for big datasets (n_samples &gt;= 10 000).

    This estimator has native support for missing values (NaNs). During
    training, the tree grower learns at each split point whether samples
    with missing values should go to the left or right child, based on the
    potential gain. When predicting, samples with missing values are
    assigned to the left or right child consequently. If no missing values
    were encountered for a given feature during training, then samples with
    missing values are mapped to whichever child has the most samples.

    This implementation is inspired by
    `LightGBM &lt;https://github.com/Microsoft/LightGBM&gt;`_.

    Read more in the :ref:`User Guide &lt;histogram_based_gradient_boosting&gt;`.

    .. versionadded:: 0.21

    Parameters
    ----------
    loss : {'auto', 'binary_crossentropy', 'categorical_crossentropy'}, \
            default='auto'
        The loss function to use in the boosting process. 'binary_crossentropy'
        (also known as logistic loss) is used for binary classification and
        generalizes to 'categorical_crossentropy' for multiclass
        classification. 'auto' will automatically choose either loss depending
        on the nature of the problem.
    learning_rate : float, default=0.1
        The learning rate, also known as *shrinkage*. This is used as a
        multiplicative factor for the leaves values. Use ``1`` for no
        shrinkage.
    max_iter : int, default=100
        The maximum number of iterations of the boosting process, i.e. the
        maximum number of trees for binary classification. For multiclass
        classification, `n_classes` trees per iteration are built.
    max_leaf_nodes : int or None, default=31
        The maximum number of leaves for each tree. Must be strictly greater
        than 1. If None, there is no maximum limit.
    max_depth : int or None, default=None
        The maximum depth of each tree. The depth of a tree is the number of
        edges to go from the root to the deepest leaf.
        Depth isn't constrained by default.
    min_samples_leaf : int, default=20
        The minimum number of samples per leaf. For small datasets with less
        than a few hundred samples, it is recommended to lower this value
        since only very shallow trees would be built.
    l2_regularization : float, default=0
        The L2 regularization parameter. Use 0 for no regularization.
    max_bins : int, default=255
        The maximum number of bins to use for non-missing values. Before
        training, each feature of the input array `X` is binned into
        integer-valued bins, which allows for a much faster training stage.
        Features with a small number of unique values may use less than
        ``max_bins`` bins. In addition to the ``max_bins`` bins, one more bin
        is always reserved for missing values. Must be no larger than 255.
    categorical_features : array-like of {bool, int} of shape (n_features) \
            or shape (n_categorical_features,), default=None.
        Indicates the categorical features.

        - None : no feature will be considered categorical.
        - boolean array-like : boolean mask indicating categorical features.
        - integer array-like : integer indices indicating categorical
          features.

        For each categorical feature, there must be at most `max_bins` unique
        categories, and each categorical value must be in [0, max_bins -1].

        Read more in the :ref:`User Guide &lt;categorical_support_gbdt&gt;`.

        .. versionadded:: 0.24

    monotonic_cst : array-like of int of shape (n_features), default=None
        Indicates the monotonic constraint to enforce on each feature. -1, 1
        and 0 respectively correspond to a negative constraint, positive
        constraint and no constraint. Read more in the :ref:`User Guide
        &lt;monotonic_cst_gbdt&gt;`.

        .. versionadded:: 0.23

    warm_start : bool, default=False
        When set to ``True``, reuse the solution of the previous call to fit
        and add more estimators to the ensemble. For results to be valid, the
        estimator should be re-trained on the same data only.
        See :term:`the Glossary &lt;warm_start&gt;`.
    early_stopping : 'auto' or bool, default='auto'
        If 'auto', early stopping is enabled if the sample size is larger than
        10000. If True, early stopping is enabled, otherwise early stopping is
        disabled.

        .. versionadded:: 0.23

    scoring : str or callable or None, default='loss'
        Scoring parameter to use for early stopping. It can be a single
        string (see :ref:`scoring_parameter`) or a callable (see
        :ref:`scoring`). If None, the estimator's default scorer
        is used. If ``scoring='loss'``, early stopping is checked
        w.r.t the loss value. Only used if early stopping is performed.
    validation_fraction : int or float or None, default=0.1
        Proportion (or absolute size) of training data to set aside as
        validation data for early stopping. If None, early stopping is done on
        the training data. Only used if early stopping is performed.
    n_iter_no_change : int, default=10
        Used to determine when to "early stop". The fitting process is
        stopped when none of the last ``n_iter_no_change`` scores are better
        than the ``n_iter_no_change - 1`` -th-to-last one, up to some
        tolerance. Only used if early stopping is performed.
    tol : float, default=1e-7
        The absolute tolerance to use when comparing scores. The higher the
        tolerance, the more likely we are to early stop: higher tolerance
        means that it will be harder for subsequent iterations to be
        considered an improvement upon the reference score.
    verbose : int, default=0
        The verbosity level. If not zero, print some information about the
        fitting process.
    random_state : int, RandomState instance or None, default=None
        Pseudo-random number generator to control the subsampling in the
        binning process, and the train/validation data split if early stopping
        is enabled.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    Attributes
    ----------
    classes_ : array, shape = (n_classes,)
        Class labels.
    do_early_stopping_ : bool
        Indicates whether early stopping is used during training.
    n_iter_ : int
        The number of iterations as selected by early stopping, depending on
        the `early_stopping` parameter. Otherwise it corresponds to max_iter.
    n_trees_per_iteration_ : int
        The number of tree that are built at each iteration. This is equal to 1
        for binary classification, and to ``n_classes`` for multiclass
        classification.
    train_score_ : ndarray, shape (n_iter_+1,)
        The scores at each iteration on the training data. The first entry
        is the score of the ensemble before the first iteration. Scores are
        computed according to the ``scoring`` parameter. If ``scoring`` is
        not 'loss', scores are computed on a subset of at most 10 000
        samples. Empty if no early stopping.
    validation_score_ : ndarray, shape (n_iter_+1,)
        The scores at each iteration on the held-out validation data. The
        first entry is the score of the ensemble before the first iteration.
        Scores are computed according to the ``scoring`` parameter. Empty if
        no early stopping or if ``validation_fraction`` is None.
    is_categorical_ : ndarray, shape (n_features, ) or None
        Boolean mask for the categorical features. ``None`` if there are no
        categorical features.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.ensemble import HistGradientBoostingClassifier
    &gt;&gt;&gt; from sklearn.datasets import load_iris
    &gt;&gt;&gt; X, y = load_iris(return_X_y=True)
    &gt;&gt;&gt; clf = HistGradientBoostingClassifier().fit(X, y)
    &gt;&gt;&gt; clf.score(X, y)
    1.0
    """</span>

    <span class="identifier">_VALID_LOSSES</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="string-literal">'binary_crossentropy', 'categorical_crossentropy'</span><span class="punctuation">,</span>
                     <span class="string-literal">'auto'</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">loss</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">learning_rate</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.1</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">100</span><span class="punctuation">,</span>
                 <span class="identifier">max_leaf_nodes</span><span class="arithmetic-assignment">=</span><span class="int-literal">31</span><span class="punctuation">,</span> <span class="identifier">max_depth</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">min_samples_leaf</span><span class="arithmetic-assignment">=</span><span class="int-literal">20</span><span class="punctuation">,</span>
                 <span class="identifier">l2_regularization</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">.</span><span class="punctuation">,</span> <span class="identifier">max_bins</span><span class="arithmetic-assignment">=</span><span class="int-literal">255</span><span class="punctuation">,</span>
                 <span class="identifier">categorical_features</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>  <span class="identifier">monotonic_cst</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">warm_start</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">early_stopping</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto', scoring='loss'</span><span class="punctuation">,</span>
                 <span class="identifier">validation_fraction</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.1</span><span class="punctuation">,</span> <span class="identifier">n_iter_no_change</span><span class="arithmetic-assignment">=</span><span class="int-literal">10</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-7</span><span class="punctuation">,</span>
                 <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="identifier">HistGradientBoostingClassifier</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">loss</span><span class="arithmetic-assignment">=</span><span class="identifier">loss</span><span class="punctuation">,</span> <span class="identifier">learning_rate</span><span class="arithmetic-assignment">=</span><span class="identifier">learning_rate</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
            <span class="identifier">max_leaf_nodes</span><span class="arithmetic-assignment">=</span><span class="identifier">max_leaf_nodes</span><span class="punctuation">,</span> <span class="identifier">max_depth</span><span class="arithmetic-assignment">=</span><span class="identifier">max_depth</span><span class="punctuation">,</span>
            <span class="identifier">min_samples_leaf</span><span class="arithmetic-assignment">=</span><span class="identifier">min_samples_leaf</span><span class="punctuation">,</span>
            <span class="identifier">l2_regularization</span><span class="arithmetic-assignment">=</span><span class="identifier">l2_regularization</span><span class="punctuation">,</span> <span class="identifier">max_bins</span><span class="arithmetic-assignment">=</span><span class="identifier">max_bins</span><span class="punctuation">,</span>
            <span class="identifier">categorical_features</span><span class="arithmetic-assignment">=</span><span class="identifier">categorical_features</span><span class="punctuation">,</span>
            <span class="identifier">monotonic_cst</span><span class="arithmetic-assignment">=</span><span class="identifier">monotonic_cst</span><span class="punctuation">,</span>
            <span class="identifier">warm_start</span><span class="arithmetic-assignment">=</span><span class="identifier">warm_start</span><span class="punctuation">,</span>
            <span class="identifier">early_stopping</span><span class="arithmetic-assignment">=</span><span class="identifier">early_stopping</span><span class="punctuation">,</span> <span class="identifier">scoring</span><span class="arithmetic-assignment">=</span><span class="identifier">scoring</span><span class="punctuation">,</span>
            <span class="identifier">validation_fraction</span><span class="arithmetic-assignment">=</span><span class="identifier">validation_fraction</span><span class="punctuation">,</span>
            <span class="identifier">n_iter_no_change</span><span class="arithmetic-assignment">=</span><span class="identifier">n_iter_no_change</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="punctuation">,</span>
            <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Predict classes for X.

        Parameters
        ----------
        X : array-like, shape (n_samples, n_features)
            The input samples.

        Returns
        -------
        y : ndarray, shape (n_samples,)
            The predicted classes.
        """</span>
        <span class="comment"># TODO: This could be done in parallel</span>
        <span class="identifier">encoded_classes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argmax</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">[</span><span class="identifier">encoded_classes</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">staged_predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Predict classes at each iteration.

        This method allows monitoring (i.e. determine error on testing set)
        after each stage.

        .. versionadded:: 0.24

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            The input samples.

        Yields
        -------
        y : generator of ndarray of shape (n_samples,)
            The predicted classes of the input samples, for each iteration.
        """</span>
        <span class="keyword">for</span> <span class="identifier">proba</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">staged_predict_proba</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">encoded_classes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argmax</span><span class="grouping">(</span><span class="identifier">proba</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span>
            <span class="keyword">yield</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="punctuation">.</span><span class="identifier">take</span><span class="grouping">(</span><span class="identifier">encoded_classes</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Predict class probabilities for X.

        Parameters
        ----------
        X : array-like, shape (n_samples, n_features)
            The input samples.

        Returns
        -------
        p : ndarray, shape (n_samples, n_classes)
            The class probabilities of the input samples.
        """</span>
        <span class="identifier">raw_predictions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_raw_predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_loss</span><span class="punctuation">.</span><span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">raw_predictions</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">staged_predict_proba</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Predict class probabilities at each iteration.

        This method allows monitoring (i.e. determine error on testing set)
        after each stage.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            The input samples.

        Yields
        -------
        y : generator of ndarray of shape (n_samples,)
            The predicted class probabilities of the input samples,
            for each iteration.
        """</span>
        <span class="keyword">for</span> <span class="identifier">raw_predictions</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_staged_raw_predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">yield</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_loss</span><span class="punctuation">.</span><span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">raw_predictions</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">decision_function</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute the decision function of ``X``.

        Parameters
        ----------
        X : array-like, shape (n_samples, n_features)
            The input samples.

        Returns
        -------
        decision : ndarray, shape (n_samples,) or \
                (n_samples, n_trees_per_iteration)
            The raw predicted values (i.e. the sum of the trees leaves) for
            each sample. n_trees_per_iteration is equal to the number of
            classes in multiclass classification.
        """</span>
        <span class="identifier">decision</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_raw_predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">decision</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">decision</span> <span class="arithmetic-assignment">=</span> <span class="identifier">decision</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">decision</span><span class="punctuation">.</span><span class="identifier">T</span>

    <span class="keyword">def</span> <span class="identifier">staged_decision_function</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute decision function of ``X`` for each iteration.

        This method allows monitoring (i.e. determine error on testing set)
        after each stage.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            The input samples.

        Yields
        -------
        decision : generator of ndarray of shape (n_samples,) or \
                (n_samples, n_trees_per_iteration)
            The decision function of the input samples, which corresponds to
            the raw values predicted from the trees of the ensemble . The
            classes corresponds to that in the attribute :term:`classes_`.
        """</span>
        <span class="keyword">for</span> <span class="identifier">staged_decision</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_staged_raw_predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">staged_decision</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="identifier">staged_decision</span> <span class="arithmetic-assignment">=</span> <span class="identifier">staged_decision</span><span class="punctuation">.</span><span class="identifier">ravel</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="keyword">yield</span> <span class="identifier">staged_decision</span><span class="punctuation">.</span><span class="identifier">T</span>

    <span class="keyword">def</span> <span class="identifier">_encode_y</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># encode classes into 0 ... n_classes - 1 and sets attributes classes_</span>
        <span class="comment"># and n_trees_per_iteration_</span>
        <span class="identifier">check_classification_targets</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>

        <span class="identifier">label_encoder</span> <span class="arithmetic-assignment">=</span> <span class="identifier">LabelEncoder</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="identifier">encoded_y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">label_encoder</span><span class="punctuation">.</span><span class="identifier">fit_transform</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">label_encoder</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span>
        <span class="identifier">n_classes</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="comment"># only 1 tree for binary classification. For multiclass classification,</span>
        <span class="comment"># we build 1 tree per class.</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_trees_per_iteration_</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span> <span class="keyword">if</span> <span class="identifier">n_classes</span> <span class="relational-operator">&lt;=</span> <span class="int-literal">2</span> <span class="keyword">else</span> <span class="identifier">n_classes</span>
        <span class="identifier">encoded_y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">encoded_y</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">Y_DTYPE</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">encoded_y</span>

    <span class="keyword">def</span> <span class="identifier">_get_loss</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">loss</span> <span class="relational-operator">==</span> <span class="string-literal">'categorical_crossentropy'</span> <span class="logical-operator">and</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_trees_per_iteration_</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"'categorical_crossentropy' is not suitable for "</span>
                             <span class="string-literal">"a binary classification problem. Please use "</span>
                             <span class="string-literal">"'auto' or 'binary_crossentropy' instead."</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">loss</span> <span class="relational-operator">==</span> <span class="string-literal">'auto'</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_trees_per_iteration_</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="keyword">return</span> <span class="identifier">_LOSSES</span><span class="grouping">[</span><span class="string-literal">'binary_crossentropy'</span><span class="grouping">]</span><span class="grouping">(</span>
                    <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="keyword">return</span> <span class="identifier">_LOSSES</span><span class="grouping">[</span><span class="string-literal">'categorical_crossentropy'</span><span class="grouping">]</span><span class="grouping">(</span>
                    <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">_LOSSES</span><span class="grouping">[</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">loss</span><span class="grouping">]</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>

    </pre>
  </body>
</html>