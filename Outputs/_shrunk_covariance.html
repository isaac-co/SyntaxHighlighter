<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""
Covariance estimators using shrinkage.

Shrinkage corresponds to regularising `cov` using a convex combination:
shrunk_cov = (1-shrinkage)*cov + shrinkage*structured_estimate.

"""</span>

<span class="comment"># Author: Alexandre Gramfort &lt;alexandre.gramfort@inria.fr&gt;</span>
<span class="comment">#         Gael Varoquaux &lt;gael.varoquaux@normalesup.org&gt;</span>
<span class="comment">#         Virgile Fritsch &lt;virgile.fritsch@inria.fr&gt;</span>
<span class="comment">#</span>
<span class="comment"># License: BSD 3 clause</span>

<span class="comment"># avoid division truncation</span>
<span class="keyword">import</span> <span class="identifier">warnings</span>
<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>

<span class="keyword">from</span> <span class="punctuation">.</span> <span class="keyword">import</span> <span class="identifier">empirical_covariance</span><span class="punctuation">,</span> <span class="identifier">EmpiricalCovariance</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">check_array</span>


<span class="comment"># ShrunkCovariance estimator</span>

<span class="keyword">def</span> <span class="identifier">shrunk_covariance</span><span class="grouping">(</span><span class="identifier">emp_cov</span><span class="punctuation">,</span> <span class="identifier">shrinkage</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.1</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Calculates a covariance matrix shrunk on the diagonal

    Read more in the :ref:`User Guide &lt;shrunk_covariance&gt;`.

    Parameters
    ----------
    emp_cov : array-like of shape (n_features, n_features)
        Covariance matrix to be shrunk

    shrinkage : float, default=0.1
        Coefficient in the convex combination used for the computation
        of the shrunk estimate. Range is [0, 1].

    Returns
    -------
    shrunk_cov : ndarray of shape (n_features, n_features)
        Shrunk covariance.

    Notes
    -----
    The regularized (shrunk) covariance is given by:

    (1 - shrinkage) * cov + shrinkage * mu * np.identity(n_features)

    where mu = trace(cov) / n_features
    """</span>
    <span class="identifier">emp_cov</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">emp_cov</span><span class="grouping">)</span>
    <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">emp_cov</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>

    <span class="identifier">mu</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">trace</span><span class="grouping">(</span><span class="identifier">emp_cov</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">n_features</span>
    <span class="identifier">shrunk_cov</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">-</span> <span class="identifier">shrinkage</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">emp_cov</span>
    <span class="identifier">shrunk_cov</span><span class="punctuation">.</span><span class="identifier">flat</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="identifier">n_features</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">shrinkage</span> <span class="arithmetic-operator">*</span> <span class="identifier">mu</span>

    <span class="keyword">return</span> <span class="identifier">shrunk_cov</span>


<span class="keyword">class</span> <span class="identifier">ShrunkCovariance</span><span class="grouping">(</span><span class="identifier">EmpiricalCovariance</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Covariance estimator with shrinkage

    Read more in the :ref:`User Guide &lt;shrunk_covariance&gt;`.

    Parameters
    ----------
    store_precision : bool, default=True
        Specify if the estimated precision is stored

    assume_centered : bool, default=False
        If True, data will not be centered before computation.
        Useful when working with data whose mean is almost, but not exactly
        zero.
        If False, data will be centered before computation.

    shrinkage : float, default=0.1
        Coefficient in the convex combination used for the computation
        of the shrunk estimate. Range is [0, 1].

    Attributes
    ----------
    covariance_ : ndarray of shape (n_features, n_features)
        Estimated covariance matrix

    location_ : ndarray of shape (n_features,)
        Estimated location, i.e. the estimated mean.

    precision_ : ndarray of shape (n_features, n_features)
        Estimated pseudo inverse matrix.
        (stored only if store_precision is True)

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.covariance import ShrunkCovariance
    &gt;&gt;&gt; from sklearn.datasets import make_gaussian_quantiles
    &gt;&gt;&gt; real_cov = np.array([[.8, .3],
    ...                      [.3, .4]])
    &gt;&gt;&gt; rng = np.random.RandomState(0)
    &gt;&gt;&gt; X = rng.multivariate_normal(mean=[0, 0],
    ...                                   cov=real_cov,
    ...                                   size=500)
    &gt;&gt;&gt; cov = ShrunkCovariance().fit(X)
    &gt;&gt;&gt; cov.covariance_
    array([[0.7387..., 0.2536...],
           [0.2536..., 0.4110...]])
    &gt;&gt;&gt; cov.location_
    array([0.0622..., 0.0193...])

    Notes
    -----
    The regularized covariance is given by:

    (1 - shrinkage) * cov + shrinkage * mu * np.identity(n_features)

    where mu = trace(cov) / n_features
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">store_precision</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                 <span class="identifier">shrinkage</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.1</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">store_precision</span><span class="arithmetic-assignment">=</span><span class="identifier">store_precision</span><span class="punctuation">,</span>
                         <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="arithmetic-assignment">=</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">shrinkage</span> <span class="arithmetic-assignment">=</span> <span class="identifier">shrinkage</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the shrunk covariance model according to the given training data
        and parameters.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where n_samples is the number of samples
            and n_features is the number of features.

        y : Ignored
            Not used, present for API consistency by convention.

        Returns
        -------
        self : object
        """</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="comment"># Not calling the parent object to fit, to avoid a potential</span>
        <span class="comment"># matrix inversion when setting the precision</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">location_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">location_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="int-literal">0</span><span class="grouping">)</span>
        <span class="identifier">covariance</span> <span class="arithmetic-assignment">=</span> <span class="identifier">empirical_covariance</span><span class="grouping">(</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">)</span>
        <span class="identifier">covariance</span> <span class="arithmetic-assignment">=</span> <span class="identifier">shrunk_covariance</span><span class="grouping">(</span><span class="identifier">covariance</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">shrinkage</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_set_covariance</span><span class="grouping">(</span><span class="identifier">covariance</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span>


<span class="comment"># Ledoit-Wolf estimator</span>

<span class="keyword">def</span> <span class="identifier">ledoit_wolf_shrinkage</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">block_size</span><span class="arithmetic-assignment">=</span><span class="int-literal">1000</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Estimates the shrunk Ledoit-Wolf covariance matrix.

    Read more in the :ref:`User Guide &lt;shrunk_covariance&gt;`.

    Parameters
    ----------
    X : array-like of shape (n_samples, n_features)
        Data from which to compute the Ledoit-Wolf shrunk covariance shrinkage.

    assume_centered : bool, default=False
        If True, data will not be centered before computation.
        Useful to work with data whose mean is significantly equal to
        zero but is not exactly zero.
        If False, data will be centered before computation.

    block_size : int, default=1000
        Size of blocks into which the covariance matrix will be split.

    Returns
    -------
    shrinkage : float
        Coefficient in the convex combination used for the computation
        of the shrunk estimate.

    Notes
    -----
    The regularized (shrunk) covariance is:

    (1 - shrinkage) * cov + shrinkage * mu * np.identity(n_features)

    where mu = trace(cov) / n_features
    """</span>
    <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="comment"># for only one feature, the result is the same whatever the shrinkage</span>
    <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">2</span> <span class="logical-operator">and</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="int-literal">0</span><span class="punctuation">.</span>
    <span class="keyword">if</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">"Only one sample available. "</span>
                      <span class="string-literal">"You may want to reshape your data array"</span><span class="grouping">)</span>
    <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>

    <span class="comment"># optionally center data</span>
    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="punctuation">:</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span> <span class="arithmetic-operator">-</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="int-literal">0</span><span class="grouping">)</span>

    <span class="comment"># A non-blocked version of the computation is present in the tests</span>
    <span class="comment"># in tests/test_covariance.py</span>

    <span class="comment"># number of blocks to split the covariance matrix into</span>
    <span class="identifier">n_splits</span> <span class="arithmetic-assignment">=</span> <span class="identifier">int</span><span class="grouping">(</span><span class="identifier">n_features</span> <span class="arithmetic-operator">/</span> <span class="identifier">block_size</span><span class="grouping">)</span>
    <span class="identifier">X2</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span>
    <span class="identifier">emp_cov_trace</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">X2</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">n_samples</span>
    <span class="identifier">mu</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">emp_cov_trace</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">n_features</span>
    <span class="identifier">beta_</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>  <span class="comment"># sum of the coefficients of &lt;X2.T, X2&gt;</span>
    <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span><span class="punctuation">.</span>  <span class="comment"># sum of the *squared* coefficients of &lt;X.T, X&gt;</span>
    <span class="comment"># starting block computation</span>
    <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">for</span> <span class="identifier">j</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">rows</span> <span class="arithmetic-assignment">=</span> <span class="identifier">slice</span><span class="grouping">(</span><span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">cols</span> <span class="arithmetic-assignment">=</span> <span class="identifier">slice</span><span class="grouping">(</span><span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="identifier">j</span><span class="punctuation">,</span> <span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="identifier">j</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">beta_</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X2</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">rows</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X2</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">cols</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">rows</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">cols</span><span class="grouping">]</span><span class="grouping">)</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="grouping">)</span>
        <span class="identifier">rows</span> <span class="arithmetic-assignment">=</span> <span class="identifier">slice</span><span class="grouping">(</span><span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="identifier">i</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">beta_</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X2</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">rows</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X2</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_splits</span><span class="punctuation">:</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span>
            <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">rows</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_splits</span><span class="punctuation">:</span><span class="grouping">]</span><span class="grouping">)</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="grouping">)</span>
    <span class="keyword">for</span> <span class="identifier">j</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">cols</span> <span class="arithmetic-assignment">=</span> <span class="identifier">slice</span><span class="grouping">(</span><span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="identifier">j</span><span class="punctuation">,</span> <span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="identifier">j</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">beta_</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X2</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_splits</span><span class="punctuation">:</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X2</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">cols</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span>
            <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_splits</span><span class="punctuation">:</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">cols</span><span class="grouping">]</span><span class="grouping">)</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="grouping">)</span>
    <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_splits</span><span class="punctuation">:</span><span class="grouping">]</span><span class="punctuation">,</span>
                            <span class="identifier">X</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_splits</span><span class="punctuation">:</span><span class="grouping">]</span><span class="grouping">)</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="grouping">)</span>
    <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">n_samples</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span>
    <span class="identifier">beta_</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X2</span><span class="punctuation">.</span><span class="identifier">T</span><span class="grouping">[</span><span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_splits</span><span class="punctuation">:</span><span class="grouping">]</span><span class="punctuation">,</span>
                           <span class="identifier">X2</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">block_size</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_splits</span><span class="punctuation">:</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="comment"># use delta_ to compute beta</span>
    <span class="identifier">beta</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">/</span> <span class="grouping">(</span><span class="identifier">n_features</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_samples</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="identifier">beta_</span> <span class="arithmetic-operator">/</span> <span class="identifier">n_samples</span> <span class="arithmetic-operator">-</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span><span class="grouping">)</span>
    <span class="comment"># delta is the sum of the squared coefficients of (&lt;X.T,X&gt; - mu*Id) / p</span>
    <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span> <span class="arithmetic-assignment">=</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="invalid">_</span> <span class="arithmetic-operator">-</span> <span class="int-literal">2</span><span class="punctuation">.</span> <span class="arithmetic-operator">*</span> <span class="identifier">mu</span> <span class="arithmetic-operator">*</span> <span class="identifier">emp_cov_trace</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="grouping">)</span> <span class="arithmetic-operator">+</span> <span class="identifier">n_features</span> <span class="arithmetic-operator">*</span> <span class="identifier">mu</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span>
    <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">n_features</span>
    <span class="comment"># get final beta as the min between beta and delta</span>
    <span class="comment"># We do this to prevent shrinking more than "1", which whould invert</span>
    <span class="comment"># the value of covariances</span>
    <span class="identifier">beta</span> <span class="arithmetic-assignment">=</span> <span class="identifier">min</span><span class="grouping">(</span><span class="identifier">beta</span><span class="punctuation">,</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span><span class="grouping">)</span>
    <span class="comment"># finally get shrinkage</span>
    <span class="identifier">shrinkage</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">0</span> <span class="keyword">if</span> <span class="identifier">beta</span> <span class="relational-operator">==</span> <span class="int-literal">0</span> <span class="keyword">else</span> <span class="identifier">beta</span> <span class="arithmetic-operator">/</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">a</span>
    <span class="keyword">return</span> <span class="identifier">shrinkage</span>


<span class="keyword">def</span> <span class="identifier">ledoit_wolf</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">block_size</span><span class="arithmetic-assignment">=</span><span class="int-literal">1000</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Estimates the shrunk Ledoit-Wolf covariance matrix.

    Read more in the :ref:`User Guide &lt;shrunk_covariance&gt;`.

    Parameters
    ----------
    X : array-like of shape (n_samples, n_features)
        Data from which to compute the covariance estimate

    assume_centered : bool, default=False
        If True, data will not be centered before computation.
        Useful to work with data whose mean is significantly equal to
        zero but is not exactly zero.
        If False, data will be centered before computation.

    block_size : int, default=1000
        Size of blocks into which the covariance matrix will be split.
        This is purely a memory optimization and does not affect results.

    Returns
    -------
    shrunk_cov : ndarray of shape (n_features, n_features)
        Shrunk covariance.

    shrinkage : float
        Coefficient in the convex combination used for the computation
        of the shrunk estimate.

    Notes
    -----
    The regularized (shrunk) covariance is:

    (1 - shrinkage) * cov + shrinkage * mu * np.identity(n_features)

    where mu = trace(cov) / n_features
    """</span>
    <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="comment"># for only one feature, the result is the same whatever the shrinkage</span>
    <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">2</span> <span class="logical-operator">and</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="punctuation">:</span>
            <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span> <span class="arithmetic-operator">-</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">atleast_2d</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">X</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="punctuation">.</span>
    <span class="keyword">if</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">"Only one sample available. "</span>
                      <span class="string-literal">"You may want to reshape your data array"</span><span class="grouping">)</span>
        <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">size</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>

    <span class="comment"># get Ledoit-Wolf shrinkage</span>
    <span class="identifier">shrinkage</span> <span class="arithmetic-assignment">=</span> <span class="identifier">ledoit_wolf_shrinkage</span><span class="grouping">(</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="arithmetic-assignment">=</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="punctuation">,</span> <span class="identifier">block_size</span><span class="arithmetic-assignment">=</span><span class="identifier">block_size</span><span class="grouping">)</span>
    <span class="identifier">emp_cov</span> <span class="arithmetic-assignment">=</span> <span class="identifier">empirical_covariance</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="arithmetic-assignment">=</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">)</span>
    <span class="identifier">mu</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">trace</span><span class="grouping">(</span><span class="identifier">emp_cov</span><span class="grouping">)</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">n_features</span>
    <span class="identifier">shrunk_cov</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">-</span> <span class="identifier">shrinkage</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">emp_cov</span>
    <span class="identifier">shrunk_cov</span><span class="punctuation">.</span><span class="identifier">flat</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="identifier">n_features</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">shrinkage</span> <span class="arithmetic-operator">*</span> <span class="identifier">mu</span>

    <span class="keyword">return</span> <span class="identifier">shrunk_cov</span><span class="punctuation">,</span> <span class="identifier">shrinkage</span>


<span class="keyword">class</span> <span class="identifier">LedoitWolf</span><span class="grouping">(</span><span class="identifier">EmpiricalCovariance</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""LedoitWolf Estimator

    Ledoit-Wolf is a particular form of shrinkage, where the shrinkage
    coefficient is computed using O. Ledoit and M. Wolf's formula as
    described in "A Well-Conditioned Estimator for Large-Dimensional
    Covariance Matrices", Ledoit and Wolf, Journal of Multivariate
    Analysis, Volume 88, Issue 2, February 2004, pages 365-411.

    Read more in the :ref:`User Guide &lt;shrunk_covariance&gt;`.

    Parameters
    ----------
    store_precision : bool, default=True
        Specify if the estimated precision is stored.

    assume_centered : bool, default=False
        If True, data will not be centered before computation.
        Useful when working with data whose mean is almost, but not exactly
        zero.
        If False (default), data will be centered before computation.

    block_size : int, default=1000
        Size of blocks into which the covariance matrix will be split
        during its Ledoit-Wolf estimation. This is purely a memory
        optimization and does not affect results.

    Attributes
    ----------
    covariance_ : ndarray of shape (n_features, n_features)
        Estimated covariance matrix.

    location_ : ndarray of shape (n_features,)
        Estimated location, i.e. the estimated mean.

    precision_ : ndarray of shape (n_features, n_features)
        Estimated pseudo inverse matrix.
        (stored only if store_precision is True)

    shrinkage_ : float
        Coefficient in the convex combination used for the computation
        of the shrunk estimate. Range is [0, 1].

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.covariance import LedoitWolf
    &gt;&gt;&gt; real_cov = np.array([[.4, .2],
    ...                      [.2, .8]])
    &gt;&gt;&gt; np.random.seed(0)
    &gt;&gt;&gt; X = np.random.multivariate_normal(mean=[0, 0],
    ...                                   cov=real_cov,
    ...                                   size=50)
    &gt;&gt;&gt; cov = LedoitWolf().fit(X)
    &gt;&gt;&gt; cov.covariance_
    array([[0.4406..., 0.1616...],
           [0.1616..., 0.8022...]])
    &gt;&gt;&gt; cov.location_
    array([ 0.0595... , -0.0075...])

    Notes
    -----
    The regularised covariance is:

    (1 - shrinkage) * cov + shrinkage * mu * np.identity(n_features)

    where mu = trace(cov) / n_features
    and shrinkage is given by the Ledoit and Wolf formula (see References)

    References
    ----------
    "A Well-Conditioned Estimator for Large-Dimensional Covariance Matrices",
    Ledoit and Wolf, Journal of Multivariate Analysis, Volume 88, Issue 2,
    February 2004, pages 365-411.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">store_precision</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                 <span class="identifier">block_size</span><span class="arithmetic-assignment">=</span><span class="int-literal">1000</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">store_precision</span><span class="arithmetic-assignment">=</span><span class="identifier">store_precision</span><span class="punctuation">,</span>
                         <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="arithmetic-assignment">=</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">block_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">block_size</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the Ledoit-Wolf shrunk covariance model according to the given
        training data and parameters.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where `n_samples` is the number of samples
            and `n_features` is the number of features.
        y : Ignored
            Not used, present for API consistency by convention.

        Returns
        -------
        self : object
        """</span>
        <span class="comment"># Not calling the parent object to fit, to avoid computing the</span>
        <span class="comment"># covariance matrix (and potentially the precision)</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">location_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">location_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="int-literal">0</span><span class="grouping">)</span>
        <span class="identifier">covariance</span><span class="punctuation">,</span> <span class="identifier">shrinkage</span> <span class="arithmetic-assignment">=</span> <span class="identifier">ledoit_wolf</span><span class="grouping">(</span><span class="identifier">X</span> <span class="arithmetic-operator">-</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">location_</span><span class="punctuation">,</span>
                                            <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                                            <span class="identifier">block_size</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">block_size</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">shrinkage_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">shrinkage</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_set_covariance</span><span class="grouping">(</span><span class="identifier">covariance</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span>


<span class="comment"># OAS estimator</span>
<span class="keyword">def</span> <span class="identifier">oas</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Estimate covariance with the Oracle Approximating Shrinkage algorithm.

    Parameters
    ----------
    X : array-like of shape (n_samples, n_features)
        Data from which to compute the covariance estimate.

    assume_centered : bool, default=False
      If True, data will not be centered before computation.
      Useful to work with data whose mean is significantly equal to
      zero but is not exactly zero.
      If False, data will be centered before computation.

    Returns
    -------
    shrunk_cov : array-like of shape (n_features, n_features)
        Shrunk covariance.

    shrinkage : float
        Coefficient in the convex combination used for the computation
        of the shrunk estimate.

    Notes
    -----
    The regularised (shrunk) covariance is:

    (1 - shrinkage) * cov + shrinkage * mu * np.identity(n_features)

    where mu = trace(cov) / n_features

    The formula we used to implement the OAS is slightly modified compared
    to the one given in the article. See :class:`OAS` for more details.
    """</span>
    <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="comment"># for only one feature, the result is the same whatever the shrinkage</span>
    <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">2</span> <span class="logical-operator">and</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="punctuation">:</span>
            <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span> <span class="arithmetic-operator">-</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">atleast_2d</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">X</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="punctuation">.</span>
    <span class="keyword">if</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">"Only one sample available. "</span>
                      <span class="string-literal">"You may want to reshape your data array"</span><span class="grouping">)</span>
        <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span>
        <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">size</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>

    <span class="identifier">emp_cov</span> <span class="arithmetic-assignment">=</span> <span class="identifier">empirical_covariance</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="arithmetic-assignment">=</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">)</span>
    <span class="identifier">mu</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">trace</span><span class="grouping">(</span><span class="identifier">emp_cov</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">n_features</span>

    <span class="comment"># formula from Chen et al.'s **implementation**</span>
    <span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="identifier">emp_cov</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="grouping">)</span>
    <span class="identifier">num</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha</span> <span class="arithmetic-operator">+</span> <span class="identifier">mu</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span>
    <span class="identifier">den</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">n_samples</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="punctuation">.</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="identifier">alpha</span> <span class="arithmetic-operator">-</span> <span class="grouping">(</span><span class="identifier">mu</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span> <span class="identifier">n_features</span><span class="grouping">)</span>

    <span class="identifier">shrinkage</span> <span class="arithmetic-assignment">=</span> <span class="int-literal">1</span><span class="punctuation">.</span> <span class="keyword">if</span> <span class="identifier">den</span> <span class="relational-operator">==</span> <span class="int-literal">0</span> <span class="keyword">else</span> <span class="identifier">min</span><span class="grouping">(</span><span class="identifier">num</span> <span class="arithmetic-operator">/</span> <span class="identifier">den</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="punctuation">.</span><span class="grouping">)</span>
    <span class="identifier">shrunk_cov</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="int-literal">1</span><span class="punctuation">.</span> <span class="arithmetic-operator">-</span> <span class="identifier">shrinkage</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">emp_cov</span>
    <span class="identifier">shrunk_cov</span><span class="punctuation">.</span><span class="identifier">flat</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="identifier">n_features</span> <span class="arithmetic-operator">+</span> <span class="int-literal">1</span><span class="grouping">]</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">shrinkage</span> <span class="arithmetic-operator">*</span> <span class="identifier">mu</span>

    <span class="keyword">return</span> <span class="identifier">shrunk_cov</span><span class="punctuation">,</span> <span class="identifier">shrinkage</span>


<span class="keyword">class</span> <span class="identifier">OAS</span><span class="grouping">(</span><span class="identifier">EmpiricalCovariance</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Oracle Approximating Shrinkage Estimator

    Read more in the :ref:`User Guide &lt;shrunk_covariance&gt;`.

    OAS is a particular form of shrinkage described in
    "Shrinkage Algorithms for MMSE Covariance Estimation"
    Chen et al., IEEE Trans. on Sign. Proc., Volume 58, Issue 10, October 2010.

    The formula used here does not correspond to the one given in the
    article. In the original article, formula (23) states that 2/p is
    multiplied by Trace(cov*cov) in both the numerator and denominator, but
    this operation is omitted because for a large p, the value of 2/p is
    so small that it doesn't affect the value of the estimator.

    Parameters
    ----------
    store_precision : bool, default=True
        Specify if the estimated precision is stored.

    assume_centered : bool, default=False
        If True, data will not be centered before computation.
        Useful when working with data whose mean is almost, but not exactly
        zero.
        If False (default), data will be centered before computation.

    Attributes
    ----------
    covariance_ : ndarray of shape (n_features, n_features)
        Estimated covariance matrix.

    location_ : ndarray of shape (n_features,)
        Estimated location, i.e. the estimated mean.

    precision_ : ndarray of shape (n_features, n_features)
        Estimated pseudo inverse matrix.
        (stored only if store_precision is True)

    shrinkage_ : float
      coefficient in the convex combination used for the computation
      of the shrunk estimate. Range is [0, 1].

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from sklearn.covariance import OAS
    &gt;&gt;&gt; from sklearn.datasets import make_gaussian_quantiles
    &gt;&gt;&gt; real_cov = np.array([[.8, .3],
    ...                      [.3, .4]])
    &gt;&gt;&gt; rng = np.random.RandomState(0)
    &gt;&gt;&gt; X = rng.multivariate_normal(mean=[0, 0],
    ...                             cov=real_cov,
    ...                             size=500)
    &gt;&gt;&gt; oas = OAS().fit(X)
    &gt;&gt;&gt; oas.covariance_
    array([[0.7533..., 0.2763...],
           [0.2763..., 0.3964...]])
    &gt;&gt;&gt; oas.precision_
    array([[ 1.7833..., -1.2431... ],
           [-1.2431...,  3.3889...]])
    &gt;&gt;&gt; oas.shrinkage_
    0.0195...

    Notes
    -----
    The regularised covariance is:

    (1 - shrinkage) * cov + shrinkage * mu * np.identity(n_features)

    where mu = trace(cov) / n_features
    and shrinkage is given by the OAS formula (see References)

    References
    ----------
    "Shrinkage Algorithms for MMSE Covariance Estimation"
    Chen et al., IEEE Trans. on Sign. Proc., Volume 58, Issue 10, October 2010.
    """</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit the Oracle Approximating Shrinkage covariance model
        according to the given training data and parameters.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Training data, where `n_samples` is the number of samples
            and `n_features` is the number of features.
        y : Ignored
            Not used, present for API consistency by convention.

        Returns
        -------
        self : object
        """</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="comment"># Not calling the parent object to fit, to avoid computing the</span>
        <span class="comment"># covariance matrix (and potentially the precision)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">location_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">location_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="int-literal">0</span><span class="grouping">)</span>

        <span class="identifier">covariance</span><span class="punctuation">,</span> <span class="identifier">shrinkage</span> <span class="arithmetic-assignment">=</span> <span class="identifier">oas</span><span class="grouping">(</span><span class="identifier">X</span> <span class="arithmetic-operator">-</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">location_</span><span class="punctuation">,</span> <span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">u</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">n</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">shrinkage_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">shrinkage</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_set_covariance</span><span class="grouping">(</span><span class="identifier">covariance</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">self</span>

    </pre>
  </body>
</html>