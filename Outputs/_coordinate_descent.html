<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment"># Author: Alexandre Gramfort &lt;alexandre.gramfort@inria.fr&gt;</span>
<span class="comment">#         Fabian Pedregosa &lt;fabian.pedregosa@inria.fr&gt;</span>
<span class="comment">#         Olivier Grisel &lt;olivier.grisel@ensta.org&gt;</span>
<span class="comment">#         Gael Varoquaux &lt;gael.varoquaux@inria.fr&gt;</span>
<span class="comment">#</span>
<span class="comment"># License: BSD 3 clause</span>

<span class="keyword">import</span> <span class="identifier">sys</span>
<span class="keyword">import</span> <span class="identifier">warnings</span>
<span class="keyword">import</span> <span class="identifier">numbers</span>
<span class="keyword">from</span> <span class="identifier">abc</span> <span class="keyword">import</span> <span class="identifier">ABCMeta</span><span class="punctuation">,</span> <span class="identifier">abstractmethod</span>

<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">from</span> <span class="identifier">scipy</span> <span class="keyword">import</span> <span class="identifier">sparse</span>
<span class="keyword">from</span> <span class="identifier">joblib</span> <span class="keyword">import</span> <span class="identifier">Parallel</span><span class="punctuation">,</span> <span class="identifier">effective_n_jobs</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_base</span> <span class="keyword">import</span> <span class="identifier">LinearModel</span><span class="punctuation">,</span> <span class="identifier">_pre_fit</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">RegressorMixin</span><span class="punctuation">,</span> <span class="identifier">MultiOutputMixin</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_base</span> <span class="keyword">import</span> <span class="identifier">_preprocess_data</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">check_array</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_random_state</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">model_selection</span> <span class="keyword">import</span> <span class="identifier">check_cv</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">extmath</span> <span class="keyword">import</span> <span class="identifier">safe_sparse_dot</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">fixes</span> <span class="keyword">import</span> <span class="identifier">_astype_copy_false</span><span class="punctuation">,</span> <span class="identifier">_joblib_parallel_args</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">check_is_fitted</span><span class="punctuation">,</span> <span class="identifier">_check_sample_weight</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">column_or_1d</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">fixes</span> <span class="keyword">import</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span>

<span class="comment"># mypy error: Module 'sklearn.linear_model' has no attribute '_cd_fast'</span>
<span class="keyword">from</span> <span class="punctuation">.</span> <span class="keyword">import</span> <span class="identifier">_cd_fast</span> <span class="keyword">as</span> <span class="identifier">cd_fast</span>  <span class="comment"># type: ignore</span>


<span class="keyword">def</span> <span class="identifier">_set_order</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'C'</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Change the order of X and y if necessary.

    Parameters
    ----------
    X : {array-like, sparse matrix} of shape (n_samples, n_features)
        Training data.

    y : ndarray of shape (n_samples,)
        Target values.

    order : {None, 'C', 'F'}
        If 'C', dense arrays are returned as C-ordered, sparse matrices in csr
        format. If 'F', dense arrays are return as F-ordered, sparse matrices
        in csc format.

    Returns
    -------
    X : {array-like, sparse matrix} of shape (n_samples, n_features)
        Training data with guaranteed order.

    y : ndarray of shape (n_samples,)
        Target values with guaranteed order.
    """</span>
    <span class="keyword">if</span> <span class="identifier">order</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="string-literal">'C', 'F'</span><span class="grouping">]</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Unknown value for order. Got {} instead of "</span>
                         <span class="string-literal">"None, 'C' or 'F'."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">order</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="identifier">sparse_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
    <span class="identifier">sparse_y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">order</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">sparse_format</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"csc" if order == "F" else "csr"</span>
        <span class="keyword">if</span> <span class="identifier">sparse_X</span><span class="punctuation">:</span>
            <span class="comment"># As of scipy 1.1.0, new argument copy=False by default.</span>
            <span class="comment"># This is what we want.</span>
            <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">sparse_format</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">_astype_copy_false</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="identifier">order</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">sparse_y</span><span class="punctuation">:</span>
            <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">sparse_format</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="identifier">order</span><span class="grouping">)</span>
    <span class="keyword">return</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span>


<span class="comment">###############################################################################</span>
<span class="comment"># Paths functions</span>

<span class="keyword">def</span> <span class="identifier">_alpha_grid</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="float-literal">1.0</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="arithmetic-assignment">=</span><span class="int-literal">100</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">""" Compute the grid of alpha values for elastic net parameter search

    Parameters
    ----------
    X : {array-like, sparse matrix} of shape (n_samples, n_features)
        Training data. Pass directly as Fortran-contiguous data to avoid
        unnecessary memory duplication

    y : ndarray of shape (n_samples,)
        Target values

    Xy : array-like of shape (n_features,), default=None
        Xy = np.dot(X.T, y) that can be precomputed.

    l1_ratio : float, default=1.0
        The elastic net mixing parameter, with ``0 &lt; l1_ratio &lt;= 1``.
        For ``l1_ratio = 0`` the penalty is an L2 penalty. (currently not
        supported) ``For l1_ratio = 1`` it is an L1 penalty. For
        ``0 &lt; l1_ratio &lt;1``, the penalty is a combination of L1 and L2.

    eps : float, default=1e-3
        Length of the path. ``eps=1e-3`` means that
        ``alpha_min / alpha_max = 1e-3``

    n_alphas : int, default=100
        Number of alphas along the regularization path

    fit_intercept : bool, default=True
        Whether to fit an intercept or not

    normalize : bool, default=False
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

    copy_X : bool, default=True
        If ``True``, X will be copied; else, it may be overwritten.
    """</span>
    <span class="keyword">if</span> <span class="identifier">l1_ratio</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Automatic alpha grid generation is not supported for"</span>
                         <span class="string-literal">" l1_ratio=0. Please supply a grid by providing "</span>
                         <span class="string-literal">"your estimator with the appropriate `alphas=` "</span>
                         <span class="string-literal">"argument."</span><span class="grouping">)</span>
    <span class="identifier">n_samples</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>

    <span class="identifier">sparse_center</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
    <span class="keyword">if</span> <span class="identifier">Xy</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">X_sparse</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">isspmatrix</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>
        <span class="identifier">sparse_center</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_sparse</span> <span class="logical-operator">and</span> <span class="grouping">(</span><span class="identifier">fit_intercept</span> <span class="logical-operator">or</span> <span class="identifier">normalize</span><span class="grouping">)</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csc'</span><span class="punctuation">,</span>
                        <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="identifier">copy_X</span> <span class="logical-operator">and</span> <span class="identifier">fit_intercept</span> <span class="logical-operator">and</span> <span class="logical-operator">not</span> <span class="identifier">X_sparse</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">X_sparse</span><span class="punctuation">:</span>
            <span class="comment"># X can be touched inplace thanks to the above line</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_preprocess_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="punctuation">,</span>
                                             <span class="identifier">normalize</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="identifier">Xy</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">sparse_center</span><span class="punctuation">:</span>
            <span class="comment"># Workaround to find alpha_max for sparse matrices.</span>
            <span class="comment"># since we should not destroy the sparsity of such matrices.</span>
            <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">X_offset</span><span class="punctuation">,</span> <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">X_scale</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_preprocess_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="punctuation">,</span>
                                                          <span class="identifier">normalize</span><span class="punctuation">,</span>
                                                          <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">a</span><span class="invalid">n</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
            <span class="identifier">mean_dot</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_offset</span> <span class="arithmetic-operator">*</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">y</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">Xy</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="identifier">Xy</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Xy</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>

    <span class="keyword">if</span> <span class="identifier">sparse_center</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="identifier">fit_intercept</span><span class="punctuation">:</span>
            <span class="identifier">Xy</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">mean_dot</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
        <span class="keyword">if</span> <span class="identifier">normalize</span><span class="punctuation">:</span>
            <span class="identifier">Xy</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">X_scale</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>

    <span class="identifier">alpha_max</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">Xy</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">max</span><span class="grouping">(</span><span class="grouping">)</span> <span class="arithmetic-operator">/</span>
                 <span class="grouping">(</span><span class="identifier">n_samples</span> <span class="arithmetic-operator">*</span> <span class="identifier">l1_ratio</span><span class="grouping">)</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">alpha_max</span> <span class="relational-operator">&lt;=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">float</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">resolution</span><span class="punctuation">:</span>
        <span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">n_alphas</span><span class="grouping">)</span>
        <span class="identifier">alphas</span><span class="punctuation">.</span><span class="identifier">fill</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">finfo</span><span class="grouping">(</span><span class="identifier">float</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">resolution</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">alphas</span>

    <span class="keyword">return</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">logspace</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">log10</span><span class="grouping">(</span><span class="identifier">alpha_max</span> <span class="arithmetic-operator">*</span> <span class="identifier">eps</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">log10</span><span class="grouping">(</span><span class="identifier">alpha_max</span><span class="grouping">)</span><span class="punctuation">,</span>
                       <span class="identifier">num</span><span class="arithmetic-assignment">=</span><span class="identifier">n_alphas</span><span class="grouping">)</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span>


<span class="keyword">def</span> <span class="identifier">lasso_path</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="arithmetic-assignment">=</span><span class="int-literal">100</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
               <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">coef_init</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
               <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">params</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Compute Lasso path with coordinate descent

    The Lasso optimization function varies for mono and multi-outputs.

    For mono-output tasks it is::

        (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1

    For multi-output tasks it is::

        (1 / (2 * n_samples)) * ||Y - XW||^2_Fro + alpha * ||W||_21

    Where::

        ||W||_21 = \\sum_i \\sqrt{\\sum_j w_{ij}^2}

    i.e. the sum of norm of each row.

    Read more in the :ref:`User Guide &lt;lasso&gt;`.

    Parameters
    ----------
    X : {array-like, sparse matrix} of shape (n_samples, n_features)
        Training data. Pass directly as Fortran-contiguous data to avoid
        unnecessary memory duplication. If ``y`` is mono-output then ``X``
        can be sparse.

    y : {array-like, sparse matrix} of shape (n_samples,) or \
        (n_samples, n_outputs)
        Target values

    eps : float, default=1e-3
        Length of the path. ``eps=1e-3`` means that
        ``alpha_min / alpha_max = 1e-3``

    n_alphas : int, default=100
        Number of alphas along the regularization path

    alphas : ndarray, default=None
        List of alphas where to compute the models.
        If ``None`` alphas are set automatically

    precompute : 'auto', bool or array-like of shape (n_features, n_features),\
                 default='auto'
        Whether to use a precomputed Gram matrix to speed up
        calculations. If set to ``'auto'`` let us decide. The Gram
        matrix can also be passed as argument.

    Xy : array-like of shape (n_features,) or (n_features, n_outputs),\
         default=None
        Xy = np.dot(X.T, y) that can be precomputed. It is useful
        only when the Gram matrix is precomputed.

    copy_X : bool, default=True
        If ``True``, X will be copied; else, it may be overwritten.

    coef_init : ndarray of shape (n_features, ), default=None
        The initial values of the coefficients.

    verbose : bool or int, default=False
        Amount of verbosity.

    return_n_iter : bool, default=False
        whether to return the number of iterations or not.

    positive : bool, default=False
        If set to True, forces coefficients to be positive.
        (Only allowed when ``y.ndim == 1``).

    **params : kwargs
        keyword arguments passed to the coordinate descent solver.

    Returns
    -------
    alphas : ndarray of shape (n_alphas,)
        The alphas along the path where models are computed.

    coefs : ndarray of shape (n_features, n_alphas) or \
            (n_outputs, n_features, n_alphas)
        Coefficients along the path.

    dual_gaps : ndarray of shape (n_alphas,)
        The dual gaps at the end of the optimization for each alpha.

    n_iters : list of int
        The number of iterations taken by the coordinate descent optimizer to
        reach the specified tolerance for each alpha.

    Notes
    -----
    For an example, see
    :ref:`examples/linear_model/plot_lasso_coordinate_descent_path.py
    &lt;sphx_glr_auto_examples_linear_model_plot_lasso_coordinate_descent_path.py&gt;`.

    To avoid unnecessary memory duplication the X argument of the fit method
    should be directly passed as a Fortran-contiguous numpy array.

    Note that in certain cases, the Lars solver may be significantly
    faster to implement this functionality. In particular, linear
    interpolation can be used to retrieve model coefficients between the
    values output by lars_path

    Examples
    --------

    Comparing lasso_path and lars_path with interpolation:

    &gt;&gt;&gt; X = np.array([[1, 2, 3.1], [2.3, 5.4, 4.3]]).T
    &gt;&gt;&gt; y = np.array([1, 2, 3.1])
    &gt;&gt;&gt; # Use lasso_path to compute a coefficient path
    &gt;&gt;&gt; _, coef_path, _ = lasso_path(X, y, alphas=[5., 1., .5])
    &gt;&gt;&gt; print(coef_path)
    [[0.         0.         0.46874778]
     [0.2159048  0.4425765  0.23689075]]

    &gt;&gt;&gt; # Now use lars_path and 1D linear interpolation to compute the
    &gt;&gt;&gt; # same path
    &gt;&gt;&gt; from sklearn.linear_model import lars_path
    &gt;&gt;&gt; alphas, active, coef_path_lars = lars_path(X, y, method='lasso')
    &gt;&gt;&gt; from scipy import interpolate
    &gt;&gt;&gt; coef_path_continuous = interpolate.interp1d(alphas[::-1],
    ...                                             coef_path_lars[:, ::-1])
    &gt;&gt;&gt; print(coef_path_continuous([5., 1., .5]))
    [[0.         0.         0.46915237]
     [0.2159048  0.4425765  0.23668876]]

    See Also
    --------
    lars_path
    Lasso
    LassoLars
    LassoCV
    LassoLarsCV
    sklearn.decomposition.sparse_encode
    """</span>
    <span class="keyword">return</span> <span class="identifier">enet_path</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">.</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="arithmetic-assignment">=</span><span class="identifier">n_alphas</span><span class="punctuation">,</span>
                     <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="identifier">alphas</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="identifier">Xy</span><span class="punctuation">,</span>
                     <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="identifier">copy_X</span><span class="punctuation">,</span> <span class="identifier">coef_init</span><span class="arithmetic-assignment">=</span><span class="identifier">coef_init</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="punctuation">,</span>
                     <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="identifier">positive</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">params</span><span class="grouping">)</span>


<span class="keyword">def</span> <span class="identifier">enet_path</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.5</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="arithmetic-assignment">=</span><span class="int-literal">100</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
              <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">coef_init</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
              <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
              <span class="identifier">check_input</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">params</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""
    Compute elastic net path with coordinate descent.

    The elastic net optimization function varies for mono and multi-outputs.

    For mono-output tasks it is::

        1 / (2 * n_samples) * ||y - Xw||^2_2
        + alpha * l1_ratio * ||w||_1
        + 0.5 * alpha * (1 - l1_ratio) * ||w||^2_2

    For multi-output tasks it is::

        (1 / (2 * n_samples)) * ||Y - XW||_Fro^2
        + alpha * l1_ratio * ||W||_21
        + 0.5 * alpha * (1 - l1_ratio) * ||W||_Fro^2

    Where::

        ||W||_21 = \\sum_i \\sqrt{\\sum_j w_{ij}^2}

    i.e. the sum of norm of each row.

    Read more in the :ref:`User Guide &lt;elastic_net&gt;`.

    Parameters
    ----------
    X : {array-like, sparse matrix} of shape (n_samples, n_features)
        Training data. Pass directly as Fortran-contiguous data to avoid
        unnecessary memory duplication. If ``y`` is mono-output then ``X``
        can be sparse.

    y : {array-like, sparse matrix} of shape (n_samples,) or \
        (n_samples, n_outputs)
        Target values.

    l1_ratio : float, default=0.5
        Number between 0 and 1 passed to elastic net (scaling between
        l1 and l2 penalties). ``l1_ratio=1`` corresponds to the Lasso.

    eps : float, default=1e-3
        Length of the path. ``eps=1e-3`` means that
        ``alpha_min / alpha_max = 1e-3``.

    n_alphas : int, default=100
        Number of alphas along the regularization path.

    alphas : ndarray, default=None
        List of alphas where to compute the models.
        If None alphas are set automatically.

    precompute : 'auto', bool or array-like of shape (n_features, n_features),\
                 default='auto'
        Whether to use a precomputed Gram matrix to speed up
        calculations. If set to ``'auto'`` let us decide. The Gram
        matrix can also be passed as argument.

    Xy : array-like of shape (n_features,) or (n_features, n_outputs),\
         default=None
        Xy = np.dot(X.T, y) that can be precomputed. It is useful
        only when the Gram matrix is precomputed.

    copy_X : bool, default=True
        If ``True``, X will be copied; else, it may be overwritten.

    coef_init : ndarray of shape (n_features, ), default=None
        The initial values of the coefficients.

    verbose : bool or int, default=False
        Amount of verbosity.

    return_n_iter : bool, default=False
        Whether to return the number of iterations or not.

    positive : bool, default=False
        If set to True, forces coefficients to be positive.
        (Only allowed when ``y.ndim == 1``).

    check_input : bool, default=True
        If set to False, the input validation checks are skipped (including the
        Gram matrix when provided). It is assumed that they are handled
        by the caller.

    **params : kwargs
        Keyword arguments passed to the coordinate descent solver.

    Returns
    -------
    alphas : ndarray of shape (n_alphas,)
        The alphas along the path where models are computed.

    coefs : ndarray of shape (n_features, n_alphas) or \
            (n_outputs, n_features, n_alphas)
        Coefficients along the path.

    dual_gaps : ndarray of shape (n_alphas,)
        The dual gaps at the end of the optimization for each alpha.

    n_iters : list of int
        The number of iterations taken by the coordinate descent optimizer to
        reach the specified tolerance for each alpha.
        (Is returned when ``return_n_iter`` is set to True).

    See Also
    --------
    MultiTaskElasticNet
    MultiTaskElasticNetCV
    ElasticNet
    ElasticNetCV

    Notes
    -----
    For an example, see
    :ref:`examples/linear_model/plot_lasso_coordinate_descent_path.py
    &lt;sphx_glr_auto_examples_linear_model_plot_lasso_coordinate_descent_path.py&gt;`.
    """</span>
    <span class="comment"># We expect X and y to be already Fortran ordered when bypassing</span>
    <span class="comment"># checks</span>
    <span class="keyword">if</span> <span class="identifier">check_input</span><span class="punctuation">:</span>
        <span class="identifier">X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csc'</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="punctuation">,</span>
                        <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'F'</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="identifier">copy_X</span><span class="grouping">)</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csc'</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">.</span><span class="identifier">type</span><span class="punctuation">,</span>
                        <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'F'</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">Xy</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="comment"># Xy should be a 1d contiguous array or a 2D C ordered array</span>
            <span class="identifier">Xy</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">Xy</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">.</span><span class="identifier">type</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'C'</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                             <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>

    <span class="identifier">multi_output</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
    <span class="keyword">if</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">!=</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="identifier">multi_output</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">True</span>
        <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">n_outputs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span>

    <span class="keyword">if</span> <span class="identifier">multi_output</span> <span class="logical-operator">and</span> <span class="identifier">positive</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'positive=True is not allowed for multi-output'</span>
                         <span class="string-literal">' (y.ndim != 1)'</span><span class="grouping">)</span>

    <span class="comment"># MultiTaskElasticNet does not support sparse matrices</span>
    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">multi_output</span> <span class="logical-operator">and</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">isspmatrix</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="string-literal">'X_offset'</span> <span class="relational-operator">in</span> <span class="identifier">params</span><span class="punctuation">:</span>
            <span class="comment"># As sparse matrices are not actually centered we need this</span>
            <span class="comment"># to be passed to the CD solver.</span>
            <span class="identifier">X_sparse_scaling</span> <span class="arithmetic-assignment">=</span> <span class="identifier">params</span><span class="grouping">[</span><span class="string-literal">'X_offset'] / params['X_scale'</span><span class="grouping">]</span>
            <span class="identifier">X_sparse_scaling</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">X_sparse_scaling</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">X_sparse_scaling</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">n_features</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

    <span class="comment"># X should be normalized and fit already if function is called</span>
    <span class="comment"># from ElasticNet.fit</span>
    <span class="keyword">if</span> <span class="identifier">check_input</span><span class="punctuation">:</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">X_offset</span><span class="punctuation">,</span> <span class="identifier">y_offset</span><span class="punctuation">,</span> <span class="identifier">X_scale</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">Xy</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
            <span class="identifier">_pre_fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                     <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">check_input</span><span class="arithmetic-assignment">=</span><span class="identifier">check_input</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">alphas</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="comment"># No need to normalize of fit_intercept: it has been done</span>
        <span class="comment"># above</span>
        <span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_alpha_grid</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="identifier">Xy</span><span class="punctuation">,</span> <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="identifier">l1_ratio</span><span class="punctuation">,</span>
                             <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="arithmetic-assignment">=</span><span class="identifier">n_alphas</span><span class="punctuation">,</span>
                             <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sort</span><span class="grouping">(</span><span class="identifier">alphas</span><span class="grouping">)</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span>  <span class="comment"># make sure alphas are properly ordered</span>

    <span class="identifier">n_alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">alphas</span><span class="grouping">)</span>
    <span class="identifier">tol</span> <span class="arithmetic-assignment">=</span> <span class="identifier">params</span><span class="punctuation">.</span><span class="identifier">get</span><span class="grouping">(</span><span class="string-literal">'tol'</span><span class="punctuation">,</span> <span class="float-literal">1e-4</span><span class="grouping">)</span>
    <span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">params</span><span class="punctuation">.</span><span class="identifier">get</span><span class="grouping">(</span><span class="string-literal">'max_iter'</span><span class="punctuation">,</span> <span class="int-literal">1000</span><span class="grouping">)</span>
    <span class="identifier">dual_gaps</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">n_alphas</span><span class="grouping">)</span>
    <span class="identifier">n_iters</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>

    <span class="identifier">rng</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">params</span><span class="punctuation">.</span><span class="identifier">get</span><span class="grouping">(</span><span class="string-literal">'random_state'</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="identifier">selection</span> <span class="arithmetic-assignment">=</span> <span class="identifier">params</span><span class="punctuation">.</span><span class="identifier">get</span><span class="grouping">(</span><span class="string-literal">'selection', 'cyclic'</span><span class="grouping">)</span>
    <span class="keyword">if</span> <span class="identifier">selection</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="string-literal">'random', 'cyclic'</span><span class="grouping">]</span><span class="punctuation">:</span>
        <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"selection should be either random or cyclic."</span><span class="grouping">)</span>
    <span class="identifier">random</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">selection</span> <span class="relational-operator">==</span> <span class="string-literal">'random'</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">multi_output</span><span class="punctuation">:</span>
        <span class="identifier">coefs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">n_features</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">coefs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">n_outputs</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="grouping">)</span><span class="punctuation">,</span>
                         <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="identifier">coef_init</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
        <span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">coefs</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'F'</span><span class="grouping">)</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">n</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">coef_init</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

    <span class="keyword">for</span> <span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">alpha</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">alphas</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># account for n_samples scaling in objectives between here and cd_fast</span>
        <span class="identifier">l1_reg</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha</span> <span class="arithmetic-operator">*</span> <span class="identifier">l1_ratio</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_samples</span>
        <span class="identifier">l2_reg</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="float-literal">1.0</span> <span class="arithmetic-operator">-</span> <span class="identifier">l1_ratio</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_samples</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">multi_output</span> <span class="logical-operator">and</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">isspmatrix</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">model</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cd_fast</span><span class="punctuation">.</span><span class="identifier">sparse_enet_coordinate_descent</span><span class="grouping">(</span>
                <span class="identifier">coef_</span><span class="punctuation">,</span> <span class="identifier">l1_reg</span><span class="punctuation">,</span> <span class="identifier">l2_reg</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">data</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">indices</span><span class="punctuation">,</span>
                <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">indptr</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">X_sparse_scaling</span><span class="punctuation">,</span>
                <span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">rng</span><span class="punctuation">,</span> <span class="identifier">random</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">multi_output</span><span class="punctuation">:</span>
            <span class="identifier">model</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cd_fast</span><span class="punctuation">.</span><span class="identifier">enet_coordinate_descent_multi_task</span><span class="grouping">(</span>
                <span class="identifier">coef_</span><span class="punctuation">,</span> <span class="identifier">l1_reg</span><span class="punctuation">,</span> <span class="identifier">l2_reg</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">rng</span><span class="punctuation">,</span> <span class="identifier">random</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ndarray</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># We expect precompute to be already Fortran ordered when bypassing</span>
            <span class="comment"># checks</span>
            <span class="keyword">if</span> <span class="identifier">check_input</span><span class="punctuation">:</span>
                <span class="identifier">precompute</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">.</span><span class="identifier">type</span><span class="punctuation">,</span>
                                         <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'C'</span><span class="grouping">)</span>
            <span class="identifier">model</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cd_fast</span><span class="punctuation">.</span><span class="identifier">enet_coordinate_descent_gram</span><span class="grouping">(</span>
                <span class="identifier">coef_</span><span class="punctuation">,</span> <span class="identifier">l1_reg</span><span class="punctuation">,</span> <span class="identifier">l2_reg</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="punctuation">,</span>
                <span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">rng</span><span class="punctuation">,</span> <span class="identifier">random</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="grouping">)</span>
        <span class="keyword">elif</span> <span class="identifier">precompute</span> <span class="relational-operator">is</span> <span class="bool-literal">False</span><span class="punctuation">:</span>
            <span class="identifier">model</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cd_fast</span><span class="punctuation">.</span><span class="identifier">enet_coordinate_descent</span><span class="grouping">(</span>
                <span class="identifier">coef_</span><span class="punctuation">,</span> <span class="identifier">l1_reg</span><span class="punctuation">,</span> <span class="identifier">l2_reg</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">rng</span><span class="punctuation">,</span> <span class="identifier">random</span><span class="punctuation">,</span>
                <span class="identifier">positive</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Precompute should be one of True, False, "</span>
                             <span class="string-literal">"'auto' or array-like. Got %r"</span> <span class="arithmetic-operator">%</span> <span class="identifier">precompute</span><span class="grouping">)</span>
        <span class="identifier">coef_</span><span class="punctuation">,</span> <span class="identifier">dual_gap_</span><span class="punctuation">,</span> <span class="identifier">eps_</span><span class="punctuation">,</span> <span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">model</span>
        <span class="identifier">coefs</span><span class="grouping">[</span><span class="punctuation">.</span><span class="punctuation">.</span><span class="punctuation">.</span><span class="punctuation">,</span> <span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coef_</span>
        <span class="comment"># we correct the scale of the returned dual gap, as the objective</span>
        <span class="comment"># in cd_fast is n_samples * the objective in this docstring.</span>
        <span class="identifier">dual_gaps</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dual_gap_</span> <span class="arithmetic-operator">/</span> <span class="identifier">n_samples</span>
        <span class="identifier">n_iters</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">n_iter_</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">verbose</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">verbose</span> <span class="relational-operator">&gt;</span> <span class="int-literal">2</span><span class="punctuation">:</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="identifier">model</span><span class="grouping">)</span>
            <span class="keyword">elif</span> <span class="identifier">verbose</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">'Path: %03i out of %03i'</span> <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">i</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">sys</span><span class="punctuation">.</span><span class="identifier">stderr</span><span class="punctuation">.</span><span class="identifier">write</span><span class="grouping">(</span><span class="string-literal">'.'</span><span class="grouping">)</span>

    <span class="keyword">if</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">alphas</span><span class="punctuation">,</span> <span class="identifier">coefs</span><span class="punctuation">,</span> <span class="identifier">dual_gaps</span><span class="punctuation">,</span> <span class="identifier">n_iters</span>
    <span class="keyword">return</span> <span class="identifier">alphas</span><span class="punctuation">,</span> <span class="identifier">coefs</span><span class="punctuation">,</span> <span class="identifier">dual_gaps</span>


<span class="comment">###############################################################################</span>
<span class="comment"># ElasticNet model</span>


<span class="keyword">class</span> <span class="identifier">ElasticNet</span><span class="grouping">(</span><span class="identifier">MultiOutputMixin</span><span class="punctuation">,</span> <span class="identifier">RegressorMixin</span><span class="punctuation">,</span> <span class="identifier">LinearModel</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Linear regression with combined L1 and L2 priors as regularizer.

    Minimizes the objective function::

            1 / (2 * n_samples) * ||y - Xw||^2_2
            + alpha * l1_ratio * ||w||_1
            + 0.5 * alpha * (1 - l1_ratio) * ||w||^2_2

    If you are interested in controlling the L1 and L2 penalty
    separately, keep in mind that this is equivalent to::

            a * ||w||_1 + 0.5 * b * ||w||_2^2

    where::

            alpha = a + b and l1_ratio = a / (a + b)

    The parameter l1_ratio corresponds to alpha in the glmnet R package while
    alpha corresponds to the lambda parameter in glmnet. Specifically, l1_ratio
    = 1 is the lasso penalty. Currently, l1_ratio &lt;= 0.01 is not reliable,
    unless you supply your own sequence of alpha.

    Read more in the :ref:`User Guide &lt;elastic_net&gt;`.

    Parameters
    ----------
    alpha : float, default=1.0
        Constant that multiplies the penalty terms. Defaults to 1.0.
        See the notes for the exact mathematical meaning of this
        parameter. ``alpha = 0`` is equivalent to an ordinary least square,
        solved by the :class:`LinearRegression` object. For numerical
        reasons, using ``alpha = 0`` with the ``Lasso`` object is not advised.
        Given this, you should use the :class:`LinearRegression` object.

    l1_ratio : float, default=0.5
        The ElasticNet mixing parameter, with ``0 &lt;= l1_ratio &lt;= 1``. For
        ``l1_ratio = 0`` the penalty is an L2 penalty. ``For l1_ratio = 1`` it
        is an L1 penalty.  For ``0 &lt; l1_ratio &lt; 1``, the penalty is a
        combination of L1 and L2.

    fit_intercept : bool, default=True
        Whether the intercept should be estimated or not. If ``False``, the
        data is assumed to be already centered.

    normalize : bool, default=False
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

    precompute : bool or array-like of shape (n_features, n_features),\
                 default=False
        Whether to use a precomputed Gram matrix to speed up
        calculations. The Gram matrix can also be passed as argument.
        For sparse input this option is always ``False`` to preserve sparsity.

    max_iter : int, default=1000
        The maximum number of iterations.

    copy_X : bool, default=True
        If ``True``, X will be copied; else, it may be overwritten.

    tol : float, default=1e-4
        The tolerance for the optimization: if the updates are
        smaller than ``tol``, the optimization code checks the
        dual gap for optimality and continues until it is smaller
        than ``tol``.

    warm_start : bool, default=False
        When set to ``True``, reuse the solution of the previous call to fit as
        initialization, otherwise, just erase the previous solution.
        See :term:`the Glossary &lt;warm_start&gt;`.

    positive : bool, default=False
        When set to ``True``, forces the coefficients to be positive.

    random_state : int, RandomState instance, default=None
        The seed of the pseudo random number generator that selects a random
        feature to update. Used when ``selection`` == 'random'.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    selection : {'cyclic', 'random'}, default='cyclic'
        If set to 'random', a random coefficient is updated every iteration
        rather than looping over features sequentially by default. This
        (setting to 'random') often leads to significantly faster convergence
        especially when tol is higher than 1e-4.

    Attributes
    ----------
    coef_ : ndarray of shape (n_features,) or (n_targets, n_features)
        Parameter vector (w in the cost function formula).

    sparse_coef_ : sparse matrix of shape (n_features,) or \
            (n_tasks, n_features)
        Sparse representation of the `coef_`.

    intercept_ : float or ndarray of shape (n_targets,)
        Independent term in decision function.

    n_iter_ : list of int
        Number of iterations run by the coordinate descent solver to reach
        the specified tolerance.

    dual_gap_ : float or ndarray of shape (n_targets,)
        Given param alpha, the dual gaps at the end of the optimization,
        same shape as each observation of y.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.linear_model import ElasticNet
    &gt;&gt;&gt; from sklearn.datasets import make_regression

    &gt;&gt;&gt; X, y = make_regression(n_features=2, random_state=0)
    &gt;&gt;&gt; regr = ElasticNet(random_state=0)
    &gt;&gt;&gt; regr.fit(X, y)
    ElasticNet(random_state=0)
    &gt;&gt;&gt; print(regr.coef_)
    [18.83816048 64.55968825]
    &gt;&gt;&gt; print(regr.intercept_)
    1.451...
    &gt;&gt;&gt; print(regr.predict([[0, 0]]))
    [1.451...]


    Notes
    -----
    To avoid unnecessary memory duplication the X argument of the fit method
    should be directly passed as a Fortran-contiguous numpy array.

    See Also
    --------
    ElasticNetCV : Elastic net model with best model selection by
        cross-validation.
    SGDRegressor : Implements elastic net regression with incremental training.
    SGDClassifier : Implements logistic regression with elastic net penalty
        (``SGDClassifier(loss="log", penalty="elasticnet")``).
    """</span>
    <span class="identifier">path</span> <span class="arithmetic-assignment">=</span> <span class="identifier">staticmethod</span><span class="grouping">(</span><span class="identifier">enet_path</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="float-literal">1.0</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.5</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">1000</span><span class="punctuation">,</span>
                 <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span> <span class="identifier">warm_start</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                 <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">selection</span><span class="arithmetic-assignment">=</span><span class="string-literal">'cyclic'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l1_ratio</span> <span class="arithmetic-assignment">=</span> <span class="identifier">l1_ratio</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_intercept</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">normalize</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">precompute</span> <span class="arithmetic-assignment">=</span> <span class="identifier">precompute</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy_X</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span> <span class="arithmetic-assignment">=</span> <span class="identifier">tol</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">warm_start</span> <span class="arithmetic-assignment">=</span> <span class="identifier">warm_start</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">positive</span> <span class="arithmetic-assignment">=</span> <span class="identifier">positive</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">selection</span> <span class="arithmetic-assignment">=</span> <span class="identifier">selection</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">check_input</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit model with coordinate descent.

        Parameters
        ----------
        X : {ndarray, sparse matrix} of (n_samples, n_features)
            Data.

        y : {ndarray, sparse matrix} of shape (n_samples,) or \
            (n_samples, n_targets)
            Target. Will be cast to X's dtype if necessary.

        sample_weight : float or array-like of shape (n_samples,), default=None
            Sample weight. Internally, the `sample_weight` vector will be
            rescaled to sum to `n_samples`.

            .. versionadded:: 0.23

        check_input : bool, default=True
            Allow to bypass several input checking.
            Don't use this parameter unless you know what you do.

        Notes
        -----

        Coordinate descent is an algorithm that considers each column of
        data at a time hence it will automatically convert the X input
        as a Fortran-contiguous numpy array if necessary.

        To avoid memory re-allocation it is advised to allocate the
        initial data in memory directly using that format.
        """</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span><span class="string-literal">"With alpha=0, this algorithm does not converge "</span>
                          <span class="string-literal">"well. You are advised to use the LinearRegression "</span>
                          <span class="string-literal">"estimator"</span><span class="punctuation">,</span> <span class="identifier">stacklevel</span><span class="arithmetic-assignment">=</span><span class="int-literal">2</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'precompute should be one of True, False or'</span>
                             <span class="string-literal">' array-like. Got %r'</span> <span class="arithmetic-operator">%</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">precompute</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="grouping">(</span><span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l1_ratio</span><span class="punctuation">,</span> <span class="identifier">numbers</span><span class="punctuation">.</span><span class="identifier">Number</span><span class="grouping">)</span> <span class="logical-operator">or</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l1_ratio</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span> <span class="logical-operator">or</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l1_ratio</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"l1_ratio must be between 0 and 1; "</span>
                             <span class="identifier">f</span><span class="string-literal">"got l1_ratio={self.l1_ratio}"</span><span class="grouping">)</span>

        <span class="comment"># Remember if X is copied</span>
        <span class="identifier">X_copied</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
        <span class="comment"># We expect X and y to be float64 or float32 Fortran ordered arrays</span>
        <span class="comment"># when bypassing checks</span>
        <span class="keyword">if</span> <span class="identifier">check_input</span><span class="punctuation">:</span>
            <span class="identifier">X_copied</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csc'</span><span class="punctuation">,</span>
                                       <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'F'</span><span class="punctuation">,</span>
                                       <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="punctuation">,</span>
                                       <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="identifier">X_copied</span><span class="punctuation">,</span> <span class="identifier">multi_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                                       <span class="identifier">y_numeric</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
            <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'F'</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">.</span><span class="identifier">type</span><span class="punctuation">,</span>
                            <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

        <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>
        <span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha</span>

        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">numbers</span><span class="punctuation">.</span><span class="identifier">Number</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
        <span class="keyword">if</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">check_input</span><span class="punctuation">:</span>
                <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Sample weights do not (yet) support "</span>
                                     <span class="string-literal">"sparse matrices."</span><span class="grouping">)</span>
                <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_sample_weight</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span>
                                                     <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
            <span class="comment"># simplify things by rescaling sw to sum up to n_samples</span>
            <span class="comment"># =&gt; np.average(x, weights=sw) = np.mean(sw * x)</span>
            <span class="identifier">sample_weight</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sample_weight</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="identifier">n_samples</span> <span class="arithmetic-operator">/</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">sample_weight</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="comment"># Objective function is:</span>
            <span class="comment"># 1/2 * np.average(squared error, weights=sw) + alpha * penalty</span>
            <span class="comment"># but coordinate descent minimizes:</span>
            <span class="comment"># 1/2 * sum(squared error) + alpha * penalty</span>
            <span class="comment"># enet_path therefore sets alpha = n_samples * alpha</span>
            <span class="comment"># With sw, enet_path should set alpha = sum(sw) * alpha</span>
            <span class="comment"># Therefore, we rescale alpha = sum(sw) / n_samples * alpha</span>
            <span class="comment"># Note: As we rescaled sample_weights to sum up to n_samples,</span>
            <span class="comment">#       we don't need this</span>
            <span class="comment"># alpha *= np.sum(sample_weight) / n_samples</span>

        <span class="comment"># Ensure copying happens only once, don't do it again if done above.</span>
        <span class="comment"># X and y will be rescaled if sample_weight is not None, order='F'</span>
        <span class="comment"># ensures that the returned X and y are still F-contiguous.</span>
        <span class="identifier">should_copy</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="logical-operator">and</span> <span class="logical-operator">not</span> <span class="identifier">X_copied</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">X_offset</span><span class="punctuation">,</span> <span class="identifier">y_offset</span><span class="punctuation">,</span> <span class="identifier">X_scale</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">Xy</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
            <span class="identifier">_pre_fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span><span class="punctuation">,</span>
                     <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="identifier">should_copy</span><span class="punctuation">,</span>
                     <span class="identifier">check_input</span><span class="arithmetic-assignment">=</span><span class="identifier">check_input</span><span class="punctuation">,</span> <span class="identifier">sample_weight</span><span class="arithmetic-assignment">=</span><span class="identifier">sample_weight</span><span class="grouping">)</span>
        <span class="comment"># coordinate descent needs F-ordered arrays and _pre_fit might have</span>
        <span class="comment"># called _rescale_data</span>
        <span class="keyword">if</span> <span class="identifier">check_input</span> <span class="logical-operator">or</span> <span class="identifier">sample_weight</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_set_order</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'F'</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
        <span class="keyword">if</span> <span class="identifier">Xy</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span> <span class="logical-operator">and</span> <span class="identifier">Xy</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">Xy</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Xy</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>

        <span class="identifier">n_targets</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">selection</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="string-literal">'cyclic', 'random'</span><span class="grouping">]</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"selection should be either random or cyclic."</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">warm_start</span> <span class="logical-operator">or</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">"coef_"</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">n_targets</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">,</span>
                             <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'F'</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span>
            <span class="keyword">if</span> <span class="identifier">coef_</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coef_</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span>

        <span class="identifier">dual_gaps_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="identifier">n_targets</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>

        <span class="keyword">for</span> <span class="identifier">k</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_targets</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">Xy</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                <span class="identifier">this_Xy</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Xy</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">k</span><span class="grouping">]</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">this_Xy</span> <span class="arithmetic-assignment">=</span> <span class="none-literal">None</span>
            <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">this_coef</span><span class="punctuation">,</span> <span class="identifier">this_dual_gap</span><span class="punctuation">,</span> <span class="identifier">this_iter</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">path</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">k</span><span class="grouping">]</span><span class="punctuation">,</span>
                          <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l1_ratio</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                          <span class="identifier">n_alphas</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">alpha</span><span class="grouping">]</span><span class="punctuation">,</span>
                          <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">Xy</span><span class="arithmetic-assignment">=</span><span class="identifier">this_Xy</span><span class="punctuation">,</span>
                          <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                          <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">positive</span><span class="punctuation">,</span>
                          <span class="identifier">X_offset</span><span class="arithmetic-assignment">=</span><span class="identifier">X_offset</span><span class="punctuation">,</span> <span class="identifier">X_scale</span><span class="arithmetic-assignment">=</span><span class="identifier">X_scale</span><span class="punctuation">,</span>
                          <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">i</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">coef_init</span><span class="arithmetic-assignment">=</span><span class="identifier">coef_</span><span class="grouping">[</span><span class="identifier">k</span><span class="grouping">]</span><span class="punctuation">,</span>
                          <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="punctuation">,</span>
                          <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="punctuation">,</span>
                          <span class="identifier">selection</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">selection</span><span class="punctuation">,</span>
                          <span class="identifier">check_input</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
            <span class="identifier">coef_</span><span class="grouping">[</span><span class="identifier">k</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">this_coef</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="int-literal">0</span><span class="grouping">]</span>
            <span class="identifier">dual_gaps_</span><span class="grouping">[</span><span class="identifier">k</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">this_dual_gap</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span><span class="punctuation">.</span><span class="identifier">append</span><span class="grouping">(</span><span class="identifier">this_iter</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">n_targets</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coef_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dual_gap_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dual_gaps_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coef_</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dual_gap_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dual_gaps_</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_set_intercept</span><span class="grouping">(</span><span class="identifier">X_offset</span><span class="punctuation">,</span> <span class="identifier">y_offset</span><span class="punctuation">,</span> <span class="identifier">X_scale</span><span class="grouping">)</span>

        <span class="comment"># workaround since _set_intercept will cast self.coef_ into X.dtype</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="comment"># return self for chaining fit and predict calls</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">sparse_coef_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Sparse representation of the fitted `coef_`."""</span>
        <span class="keyword">return</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">csr_matrix</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_decision_function</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Decision function of the linear model.

        Parameters
        ----------
        X : numpy array or scipy.sparse matrix of shape (n_samples, n_features)

        Returns
        -------
        T : ndarray of shape (n_samples,)
            The predicted decision function.
        """</span>
        <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">isspmatrix</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span><span class="punctuation">.</span><span class="identifier">T</span><span class="punctuation">,</span>
                                   <span class="identifier">dense_output</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span> <span class="arithmetic-operator">+</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">intercept_</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">_decision_function</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>


<span class="comment">###############################################################################</span>
<span class="comment"># Lasso model</span>

<span class="keyword">class</span> <span class="identifier">Lasso</span><span class="grouping">(</span><span class="identifier">ElasticNet</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Linear Model trained with L1 prior as regularizer (aka the Lasso)

    The optimization objective for Lasso is::

        (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1

    Technically the Lasso model is optimizing the same objective function as
    the Elastic Net with ``l1_ratio=1.0`` (no L2 penalty).

    Read more in the :ref:`User Guide &lt;lasso&gt;`.

    Parameters
    ----------
    alpha : float, default=1.0
        Constant that multiplies the L1 term. Defaults to 1.0.
        ``alpha = 0`` is equivalent to an ordinary least square, solved
        by the :class:`LinearRegression` object. For numerical
        reasons, using ``alpha = 0`` with the ``Lasso`` object is not advised.
        Given this, you should use the :class:`LinearRegression` object.

    fit_intercept : bool, default=True
        Whether to calculate the intercept for this model. If set
        to False, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    normalize : bool, default=False
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

    precompute : bool or array-like of shape (n_features, n_features),\
                 default=False
        Whether to use a precomputed Gram matrix to speed up
        calculations. The Gram matrix can also be passed as argument.
        For sparse input this option is always ``False`` to preserve sparsity.

    copy_X : bool, default=True
        If ``True``, X will be copied; else, it may be overwritten.

    max_iter : int, default=1000
        The maximum number of iterations.

    tol : float, default=1e-4
        The tolerance for the optimization: if the updates are
        smaller than ``tol``, the optimization code checks the
        dual gap for optimality and continues until it is smaller
        than ``tol``.

    warm_start : bool, default=False
        When set to True, reuse the solution of the previous call to fit as
        initialization, otherwise, just erase the previous solution.
        See :term:`the Glossary &lt;warm_start&gt;`.

    positive : bool, default=False
        When set to ``True``, forces the coefficients to be positive.

    random_state : int, RandomState instance, default=None
        The seed of the pseudo random number generator that selects a random
        feature to update. Used when ``selection`` == 'random'.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    selection : {'cyclic', 'random'}, default='cyclic'
        If set to 'random', a random coefficient is updated every iteration
        rather than looping over features sequentially by default. This
        (setting to 'random') often leads to significantly faster convergence
        especially when tol is higher than 1e-4.

    Attributes
    ----------
    coef_ : ndarray of shape (n_features,) or (n_targets, n_features)
        Parameter vector (w in the cost function formula).

    dual_gap_ : float or ndarray of shape (n_targets,)
        Given param alpha, the dual gaps at the end of the optimization,
        same shape as each observation of y.

    sparse_coef_ : sparse matrix of shape (n_features, 1) or \
            (n_targets, n_features)
        Readonly property derived from ``coef_``.

    intercept_ : float or ndarray of shape (n_targets,)
        Independent term in decision function.

    n_iter_ : int or list of int
        Number of iterations run by the coordinate descent solver to reach
        the specified tolerance.

    Examples
    --------
    &gt;&gt;&gt; from sklearn import linear_model
    &gt;&gt;&gt; clf = linear_model.Lasso(alpha=0.1)
    &gt;&gt;&gt; clf.fit([[0,0], [1, 1], [2, 2]], [0, 1, 2])
    Lasso(alpha=0.1)
    &gt;&gt;&gt; print(clf.coef_)
    [0.85 0.  ]
    &gt;&gt;&gt; print(clf.intercept_)
    0.15...

    See Also
    --------
    lars_path
    lasso_path
    LassoLars
    LassoCV
    LassoLarsCV
    sklearn.decomposition.sparse_encode

    Notes
    -----
    The algorithm used to fit the model is coordinate descent.

    To avoid unnecessary memory duplication the X argument of the fit method
    should be directly passed as a Fortran-contiguous numpy array.
    """</span>
    <span class="identifier">path</span> <span class="arithmetic-assignment">=</span> <span class="identifier">staticmethod</span><span class="grouping">(</span><span class="identifier">enet_path</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="float-literal">1.0</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                 <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">1000</span><span class="punctuation">,</span>
                 <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span> <span class="identifier">warm_start</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                 <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">selection</span><span class="arithmetic-assignment">=</span><span class="string-literal">'cyclic'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="identifier">alpha</span><span class="punctuation">,</span> <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="float-literal">1.0</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span>
            <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="identifier">normalize</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="identifier">copy_X</span><span class="punctuation">,</span>
            <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">warm_start</span><span class="arithmetic-assignment">=</span><span class="identifier">warm_start</span><span class="punctuation">,</span>
            <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="identifier">positive</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="punctuation">,</span>
            <span class="identifier">selection</span><span class="arithmetic-assignment">=</span><span class="identifier">selection</span><span class="grouping">)</span>


<span class="comment">###############################################################################</span>
<span class="comment"># Functions for CV with paths functions</span>

<span class="keyword">def</span> <span class="identifier">_path_residuals</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span><span class="punctuation">,</span> <span class="identifier">path</span><span class="punctuation">,</span> <span class="identifier">path_params</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                    <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">X_order</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Returns the MSE for the models computed by 'path'.

    Parameters
    ----------
    X : {array-like, sparse matrix} of shape (n_samples, n_features)
        Training data.

    y : array-like of shape (n_samples,) or (n_samples, n_targets)
        Target values.

    train : list of indices
        The indices of the train set.

    test : list of indices
        The indices of the test set.

    path : callable
        Function returning a list of models on the path. See
        enet_path for an example of signature.

    path_params : dictionary
        Parameters passed to the path function.

    alphas : array-like, default=None
        Array of float that is used for cross-validation. If not
        provided, computed using 'path'.

    l1_ratio : float, default=1
        float between 0 and 1 passed to ElasticNet (scaling between
        l1 and l2 penalties). For ``l1_ratio = 0`` the penalty is an
        L2 penalty. For ``l1_ratio = 1`` it is an L1 penalty. For ``0
        &lt; l1_ratio &lt; 1``, the penalty is a combination of L1 and L2.

    X_order : {'F', 'C'}, default=None
        The order of the arrays expected by the path function to
        avoid memory copies.

    dtype : a numpy dtype, default=None
        The dtype of the arrays expected by the path function to
        avoid memory copies.
    """</span>
    <span class="identifier">X_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">train</span><span class="grouping">]</span>
    <span class="identifier">y_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="grouping">[</span><span class="identifier">train</span><span class="grouping">]</span>
    <span class="identifier">X_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="grouping">[</span><span class="identifier">test</span><span class="grouping">]</span>
    <span class="identifier">y_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="grouping">[</span><span class="identifier">test</span><span class="grouping">]</span>

    <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">issparse</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">for</span> <span class="identifier">array</span><span class="punctuation">,</span> <span class="identifier">array_input</span> <span class="relational-operator">in</span> <span class="grouping">(</span><span class="grouping">(</span><span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">,</span>
                                   <span class="grouping">(</span><span class="identifier">X_test</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">y_test</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">array</span><span class="punctuation">.</span><span class="identifier">base</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="identifier">array_input</span> <span class="logical-operator">and</span> <span class="logical-operator">not</span> <span class="identifier">array</span><span class="punctuation">.</span><span class="identifier">flags</span><span class="grouping">[</span><span class="string-literal">'WRITEABLE'</span><span class="grouping">]</span><span class="punctuation">:</span>
                <span class="comment"># fancy indexing should create a writable copy but it doesn't</span>
                <span class="comment"># for read-only memmaps (cf. numpy#14132).</span>
                <span class="identifier">array</span><span class="punctuation">.</span><span class="identifier">setflags</span><span class="grouping">(</span><span class="identifier">write</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

    <span class="identifier">fit_intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">path_params</span><span class="grouping">[</span><span class="string-literal">'fit_intercept'</span><span class="grouping">]</span>
    <span class="identifier">normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">path_params</span><span class="grouping">[</span><span class="string-literal">'normalize'</span><span class="grouping">]</span>

    <span class="keyword">if</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="identifier">precompute</span> <span class="arithmetic-assignment">=</span> <span class="identifier">path_params</span><span class="grouping">[</span><span class="string-literal">'precompute'</span><span class="grouping">]</span>
    <span class="keyword">else</span><span class="punctuation">:</span>
        <span class="comment"># No Gram variant of multi-task exists right now.</span>
        <span class="comment"># Fall back to default enet_multitask</span>
        <span class="identifier">precompute</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>

    <span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="identifier">X_offset</span><span class="punctuation">,</span> <span class="identifier">y_offset</span><span class="punctuation">,</span> <span class="identifier">X_scale</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">Xy</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
        <span class="identifier">_pre_fit</span><span class="grouping">(</span><span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="punctuation">,</span>
                 <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="identifier">path_params</span> <span class="arithmetic-assignment">=</span> <span class="identifier">path_params</span><span class="punctuation">.</span><span class="identifier">copy</span><span class="grouping">(</span><span class="grouping">)</span>
    <span class="identifier">path_params</span><span class="grouping">[</span><span class="string-literal">'Xy'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Xy</span>
    <span class="identifier">path_params</span><span class="grouping">[</span><span class="string-literal">'X_offset'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_offset</span>
    <span class="identifier">path_params</span><span class="grouping">[</span><span class="string-literal">'X_scale'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_scale</span>
    <span class="identifier">path_params</span><span class="grouping">[</span><span class="string-literal">'precompute'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">precompute</span>
    <span class="identifier">path_params</span><span class="grouping">[</span><span class="string-literal">'copy_X'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
    <span class="identifier">path_params</span><span class="grouping">[</span><span class="string-literal">'alphas'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alphas</span>

    <span class="keyword">if</span> <span class="string-literal">'l1_ratio'</span> <span class="relational-operator">in</span> <span class="identifier">path_params</span><span class="punctuation">:</span>
        <span class="identifier">path_params</span><span class="grouping">[</span><span class="string-literal">'l1_ratio'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">l1_ratio</span>

    <span class="comment"># Do the ordering and type casting here, as if it is done in the path,</span>
    <span class="comment"># X is copied and a reference is kept here</span>
    <span class="identifier">X_train</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_array</span><span class="grouping">(</span><span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csc'</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">dtype</span><span class="punctuation">,</span>
                          <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="identifier">X_order</span><span class="grouping">)</span>
    <span class="identifier">alphas</span><span class="punctuation">,</span> <span class="identifier">coefs</span><span class="punctuation">,</span> <span class="identifier">_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">path</span><span class="grouping">(</span><span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">path_params</span><span class="grouping">)</span>
    <span class="keyword">del</span> <span class="identifier">X_train</span><span class="punctuation">,</span> <span class="identifier">y_train</span>

    <span class="keyword">if</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
        <span class="comment"># Doing this so that it becomes coherent with multioutput.</span>
        <span class="identifier">coefs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">coefs</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="grouping">]</span>
        <span class="identifier">y_offset</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">atleast_1d</span><span class="grouping">(</span><span class="identifier">y_offset</span><span class="grouping">)</span>
        <span class="identifier">y_test</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y_test</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>

    <span class="keyword">if</span> <span class="identifier">normalize</span><span class="punctuation">:</span>
        <span class="identifier">nonzeros</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">flatnonzero</span><span class="grouping">(</span><span class="identifier">X_scale</span><span class="grouping">)</span>
        <span class="identifier">coefs</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">nonzeros</span><span class="grouping">]</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">X_scale</span><span class="grouping">[</span><span class="identifier">nonzeros</span><span class="grouping">]</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>

    <span class="identifier">intercepts</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y_offset</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span> <span class="arithmetic-operator">-</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">dot</span><span class="grouping">(</span><span class="identifier">X_offset</span><span class="punctuation">,</span> <span class="identifier">coefs</span><span class="grouping">)</span>
    <span class="identifier">X_test_coefs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">safe_sparse_dot</span><span class="grouping">(</span><span class="identifier">X_test</span><span class="punctuation">,</span> <span class="identifier">coefs</span><span class="grouping">)</span>
    <span class="identifier">residues</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X_test_coefs</span> <span class="arithmetic-operator">-</span> <span class="identifier">y_test</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span>
    <span class="identifier">residues</span> <span class="arithmetic-assignment">+=</span> <span class="identifier">intercepts</span>
    <span class="identifier">this_mses</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="grouping">(</span><span class="identifier">residues</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="grouping">)</span>

    <span class="keyword">return</span> <span class="identifier">this_mses</span>


<span class="keyword">class</span> <span class="identifier">LinearModelCV</span><span class="grouping">(</span><span class="identifier">MultiOutputMixin</span><span class="punctuation">,</span> <span class="identifier">LinearModel</span><span class="punctuation">,</span> <span class="identifier">metaclass</span><span class="arithmetic-assignment">=</span><span class="identifier">ABCMeta</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Base class for iterative model fitting along a regularization path."""</span>

    <span class="punctuation">@</span><span class="identifier">abstractmethod</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="arithmetic-assignment">=</span><span class="int-literal">100</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">1000</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span>
                 <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">selection</span><span class="arithmetic-assignment">=</span><span class="string-literal">'cyclic'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">eps</span> <span class="arithmetic-assignment">=</span> <span class="identifier">eps</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_alphas</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alphas</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_intercept</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">normalize</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">precompute</span> <span class="arithmetic-assignment">=</span> <span class="identifier">precompute</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span> <span class="arithmetic-assignment">=</span> <span class="identifier">tol</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy_X</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cv</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">verbose</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_jobs</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">positive</span> <span class="arithmetic-assignment">=</span> <span class="identifier">positive</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">selection</span> <span class="arithmetic-assignment">=</span> <span class="identifier">selection</span>

    <span class="punctuation">@</span><span class="identifier">abstractmethod</span>
    <span class="keyword">def</span> <span class="identifier">_get_estimator</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Model to be fitted after the best alpha has been determined."""</span>

    <span class="punctuation">@</span><span class="identifier">abstractmethod</span>
    <span class="keyword">def</span> <span class="identifier">_is_multitask</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Bool indicating if class is meant for multidimensional target."""</span>

    <span class="punctuation">@</span><span class="identifier">staticmethod</span>
    <span class="punctuation">@</span><span class="identifier">abstractmethod</span>
    <span class="keyword">def</span> <span class="identifier">path</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">kwargs</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Compute path with coordinate descent."""</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit linear model with coordinate descent.

        Fit is on grid of alphas and best alpha estimated by cross-validation.

        Parameters
        ----------
        X : {array-like, sparse matrix} of shape (n_samples, n_features)
            Training data. Pass directly as Fortran-contiguous data
            to avoid unnecessary memory duplication. If y is mono-output,
            X can be sparse.

        y : array-like of shape (n_samples,) or (n_samples, n_targets)
            Target values.
        """</span>
        <span class="comment"># This makes sure that there is no duplication in memory.</span>
        <span class="comment"># Dealing right with copy_X is important in the following:</span>
        <span class="comment"># Multiple functions touch X and subsamples of X and can induce a</span>
        <span class="comment"># lot of duplication of memory</span>
        <span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span>

        <span class="identifier">check_y_params</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dict</span><span class="grouping">(</span><span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="punctuation">,</span>
                              <span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ndarray</span><span class="grouping">)</span> <span class="logical-operator">or</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">isspmatrix</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># Keep a reference to X</span>
            <span class="identifier">reference_to_old_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span>
            <span class="comment"># Let us not impose fortran ordering so far: it is</span>
            <span class="comment"># not useful for the cross-validation loop and will be done</span>
            <span class="comment"># by the model fitting itself</span>

            <span class="comment"># Need to validate separately here.</span>
            <span class="comment"># We can't pass multi_ouput=True because that would allow y to be</span>
            <span class="comment"># csr. We also want to allow y to be 64 or 32 but check_X_y only</span>
            <span class="comment"># allows to convert for 64.</span>
            <span class="identifier">check_X_params</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dict</span><span class="grouping">(</span><span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csc'</span><span class="punctuation">,</span>
                                  <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span>
                                       <span class="identifier">validate_separately</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="identifier">check_X_params</span><span class="punctuation">,</span>
                                                            <span class="identifier">check_y_params</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">isspmatrix</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">reference_to_old_X</span><span class="punctuation">,</span> <span class="string-literal">"data"</span><span class="grouping">)</span> <span class="logical-operator">and</span>
                   <span class="logical-operator">not</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">may_share_memory</span><span class="grouping">(</span><span class="identifier">reference_to_old_X</span><span class="punctuation">.</span><span class="identifier">data</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">data</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="comment"># X is a sparse matrix and has been copied</span>
                    <span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
            <span class="keyword">elif</span> <span class="logical-operator">not</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">may_share_memory</span><span class="grouping">(</span><span class="identifier">reference_to_old_X</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="comment"># X has been copied</span>
                <span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
            <span class="keyword">del</span> <span class="identifier">reference_to_old_X</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># Need to validate separately here.</span>
            <span class="comment"># We can't pass multi_ouput=True because that would allow y to be</span>
            <span class="comment"># csr. We also want to allow y to be 64 or 32 but check_X_y only</span>
            <span class="comment"># allows to convert for 64.</span>
            <span class="identifier">check_X_params</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dict</span><span class="grouping">(</span><span class="identifier">accept_sparse</span><span class="arithmetic-assignment">=</span><span class="string-literal">'csc'</span><span class="punctuation">,</span>
                                  <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'F'</span><span class="punctuation">,</span>
                                  <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="identifier">copy_X</span><span class="grouping">)</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span>
                                       <span class="identifier">validate_separately</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="identifier">check_X_params</span><span class="punctuation">,</span>
                                                            <span class="identifier">check_y_params</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>

        <span class="keyword">if</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"y has 0 samples: %r"</span> <span class="arithmetic-operator">%</span> <span class="identifier">y</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_is_multitask</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span> <span class="logical-operator">and</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">1</span><span class="grouping">]</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"For multi-task outputs, use "</span>
                                 <span class="string-literal">"MultiTask%s"</span> <span class="arithmetic-operator">%</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__class__</span><span class="punctuation">.</span><span class="identifier">__name__</span><span class="grouping">)</span>
            <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">column_or_1d</span><span class="grouping">(</span><span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">warn</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">sparse</span><span class="punctuation">.</span><span class="identifier">isspmatrix</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">"X should be dense but a sparse matrix was"</span>
                                <span class="string-literal">"passed"</span><span class="grouping">)</span>
            <span class="keyword">elif</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"For mono-task outputs, use "</span>
                                 <span class="string-literal">"%sCV"</span> <span class="arithmetic-operator">%</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__class__</span><span class="punctuation">.</span><span class="identifier">__name__</span><span class="grouping">[</span><span class="int-literal">9</span><span class="punctuation">:</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="identifier">model</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_get_estimator</span><span class="grouping">(</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">selection</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="string-literal">"random", "cyclic"</span><span class="grouping">]</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"selection should be either random or cyclic."</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span> <span class="relational-operator">!=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"X and y have inconsistent dimensions (%d != %d)"</span>
                             <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="comment"># All LinearModelCV parameters except 'cv' are acceptable</span>
        <span class="identifier">path_params</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">get_params</span><span class="grouping">(</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="string-literal">'l1_ratio'</span> <span class="relational-operator">in</span> <span class="identifier">path_params</span><span class="punctuation">:</span>
            <span class="identifier">l1_ratios</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">atleast_1d</span><span class="grouping">(</span><span class="identifier">path_params</span><span class="grouping">[</span><span class="string-literal">'l1_ratio'</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="comment"># For the first path, we need to set l1_ratio</span>
            <span class="identifier">path_params</span><span class="grouping">[</span><span class="string-literal">'l1_ratio'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">l1_ratios</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">l1_ratios</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="grouping">]</span>
        <span class="identifier">path_params</span><span class="punctuation">.</span><span class="identifier">pop</span><span class="grouping">(</span><span class="string-literal">'cv'</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">)</span>
        <span class="identifier">path_params</span><span class="punctuation">.</span><span class="identifier">pop</span><span class="grouping">(</span><span class="string-literal">'n_jobs'</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">)</span>

        <span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas</span>
        <span class="identifier">n_l1_ratio</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">l1_ratios</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">alphas</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">_alpha_grid</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="identifier">l1_ratio</span><span class="punctuation">,</span>
                                  <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span>
                                  <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_alphas</span><span class="punctuation">,</span>
                                  <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span><span class="grouping">)</span>
                      <span class="keyword">for</span> <span class="identifier">l1_ratio</span> <span class="relational-operator">in</span> <span class="identifier">l1_ratios</span><span class="grouping">]</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="comment"># Making sure alphas is properly ordered.</span>
            <span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">tile</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sort</span><span class="grouping">(</span><span class="identifier">alphas</span><span class="grouping">)</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">n_l1_ratio</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="comment"># We want n_alphas to be the number of alphas used for each l1_ratio.</span>
        <span class="identifier">n_alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">alphas</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="identifier">path_params</span><span class="punctuation">.</span><span class="identifier">update</span><span class="grouping">(</span><span class="grouping">{</span><span class="string-literal">'n_alphas'</span><span class="punctuation">:</span> <span class="identifier">n_alphas</span><span class="grouping">}</span><span class="grouping">)</span>

        <span class="identifier">path_params</span><span class="grouping">[</span><span class="string-literal">'copy_X'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy_X</span>
        <span class="comment"># We are not computing in parallel, we can modify X</span>
        <span class="comment"># inplace in the folds</span>
        <span class="keyword">if</span> <span class="identifier">effective_n_jobs</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span><span class="grouping">)</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="identifier">path_params</span><span class="grouping">[</span><span class="string-literal">'copy_X'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>

        <span class="comment"># init cross-validation generator</span>
        <span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_cv</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span><span class="grouping">)</span>

        <span class="comment"># Compute path for all folds and compute MSE to get the best alpha</span>
        <span class="identifier">folds</span> <span class="arithmetic-assignment">=</span> <span class="identifier">list</span><span class="grouping">(</span><span class="identifier">cv</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">best_mse</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">inf</span>

        <span class="comment"># We do a double for loop folded in one, in order to be able to</span>
        <span class="comment"># iterate in parallel on l1_ratio and folds</span>
        <span class="identifier">jobs</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">(</span><span class="identifier">_path_residuals</span><span class="grouping">)</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">path</span><span class="punctuation">,</span>
                                         <span class="identifier">path_params</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="identifier">this_alphas</span><span class="punctuation">,</span>
                                         <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="identifier">this_l1_ratio</span><span class="punctuation">,</span> <span class="identifier">X_order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'F'</span><span class="punctuation">,</span>
                                         <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">.</span><span class="identifier">type</span><span class="grouping">)</span>
                <span class="keyword">for</span> <span class="identifier">this_l1_ratio</span><span class="punctuation">,</span> <span class="identifier">this_alphas</span> <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">l1_ratios</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="grouping">)</span>
                <span class="keyword">for</span> <span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span> <span class="relational-operator">in</span> <span class="identifier">folds</span><span class="grouping">)</span>
        <span class="identifier">mse_paths</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Parallel</span><span class="grouping">(</span><span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="punctuation">,</span>
                             <span class="arithmetic-operator">**</span><span class="identifier">_joblib_parallel_args</span><span class="grouping">(</span><span class="identifier">prefer</span><span class="arithmetic-assignment">=</span><span class="string-literal">"threads"</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">(</span><span class="identifier">jobs</span><span class="grouping">)</span>
        <span class="identifier">mse_paths</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="identifier">mse_paths</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">n_l1_ratio</span><span class="punctuation">,</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">folds</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">mean_mse</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">mean</span><span class="grouping">(</span><span class="identifier">mse_paths</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">mse_path_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">squeeze</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">rollaxis</span><span class="grouping">(</span><span class="identifier">mse_paths</span><span class="punctuation">,</span> <span class="int-literal">2</span><span class="punctuation">,</span> <span class="int-literal">1</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">l1_ratio</span><span class="punctuation">,</span> <span class="identifier">l1_alphas</span><span class="punctuation">,</span> <span class="identifier">mse_alphas</span> <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">l1_ratios</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="punctuation">,</span>
                                                   <span class="identifier">mean_mse</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">i_best_alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">argmin</span><span class="grouping">(</span><span class="identifier">mse_alphas</span><span class="grouping">)</span>
            <span class="identifier">this_best_mse</span> <span class="arithmetic-assignment">=</span> <span class="identifier">mse_alphas</span><span class="grouping">[</span><span class="identifier">i_best_alpha</span><span class="grouping">]</span>
            <span class="keyword">if</span> <span class="identifier">this_best_mse</span> <span class="relational-operator">&lt;</span> <span class="identifier">best_mse</span><span class="punctuation">:</span>
                <span class="identifier">best_alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">l1_alphas</span><span class="grouping">[</span><span class="identifier">i_best_alpha</span><span class="grouping">]</span>
                <span class="identifier">best_l1_ratio</span> <span class="arithmetic-assignment">=</span> <span class="identifier">l1_ratio</span>
                <span class="identifier">best_mse</span> <span class="arithmetic-assignment">=</span> <span class="identifier">this_best_mse</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l1_ratio_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">best_l1_ratio</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">best_alpha</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">alphas</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">n_l1_ratio</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas_</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span>
        <span class="comment"># Remove duplicate alphas in case alphas is provided.</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">alphas</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="comment"># Refit the model with the parameters selected</span>
        <span class="identifier">common_params</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="identifier">name</span><span class="punctuation">:</span> <span class="identifier">value</span>
                         <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">value</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">get_params</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span>
                         <span class="keyword">if</span> <span class="identifier">name</span> <span class="relational-operator">in</span> <span class="identifier">model</span><span class="punctuation">.</span><span class="identifier">get_params</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">}</span>
        <span class="identifier">model</span><span class="punctuation">.</span><span class="identifier">set_params</span><span class="grouping">(</span><span class="arithmetic-operator">**</span><span class="identifier">common_params</span><span class="grouping">)</span>
        <span class="identifier">model</span><span class="punctuation">.</span><span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">best_alpha</span>
        <span class="identifier">model</span><span class="punctuation">.</span><span class="identifier">l1_ratio</span> <span class="arithmetic-assignment">=</span> <span class="identifier">best_l1_ratio</span>
        <span class="identifier">model</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy_X</span>
        <span class="identifier">precompute</span> <span class="arithmetic-assignment">=</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">"precompute"</span><span class="punctuation">,</span> <span class="none-literal">None</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">precompute</span> <span class="relational-operator">==</span> <span class="string-literal">"auto"</span><span class="punctuation">:</span>
            <span class="identifier">model</span><span class="punctuation">.</span><span class="identifier">precompute</span> <span class="arithmetic-assignment">=</span> <span class="bool-literal">False</span>
        <span class="identifier">model</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">'l1_ratio'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">del</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l1_ratio_</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">model</span><span class="punctuation">.</span><span class="identifier">coef_</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">intercept_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">model</span><span class="punctuation">.</span><span class="identifier">intercept_</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dual_gap_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">model</span><span class="punctuation">.</span><span class="identifier">dual_gap_</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">model</span><span class="punctuation">.</span><span class="identifier">n_iter_</span>
        <span class="keyword">return</span> <span class="identifier">self</span>


<span class="keyword">class</span> <span class="identifier">LassoCV</span><span class="grouping">(</span><span class="identifier">RegressorMixin</span><span class="punctuation">,</span> <span class="identifier">LinearModelCV</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Lasso linear model with iterative fitting along a regularization path.

    See glossary entry for :term:`cross-validation estimator`.

    The best model is selected by cross-validation.

    The optimization objective for Lasso is::

        (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1

    Read more in the :ref:`User Guide &lt;lasso&gt;`.

    Parameters
    ----------
    eps : float, default=1e-3
        Length of the path. ``eps=1e-3`` means that
        ``alpha_min / alpha_max = 1e-3``.

    n_alphas : int, default=100
        Number of alphas along the regularization path.

    alphas : ndarray, default=None
        List of alphas where to compute the models.
        If ``None`` alphas are set automatically.

    fit_intercept : bool, default=True
        Whether to calculate the intercept for this model. If set
        to false, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    normalize : bool, default=False
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

    precompute : 'auto', bool or array-like of shape (n_features, n_features),\
                 default='auto'
        Whether to use a precomputed Gram matrix to speed up
        calculations. If set to ``'auto'`` let us decide. The Gram
        matrix can also be passed as argument.

    max_iter : int, default=1000
        The maximum number of iterations.

    tol : float, default=1e-4
        The tolerance for the optimization: if the updates are
        smaller than ``tol``, the optimization code checks the
        dual gap for optimality and continues until it is smaller
        than ``tol``.

    copy_X : bool, default=True
        If ``True``, X will be copied; else, it may be overwritten.

    cv : int, cross-validation generator or iterable, default=None
        Determines the cross-validation splitting strategy.
        Possible inputs for cv are:

        - None, to use the default 5-fold cross-validation,
        - int, to specify the number of folds.
        - :term:`CV splitter`,
        - An iterable yielding (train, test) splits as arrays of indices.

        For int/None inputs, :class:`KFold` is used.

        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
        cross-validation strategies that can be used here.

        .. versionchanged:: 0.22
            ``cv`` default value if None changed from 3-fold to 5-fold.

    verbose : bool or int, default=False
        Amount of verbosity.

    n_jobs : int, default=None
        Number of CPUs to use during the cross validation.
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

    positive : bool, default=False
        If positive, restrict regression coefficients to be positive.

    random_state : int, RandomState instance, default=None
        The seed of the pseudo random number generator that selects a random
        feature to update. Used when ``selection`` == 'random'.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    selection : {'cyclic', 'random'}, default='cyclic'
        If set to 'random', a random coefficient is updated every iteration
        rather than looping over features sequentially by default. This
        (setting to 'random') often leads to significantly faster convergence
        especially when tol is higher than 1e-4.

    Attributes
    ----------
    alpha_ : float
        The amount of penalization chosen by cross validation.

    coef_ : ndarray of shape (n_features,) or (n_targets, n_features)
        Parameter vector (w in the cost function formula).

    intercept_ : float or ndarray of shape (n_targets,)
        Independent term in decision function.

    mse_path_ : ndarray of shape (n_alphas, n_folds)
        Mean square error for the test set on each fold, varying alpha.

    alphas_ : ndarray of shape (n_alphas,)
        The grid of alphas used for fitting.

    dual_gap_ : float or ndarray of shape (n_targets,)
        The dual gap at the end of the optimization for the optimal alpha
        (``alpha_``).

    n_iter_ : int
        Number of iterations run by the coordinate descent solver to reach
        the specified tolerance for the optimal alpha.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.linear_model import LassoCV
    &gt;&gt;&gt; from sklearn.datasets import make_regression
    &gt;&gt;&gt; X, y = make_regression(noise=4, random_state=0)
    &gt;&gt;&gt; reg = LassoCV(cv=5, random_state=0).fit(X, y)
    &gt;&gt;&gt; reg.score(X, y)
    0.9993...
    &gt;&gt;&gt; reg.predict(X[:1,])
    array([-78.4951...])

    Notes
    -----
    For an example, see
    :ref:`examples/linear_model/plot_lasso_model_selection.py
    &lt;sphx_glr_auto_examples_linear_model_plot_lasso_model_selection.py&gt;`.

    To avoid unnecessary memory duplication the X argument of the fit method
    should be directly passed as a Fortran-contiguous numpy array.

    See Also
    --------
    lars_path
    lasso_path
    LassoLars
    Lasso
    LassoLarsCV
    """</span>
    <span class="identifier">path</span> <span class="arithmetic-assignment">=</span> <span class="identifier">staticmethod</span><span class="grouping">(</span><span class="identifier">lasso_path</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="arithmetic-assignment">=</span><span class="int-literal">100</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">1000</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span>
                 <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">selection</span><span class="arithmetic-assignment">=</span><span class="string-literal">'cyclic'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="arithmetic-assignment">=</span><span class="identifier">n_alphas</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="identifier">alphas</span><span class="punctuation">,</span>
            <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="identifier">normalize</span><span class="punctuation">,</span>
            <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="identifier">precompute</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="identifier">copy_X</span><span class="punctuation">,</span>
            <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">n_jobs</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="identifier">positive</span><span class="punctuation">,</span>
            <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="punctuation">,</span> <span class="identifier">selection</span><span class="arithmetic-assignment">=</span><span class="identifier">selection</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_get_estimator</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">Lasso</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_is_multitask</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="bool-literal">False</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'multioutput'</span><span class="punctuation">:</span> <span class="bool-literal">False</span><span class="grouping">}</span>


<span class="keyword">class</span> <span class="identifier">ElasticNetCV</span><span class="grouping">(</span><span class="identifier">RegressorMixin</span><span class="punctuation">,</span> <span class="identifier">LinearModelCV</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Elastic Net model with iterative fitting along a regularization path.

    See glossary entry for :term:`cross-validation estimator`.

    Read more in the :ref:`User Guide &lt;elastic_net&gt;`.

    Parameters
    ----------
    l1_ratio : float or list of float, default=0.5
        float between 0 and 1 passed to ElasticNet (scaling between
        l1 and l2 penalties). For ``l1_ratio = 0``
        the penalty is an L2 penalty. For ``l1_ratio = 1`` it is an L1 penalty.
        For ``0 &lt; l1_ratio &lt; 1``, the penalty is a combination of L1 and L2
        This parameter can be a list, in which case the different
        values are tested by cross-validation and the one giving the best
        prediction score is used. Note that a good choice of list of
        values for l1_ratio is often to put more values close to 1
        (i.e. Lasso) and less close to 0 (i.e. Ridge), as in ``[.1, .5, .7,
        .9, .95, .99, 1]``.

    eps : float, default=1e-3
        Length of the path. ``eps=1e-3`` means that
        ``alpha_min / alpha_max = 1e-3``.

    n_alphas : int, default=100
        Number of alphas along the regularization path, used for each l1_ratio.

    alphas : ndarray, default=None
        List of alphas where to compute the models.
        If None alphas are set automatically.

    fit_intercept : bool, default=True
        Whether to calculate the intercept for this model. If set
        to false, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    normalize : bool, default=False
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

    precompute : 'auto', bool or array-like of shape (n_features, n_features),\
                 default='auto'
        Whether to use a precomputed Gram matrix to speed up
        calculations. If set to ``'auto'`` let us decide. The Gram
        matrix can also be passed as argument.

    max_iter : int, default=1000
        The maximum number of iterations.

    tol : float, default=1e-4
        The tolerance for the optimization: if the updates are
        smaller than ``tol``, the optimization code checks the
        dual gap for optimality and continues until it is smaller
        than ``tol``.

    cv : int, cross-validation generator or iterable, default=None
        Determines the cross-validation splitting strategy.
        Possible inputs for cv are:

        - None, to use the default 5-fold cross-validation,
        - int, to specify the number of folds.
        - :term:`CV splitter`,
        - An iterable yielding (train, test) splits as arrays of indices.

        For int/None inputs, :class:`KFold` is used.

        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
        cross-validation strategies that can be used here.

        .. versionchanged:: 0.22
            ``cv`` default value if None changed from 3-fold to 5-fold.

    copy_X : bool, default=True
        If ``True``, X will be copied; else, it may be overwritten.

    verbose : bool or int, default=0
        Amount of verbosity.

    n_jobs : int, default=None
        Number of CPUs to use during the cross validation.
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

    positive : bool, default=False
        When set to ``True``, forces the coefficients to be positive.

    random_state : int, RandomState instance, default=None
        The seed of the pseudo random number generator that selects a random
        feature to update. Used when ``selection`` == 'random'.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    selection : {'cyclic', 'random'}, default='cyclic'
        If set to 'random', a random coefficient is updated every iteration
        rather than looping over features sequentially by default. This
        (setting to 'random') often leads to significantly faster convergence
        especially when tol is higher than 1e-4.

    Attributes
    ----------
    alpha_ : float
        The amount of penalization chosen by cross validation.

    l1_ratio_ : float
        The compromise between l1 and l2 penalization chosen by
        cross validation.

    coef_ : ndarray of shape (n_features,) or (n_targets, n_features)
        Parameter vector (w in the cost function formula).

    intercept_ : float or ndarray of shape (n_targets, n_features)
        Independent term in the decision function.

    mse_path_ : ndarray of shape (n_l1_ratio, n_alpha, n_folds)
        Mean square error for the test set on each fold, varying l1_ratio and
        alpha.

    alphas_ : ndarray of shape (n_alphas,) or (n_l1_ratio, n_alphas)
        The grid of alphas used for fitting, for each l1_ratio.

    dual_gap_ : float
        The dual gaps at the end of the optimization for the optimal alpha.

    n_iter_ : int
        Number of iterations run by the coordinate descent solver to reach
        the specified tolerance for the optimal alpha.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.linear_model import ElasticNetCV
    &gt;&gt;&gt; from sklearn.datasets import make_regression

    &gt;&gt;&gt; X, y = make_regression(n_features=2, random_state=0)
    &gt;&gt;&gt; regr = ElasticNetCV(cv=5, random_state=0)
    &gt;&gt;&gt; regr.fit(X, y)
    ElasticNetCV(cv=5, random_state=0)
    &gt;&gt;&gt; print(regr.alpha_)
    0.199...
    &gt;&gt;&gt; print(regr.intercept_)
    0.398...
    &gt;&gt;&gt; print(regr.predict([[0, 0]]))
    [0.398...]


    Notes
    -----
    For an example, see
    :ref:`examples/linear_model/plot_lasso_model_selection.py
    &lt;sphx_glr_auto_examples_linear_model_plot_lasso_model_selection.py&gt;`.

    To avoid unnecessary memory duplication the X argument of the fit method
    should be directly passed as a Fortran-contiguous numpy array.

    The parameter l1_ratio corresponds to alpha in the glmnet R package
    while alpha corresponds to the lambda parameter in glmnet.
    More specifically, the optimization objective is::

        1 / (2 * n_samples) * ||y - Xw||^2_2
        + alpha * l1_ratio * ||w||_1
        + 0.5 * alpha * (1 - l1_ratio) * ||w||^2_2

    If you are interested in controlling the L1 and L2 penalty
    separately, keep in mind that this is equivalent to::

        a * L1 + b * L2

    for::

        alpha = a + b and l1_ratio = a / (a + b).

    See Also
    --------
    enet_path
    ElasticNet

    """</span>
    <span class="identifier">path</span> <span class="arithmetic-assignment">=</span> <span class="identifier">staticmethod</span><span class="grouping">(</span><span class="identifier">enet_path</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.5</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="arithmetic-assignment">=</span><span class="int-literal">100</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">precompute</span><span class="arithmetic-assignment">=</span><span class="string-literal">'auto'</span><span class="punctuation">,</span>
                 <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">1000</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">positive</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">selection</span><span class="arithmetic-assignment">=</span><span class="string-literal">'cyclic'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l1_ratio</span> <span class="arithmetic-assignment">=</span> <span class="identifier">l1_ratio</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">eps</span> <span class="arithmetic-assignment">=</span> <span class="identifier">eps</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_alphas</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alphas</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_intercept</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">normalize</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">precompute</span> <span class="arithmetic-assignment">=</span> <span class="identifier">precompute</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span> <span class="arithmetic-assignment">=</span> <span class="identifier">tol</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cv</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy_X</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">verbose</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_jobs</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">positive</span> <span class="arithmetic-assignment">=</span> <span class="identifier">positive</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">selection</span> <span class="arithmetic-assignment">=</span> <span class="identifier">selection</span>

    <span class="keyword">def</span> <span class="identifier">_get_estimator</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">ElasticNet</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_is_multitask</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="bool-literal">False</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'multioutput'</span><span class="punctuation">:</span> <span class="bool-literal">False</span><span class="grouping">}</span>

<span class="comment">###############################################################################</span>
<span class="comment"># Multi Task ElasticNet and Lasso models (with joint feature selection)</span>


<span class="keyword">class</span> <span class="identifier">MultiTaskElasticNet</span><span class="grouping">(</span><span class="identifier">Lasso</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Multi-task ElasticNet model trained with L1/L2 mixed-norm as
    regularizer.

    The optimization objective for MultiTaskElasticNet is::

        (1 / (2 * n_samples)) * ||Y - XW||_Fro^2
        + alpha * l1_ratio * ||W||_21
        + 0.5 * alpha * (1 - l1_ratio) * ||W||_Fro^2

    Where::

        ||W||_21 = sum_i sqrt(sum_j W_ij ^ 2)

    i.e. the sum of norms of each row.

    Read more in the :ref:`User Guide &lt;multi_task_elastic_net&gt;`.

    Parameters
    ----------
    alpha : float, default=1.0
        Constant that multiplies the L1/L2 term. Defaults to 1.0.

    l1_ratio : float, default=0.5
        The ElasticNet mixing parameter, with 0 &lt; l1_ratio &lt;= 1.
        For l1_ratio = 1 the penalty is an L1/L2 penalty. For l1_ratio = 0 it
        is an L2 penalty.
        For ``0 &lt; l1_ratio &lt; 1``, the penalty is a combination of L1/L2 and L2.

    fit_intercept : bool, default=True
        Whether to calculate the intercept for this model. If set
        to false, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    normalize : bool, default=False
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

    copy_X : bool, default=True
        If ``True``, X will be copied; else, it may be overwritten.

    max_iter : int, default=1000
        The maximum number of iterations.

    tol : float, default=1e-4
        The tolerance for the optimization: if the updates are
        smaller than ``tol``, the optimization code checks the
        dual gap for optimality and continues until it is smaller
        than ``tol``.

    warm_start : bool, default=False
        When set to ``True``, reuse the solution of the previous call to fit as
        initialization, otherwise, just erase the previous solution.
        See :term:`the Glossary &lt;warm_start&gt;`.

    random_state : int, RandomState instance, default=None
        The seed of the pseudo random number generator that selects a random
        feature to update. Used when ``selection`` == 'random'.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    selection : {'cyclic', 'random'}, default='cyclic'
        If set to 'random', a random coefficient is updated every iteration
        rather than looping over features sequentially by default. This
        (setting to 'random') often leads to significantly faster convergence
        especially when tol is higher than 1e-4.

    Attributes
    ----------
    intercept_ : ndarray of shape (n_tasks,)
        Independent term in decision function.

    coef_ : ndarray of shape (n_tasks, n_features)
        Parameter vector (W in the cost function formula). If a 1D y is
        passed in at fit (non multi-task usage), ``coef_`` is then a 1D array.
        Note that ``coef_`` stores the transpose of ``W``, ``W.T``.

    n_iter_ : int
        Number of iterations run by the coordinate descent solver to reach
        the specified tolerance.

    dual_gap_ : float
        The dual gaps at the end of the optimization.

    eps_ : float
        The tolerance scaled scaled by the variance of the target `y`.

    sparse_coef_ : sparse matrix of shape (n_features,) or \
            (n_tasks, n_features)
        Sparse representation of the `coef_`.

    Examples
    --------
    &gt;&gt;&gt; from sklearn import linear_model
    &gt;&gt;&gt; clf = linear_model.MultiTaskElasticNet(alpha=0.1)
    &gt;&gt;&gt; clf.fit([[0,0], [1, 1], [2, 2]], [[0, 0], [1, 1], [2, 2]])
    MultiTaskElasticNet(alpha=0.1)
    &gt;&gt;&gt; print(clf.coef_)
    [[0.45663524 0.45612256]
     [0.45663524 0.45612256]]
    &gt;&gt;&gt; print(clf.intercept_)
    [0.0872422 0.0872422]

    See Also
    --------
    MultiTaskElasticNetCV : Multi-task L1/L2 ElasticNet with built-in
        cross-validation.
    ElasticNet
    MultiTaskLasso

    Notes
    -----
    The algorithm used to fit the model is coordinate descent.

    To avoid unnecessary memory duplication the X and y arguments of the fit
    method should be directly passed as Fortran-contiguous numpy arrays.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="float-literal">1.0</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.5</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">1000</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span>
                 <span class="identifier">warm_start</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">selection</span><span class="arithmetic-assignment">=</span><span class="string-literal">'cyclic'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l1_ratio</span> <span class="arithmetic-assignment">=</span> <span class="identifier">l1_ratio</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_intercept</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">normalize</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy_X</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span> <span class="arithmetic-assignment">=</span> <span class="identifier">tol</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">warm_start</span> <span class="arithmetic-assignment">=</span> <span class="identifier">warm_start</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">selection</span> <span class="arithmetic-assignment">=</span> <span class="identifier">selection</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Fit MultiTaskElasticNet model with coordinate descent

        Parameters
        ----------
        X : ndarray of shape (n_samples, n_features)
            Data.
        y : ndarray of shape (n_samples, n_tasks)
            Target. Will be cast to X's dtype if necessary.

        Notes
        -----

        Coordinate descent is an algorithm that considers each column of
        data at a time hence it will automatically convert the X input
        as a Fortran-contiguous numpy array if necessary.

        To avoid memory re-allocation it is advised to allocate the
        initial data in memory directly using that format.
        """</span>
        <span class="comment"># Need to validate separately here.</span>
        <span class="comment"># We can't pass multi_ouput=True because that would allow y to be csr.</span>
        <span class="identifier">check_X_params</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dict</span><span class="grouping">(</span><span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="grouping">[</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float32</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'F'</span><span class="punctuation">,</span>
                              <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="grouping">)</span>
        <span class="identifier">check_y_params</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dict</span><span class="grouping">(</span><span class="identifier">ensure_2d</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'F'</span><span class="grouping">)</span>
        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_validate_data</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">validate_separately</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="identifier">check_X_params</span><span class="punctuation">,</span>
                                                              <span class="identifier">check_y_params</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">y</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">y</span><span class="invalid">p</span><span class="invalid">e</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">'l1_ratio'</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">model_str</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'ElasticNet'</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">model_str</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">'Lasso'</span>
        <span class="keyword">if</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">==</span> <span class="int-literal">1</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"For mono-task outputs, use %s"</span> <span class="arithmetic-operator">%</span> <span class="identifier">model_str</span><span class="grouping">)</span>

        <span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">n_features</span> <span class="arithmetic-assignment">=</span> <span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">shape</span>
        <span class="identifier">_</span><span class="punctuation">,</span> <span class="identifier">n_tasks</span> <span class="arithmetic-assignment">=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span>

        <span class="keyword">if</span> <span class="identifier">n_samples</span> <span class="relational-operator">!=</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"X and y have inconsistent dimensions (%d != %d)"</span>
                             <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">n_samples</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">.</span><span class="identifier">shape</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">X_offset</span><span class="punctuation">,</span> <span class="identifier">y_offset</span><span class="punctuation">,</span> <span class="identifier">X_scale</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_preprocess_data</span><span class="grouping">(</span>
            <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span><span class="punctuation">,</span> <span class="identifier">copy</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">warm_start</span> <span class="logical-operator">or</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="string-literal">"coef_"</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">zeros</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">n_tasks</span><span class="punctuation">,</span> <span class="identifier">n_features</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">X</span><span class="punctuation">.</span><span class="identifier">dtype</span><span class="punctuation">.</span><span class="identifier">type</span><span class="punctuation">,</span>
                                  <span class="identifier">order</span><span class="arithmetic-assignment">=</span><span class="string-literal">'F'</span><span class="grouping">)</span>

        <span class="identifier">l1_reg</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha</span> <span class="arithmetic-operator">*</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l1_ratio</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_samples</span>
        <span class="identifier">l2_reg</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha</span> <span class="arithmetic-operator">*</span> <span class="grouping">(</span><span class="float-literal">1.0</span> <span class="arithmetic-operator">-</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l1_ratio</span><span class="grouping">)</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_samples</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">n</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span><span class="grouping">)</span>  <span class="comment"># coef contiguous in memory</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">selection</span> <span class="logical-operator">not</span> <span class="relational-operator">in</span> <span class="grouping">[</span><span class="string-literal">'random', 'cyclic'</span><span class="grouping">]</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"selection should be either random or cyclic."</span><span class="grouping">)</span>
        <span class="identifier">random</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">selection</span> <span class="relational-operator">==</span> <span class="string-literal">'random'</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dual_gap_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">eps_</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter_</span> <span class="arithmetic-assignment">=</span> <span class="invalid">\</span>
            <span class="identifier">cd_fast</span><span class="punctuation">.</span><span class="identifier">enet_coordinate_descent_multi_task</span><span class="grouping">(</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">coef_</span><span class="punctuation">,</span> <span class="identifier">l1_reg</span><span class="punctuation">,</span> <span class="identifier">l2_reg</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span><span class="punctuation">,</span>
                <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">random</span><span class="grouping">)</span>

        <span class="comment"># account for different objective scaling here and in cd_fast</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">dual_gap_</span> <span class="arithmetic-assignment">/=</span> <span class="identifier">n_samples</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_set_intercept</span><span class="grouping">(</span><span class="identifier">X_offset</span><span class="punctuation">,</span> <span class="identifier">y_offset</span><span class="punctuation">,</span> <span class="identifier">X_scale</span><span class="grouping">)</span>

        <span class="comment"># return self for chaining fit and predict calls</span>
        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'multioutput_only'</span><span class="punctuation">:</span> <span class="bool-literal">True</span><span class="grouping">}</span>


<span class="keyword">class</span> <span class="identifier">MultiTaskLasso</span><span class="grouping">(</span><span class="identifier">MultiTaskElasticNet</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Multi-task Lasso model trained with L1/L2 mixed-norm as regularizer.

    The optimization objective for Lasso is::

        (1 / (2 * n_samples)) * ||Y - XW||^2_Fro + alpha * ||W||_21

    Where::

        ||W||_21 = \\sum_i \\sqrt{\\sum_j w_{ij}^2}

    i.e. the sum of norm of each row.

    Read more in the :ref:`User Guide &lt;multi_task_lasso&gt;`.

    Parameters
    ----------
    alpha : float, default=1.0
        Constant that multiplies the L1/L2 term. Defaults to 1.0.

    fit_intercept : bool, default=True
        Whether to calculate the intercept for this model. If set
        to false, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    normalize : bool, default=False
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

    copy_X : bool, default=True
        If ``True``, X will be copied; else, it may be overwritten.

    max_iter : int, default=1000
        The maximum number of iterations.

    tol : float, default=1e-4
        The tolerance for the optimization: if the updates are
        smaller than ``tol``, the optimization code checks the
        dual gap for optimality and continues until it is smaller
        than ``tol``.

    warm_start : bool, default=False
        When set to ``True``, reuse the solution of the previous call to fit as
        initialization, otherwise, just erase the previous solution.
        See :term:`the Glossary &lt;warm_start&gt;`.

    random_state : int, RandomState instance, default=None
        The seed of the pseudo random number generator that selects a random
        feature to update. Used when ``selection`` == 'random'.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    selection : {'cyclic', 'random'}, default='cyclic'
        If set to 'random', a random coefficient is updated every iteration
        rather than looping over features sequentially by default. This
        (setting to 'random') often leads to significantly faster convergence
        especially when tol is higher than 1e-4

    Attributes
    ----------
    coef_ : ndarray of shape (n_tasks, n_features)
        Parameter vector (W in the cost function formula).
        Note that ``coef_`` stores the transpose of ``W``, ``W.T``.

    intercept_ : ndarray of shape (n_tasks,)
        Independent term in decision function.

    n_iter_ : int
        Number of iterations run by the coordinate descent solver to reach
        the specified tolerance.

    dual_gap_ : ndarray of shape (n_alphas,)
        The dual gaps at the end of the optimization for each alpha.

    eps_ : float
        The tolerance scaled scaled by the variance of the target `y`.

    sparse_coef_ : sparse matrix of shape (n_features,) or \
            (n_tasks, n_features)
        Sparse representation of the `coef_`.

    Examples
    --------
    &gt;&gt;&gt; from sklearn import linear_model
    &gt;&gt;&gt; clf = linear_model.MultiTaskLasso(alpha=0.1)
    &gt;&gt;&gt; clf.fit([[0, 1], [1, 2], [2, 4]], [[0, 0], [1, 1], [2, 3]])
    MultiTaskLasso(alpha=0.1)
    &gt;&gt;&gt; print(clf.coef_)
    [[0.         0.60809415]
    [0.         0.94592424]]
    &gt;&gt;&gt; print(clf.intercept_)
    [-0.41888636 -0.87382323]

    See Also
    --------
    MultiTaskLasso : Multi-task L1/L2 Lasso with built-in cross-validation.
    Lasso
    MultiTaskElasticNet

    Notes
    -----
    The algorithm used to fit the model is coordinate descent.

    To avoid unnecessary memory duplication the X and y arguments of the fit
    method should be directly passed as Fortran-contiguous numpy arrays.
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">alpha</span><span class="arithmetic-assignment">=</span><span class="float-literal">1.0</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                 <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">1000</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span> <span class="identifier">warm_start</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                 <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">selection</span><span class="arithmetic-assignment">=</span><span class="string-literal">'cyclic'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alpha</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alpha</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_intercept</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">normalize</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy_X</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span> <span class="arithmetic-assignment">=</span> <span class="identifier">tol</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">warm_start</span> <span class="arithmetic-assignment">=</span> <span class="identifier">warm_start</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l1_ratio</span> <span class="arithmetic-assignment">=</span> <span class="float-literal">1.0</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">selection</span> <span class="arithmetic-assignment">=</span> <span class="identifier">selection</span>


<span class="keyword">class</span> <span class="identifier">MultiTaskElasticNetCV</span><span class="grouping">(</span><span class="identifier">RegressorMixin</span><span class="punctuation">,</span> <span class="identifier">LinearModelCV</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Multi-task L1/L2 ElasticNet with built-in cross-validation.

    See glossary entry for :term:`cross-validation estimator`.

    The optimization objective for MultiTaskElasticNet is::

        (1 / (2 * n_samples)) * ||Y - XW||^Fro_2
        + alpha * l1_ratio * ||W||_21
        + 0.5 * alpha * (1 - l1_ratio) * ||W||_Fro^2

    Where::

        ||W||_21 = \\sum_i \\sqrt{\\sum_j w_{ij}^2}

    i.e. the sum of norm of each row.

    Read more in the :ref:`User Guide &lt;multi_task_elastic_net&gt;`.

    .. versionadded:: 0.15

    Parameters
    ----------
    l1_ratio : float or list of float, default=0.5
        The ElasticNet mixing parameter, with 0 &lt; l1_ratio &lt;= 1.
        For l1_ratio = 1 the penalty is an L1/L2 penalty. For l1_ratio = 0 it
        is an L2 penalty.
        For ``0 &lt; l1_ratio &lt; 1``, the penalty is a combination of L1/L2 and L2.
        This parameter can be a list, in which case the different
        values are tested by cross-validation and the one giving the best
        prediction score is used. Note that a good choice of list of
        values for l1_ratio is often to put more values close to 1
        (i.e. Lasso) and less close to 0 (i.e. Ridge), as in ``[.1, .5, .7,
        .9, .95, .99, 1]``

    eps : float, default=1e-3
        Length of the path. ``eps=1e-3`` means that
        ``alpha_min / alpha_max = 1e-3``.

    n_alphas : int, default=100
        Number of alphas along the regularization path.

    alphas : array-like, default=None
        List of alphas where to compute the models.
        If not provided, set automatically.

    fit_intercept : bool, default=True
        Whether to calculate the intercept for this model. If set
        to false, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    normalize : bool, default=False
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

    max_iter : int, default=1000
        The maximum number of iterations.

    tol : float, default=1e-4
        The tolerance for the optimization: if the updates are
        smaller than ``tol``, the optimization code checks the
        dual gap for optimality and continues until it is smaller
        than ``tol``.

    cv : int, cross-validation generator or iterable, default=None
        Determines the cross-validation splitting strategy.
        Possible inputs for cv are:

        - None, to use the default 5-fold cross-validation,
        - int, to specify the number of folds.
        - :term:`CV splitter`,
        - An iterable yielding (train, test) splits as arrays of indices.

        For int/None inputs, :class:`KFold` is used.

        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
        cross-validation strategies that can be used here.

        .. versionchanged:: 0.22
            ``cv`` default value if None changed from 3-fold to 5-fold.

    copy_X : bool, default=True
        If ``True``, X will be copied; else, it may be overwritten.

    verbose : bool or int, default=0
        Amount of verbosity.

    n_jobs : int, default=None
        Number of CPUs to use during the cross validation. Note that this is
        used only if multiple values for l1_ratio are given.
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

    random_state : int, RandomState instance, default=None
        The seed of the pseudo random number generator that selects a random
        feature to update. Used when ``selection`` == 'random'.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    selection : {'cyclic', 'random'}, default='cyclic'
        If set to 'random', a random coefficient is updated every iteration
        rather than looping over features sequentially by default. This
        (setting to 'random') often leads to significantly faster convergence
        especially when tol is higher than 1e-4.

    Attributes
    ----------
    intercept_ : ndarray of shape (n_tasks,)
        Independent term in decision function.

    coef_ : ndarray of shape (n_tasks, n_features)
        Parameter vector (W in the cost function formula).
        Note that ``coef_`` stores the transpose of ``W``, ``W.T``.

    alpha_ : float
        The amount of penalization chosen by cross validation.

    mse_path_ : ndarray of shape (n_alphas, n_folds) or \
                (n_l1_ratio, n_alphas, n_folds)
        Mean square error for the test set on each fold, varying alpha.

    alphas_ : ndarray of shape (n_alphas,) or (n_l1_ratio, n_alphas)
        The grid of alphas used for fitting, for each l1_ratio.

    l1_ratio_ : float
        Best l1_ratio obtained by cross-validation.

    n_iter_ : int
        Number of iterations run by the coordinate descent solver to reach
        the specified tolerance for the optimal alpha.

    dual_gap_ : float
        The dual gap at the end of the optimization for the optimal alpha.

    Examples
    --------
    &gt;&gt;&gt; from sklearn import linear_model
    &gt;&gt;&gt; clf = linear_model.MultiTaskElasticNetCV(cv=3)
    &gt;&gt;&gt; clf.fit([[0,0], [1, 1], [2, 2]],
    ...         [[0, 0], [1, 1], [2, 2]])
    MultiTaskElasticNetCV(cv=3)
    &gt;&gt;&gt; print(clf.coef_)
    [[0.52875032 0.46958558]
     [0.52875032 0.46958558]]
    &gt;&gt;&gt; print(clf.intercept_)
    [0.00166409 0.00166409]

    See Also
    --------
    MultiTaskElasticNet
    ElasticNetCV
    MultiTaskLassoCV

    Notes
    -----
    The algorithm used to fit the model is coordinate descent.

    To avoid unnecessary memory duplication the X and y arguments of the fit
    method should be directly passed as Fortran-contiguous numpy arrays.
    """</span>
    <span class="identifier">path</span> <span class="arithmetic-assignment">=</span> <span class="identifier">staticmethod</span><span class="grouping">(</span><span class="identifier">enet_path</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">l1_ratio</span><span class="arithmetic-assignment">=</span><span class="float-literal">0.5</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="arithmetic-assignment">=</span><span class="int-literal">100</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                 <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">1000</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">selection</span><span class="arithmetic-assignment">=</span><span class="string-literal">'cyclic'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">l1_ratio</span> <span class="arithmetic-assignment">=</span> <span class="identifier">l1_ratio</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">eps</span> <span class="arithmetic-assignment">=</span> <span class="identifier">eps</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_alphas</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">alphas</span> <span class="arithmetic-assignment">=</span> <span class="identifier">alphas</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">fit_intercept</span> <span class="arithmetic-assignment">=</span> <span class="identifier">fit_intercept</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">normalize</span> <span class="arithmetic-assignment">=</span> <span class="identifier">normalize</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">max_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">max_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">tol</span> <span class="arithmetic-assignment">=</span> <span class="identifier">tol</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cv</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">copy_X</span> <span class="arithmetic-assignment">=</span> <span class="identifier">copy_X</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">verbose</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_jobs</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">selection</span> <span class="arithmetic-assignment">=</span> <span class="identifier">selection</span>

    <span class="keyword">def</span> <span class="identifier">_get_estimator</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">MultiTaskElasticNet</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_is_multitask</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="bool-literal">True</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'multioutput_only'</span><span class="punctuation">:</span> <span class="bool-literal">True</span><span class="grouping">}</span>


<span class="keyword">class</span> <span class="identifier">MultiTaskLassoCV</span><span class="grouping">(</span><span class="identifier">RegressorMixin</span><span class="punctuation">,</span> <span class="identifier">LinearModelCV</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Multi-task Lasso model trained with L1/L2 mixed-norm as regularizer.

    See glossary entry for :term:`cross-validation estimator`.

    The optimization objective for MultiTaskLasso is::

        (1 / (2 * n_samples)) * ||Y - XW||^Fro_2 + alpha * ||W||_21

    Where::

        ||W||_21 = \\sum_i \\sqrt{\\sum_j w_{ij}^2}

    i.e. the sum of norm of each row.

    Read more in the :ref:`User Guide &lt;multi_task_lasso&gt;`.

    .. versionadded:: 0.15

    Parameters
    ----------
    eps : float, default=1e-3
        Length of the path. ``eps=1e-3`` means that
        ``alpha_min / alpha_max = 1e-3``.

    n_alphas : int, default=100
        Number of alphas along the regularization path.

    alphas : array-like, default=None
        List of alphas where to compute the models.
        If not provided, set automatically.

    fit_intercept : bool, default=True
        Whether to calculate the intercept for this model. If set
        to false, no intercept will be used in calculations
        (i.e. data is expected to be centered).

    normalize : bool, default=False
        This parameter is ignored when ``fit_intercept`` is set to False.
        If True, the regressors X will be normalized before regression by
        subtracting the mean and dividing by the l2-norm.
        If you wish to standardize, please use
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit``
        on an estimator with ``normalize=False``.

    max_iter : int, default=1000
        The maximum number of iterations.

    tol : float, default=1e-4
        The tolerance for the optimization: if the updates are
        smaller than ``tol``, the optimization code checks the
        dual gap for optimality and continues until it is smaller
        than ``tol``.

    copy_X : bool, default=True
        If ``True``, X will be copied; else, it may be overwritten.

    cv : int, cross-validation generator or iterable, default=None
        Determines the cross-validation splitting strategy.
        Possible inputs for cv are:

        - None, to use the default 5-fold cross-validation,
        - int, to specify the number of folds.
        - :term:`CV splitter`,
        - An iterable yielding (train, test) splits as arrays of indices.

        For int/None inputs, :class:`KFold` is used.

        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
        cross-validation strategies that can be used here.

        .. versionchanged:: 0.22
            ``cv`` default value if None changed from 3-fold to 5-fold.

    verbose : bool or int, default=False
        Amount of verbosity.

    n_jobs : int, default=None
        Number of CPUs to use during the cross validation. Note that this is
        used only if multiple values for l1_ratio are given.
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

    random_state : int, RandomState instance, default=None
        The seed of the pseudo random number generator that selects a random
        feature to update. Used when ``selection`` == 'random'.
        Pass an int for reproducible output across multiple function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    selection : {'cyclic', 'random'}, default='cyclic'
        If set to 'random', a random coefficient is updated every iteration
        rather than looping over features sequentially by default. This
        (setting to 'random') often leads to significantly faster convergence
        especially when tol is higher than 1e-4.

    Attributes
    ----------
    intercept_ : ndarray of shape (n_tasks,)
        Independent term in decision function.

    coef_ : ndarray of shape (n_tasks, n_features)
        Parameter vector (W in the cost function formula).
        Note that ``coef_`` stores the transpose of ``W``, ``W.T``.

    alpha_ : float
        The amount of penalization chosen by cross validation.

    mse_path_ : ndarray of shape (n_alphas, n_folds)
        Mean square error for the test set on each fold, varying alpha.

    alphas_ : ndarray of shape (n_alphas,)
        The grid of alphas used for fitting.

    n_iter_ : int
        Number of iterations run by the coordinate descent solver to reach
        the specified tolerance for the optimal alpha.

    dual_gap_ : float
        The dual gap at the end of the optimization for the optimal alpha.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.linear_model import MultiTaskLassoCV
    &gt;&gt;&gt; from sklearn.datasets import make_regression
    &gt;&gt;&gt; from sklearn.metrics import r2_score
    &gt;&gt;&gt; X, y = make_regression(n_targets=2, noise=4, random_state=0)
    &gt;&gt;&gt; reg = MultiTaskLassoCV(cv=5, random_state=0).fit(X, y)
    &gt;&gt;&gt; r2_score(y, reg.predict(X))
    0.9994...
    &gt;&gt;&gt; reg.alpha_
    0.5713...
    &gt;&gt;&gt; reg.predict(X[:1,])
    array([[153.7971...,  94.9015...]])

    See Also
    --------
    MultiTaskElasticNet
    ElasticNetCV
    MultiTaskElasticNetCV

    Notes
    -----
    The algorithm used to fit the model is coordinate descent.

    To avoid unnecessary memory duplication the X and y arguments of the fit
    method should be directly passed as Fortran-contiguous numpy arrays.
    """</span>
    <span class="identifier">path</span> <span class="arithmetic-assignment">=</span> <span class="identifier">staticmethod</span><span class="grouping">(</span><span class="identifier">lasso_path</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-3</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="arithmetic-assignment">=</span><span class="int-literal">100</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">1000</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="float-literal">1e-4</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">selection</span><span class="arithmetic-assignment">=</span><span class="string-literal">'cyclic'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">eps</span><span class="arithmetic-assignment">=</span><span class="identifier">eps</span><span class="punctuation">,</span> <span class="identifier">n_alphas</span><span class="arithmetic-assignment">=</span><span class="identifier">n_alphas</span><span class="punctuation">,</span> <span class="identifier">alphas</span><span class="arithmetic-assignment">=</span><span class="identifier">alphas</span><span class="punctuation">,</span>
            <span class="identifier">fit_intercept</span><span class="arithmetic-assignment">=</span><span class="identifier">fit_intercept</span><span class="punctuation">,</span> <span class="identifier">normalize</span><span class="arithmetic-assignment">=</span><span class="identifier">normalize</span><span class="punctuation">,</span>
            <span class="identifier">max_iter</span><span class="arithmetic-assignment">=</span><span class="identifier">max_iter</span><span class="punctuation">,</span> <span class="identifier">tol</span><span class="arithmetic-assignment">=</span><span class="identifier">tol</span><span class="punctuation">,</span> <span class="identifier">copy_X</span><span class="arithmetic-assignment">=</span><span class="identifier">copy_X</span><span class="punctuation">,</span>
            <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">n_jobs</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">random_state</span><span class="punctuation">,</span>
            <span class="identifier">selection</span><span class="arithmetic-assignment">=</span><span class="identifier">selection</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_get_estimator</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">MultiTaskLasso</span><span class="grouping">(</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_is_multitask</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="bool-literal">True</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="grouping">{</span><span class="string-literal">'multioutput_only'</span><span class="punctuation">:</span> <span class="bool-literal">True</span><span class="grouping">}</span>

    </pre>
  </body>
</html>