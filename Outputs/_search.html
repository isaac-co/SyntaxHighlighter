<html>
  <head>
    <title>Python Lexical Highliter</title>
    <link rel="stylesheet" href="token_colors.css">
  </head>
  <body>
    <pre><span class="comment">"""
The :mod:`sklearn.model_selection._search` includes utilities to fine-tune the
parameters of an estimator.
"""</span>

<span class="comment"># Author: Alexandre Gramfort &lt;alexandre.gramfort@inria.fr&gt;,</span>
<span class="comment">#         Gael Varoquaux &lt;gael.varoquaux@normalesup.org&gt;</span>
<span class="comment">#         Andreas Mueller &lt;amueller@ais.uni-bonn.de&gt;</span>
<span class="comment">#         Olivier Grisel &lt;olivier.grisel@ensta.org&gt;</span>
<span class="comment">#         Raghav RV &lt;rvraghav93@gmail.com&gt;</span>
<span class="comment"># License: BSD 3 clause</span>

<span class="keyword">from</span> <span class="identifier">abc</span> <span class="keyword">import</span> <span class="identifier">ABCMeta</span><span class="punctuation">,</span> <span class="identifier">abstractmethod</span>
<span class="keyword">from</span> <span class="identifier">collections</span> <span class="keyword">import</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">d</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">t</span>
<span class="keyword">from</span> <span class="identifier">collections</span><span class="punctuation">.</span><span class="identifier">abc</span> <span class="keyword">import</span> <span class="identifier">Mapping</span><span class="punctuation">,</span> <span class="identifier">Sequence</span><span class="punctuation">,</span> <span class="identifier">Iterable</span>
<span class="keyword">from</span> <span class="identifier">functools</span> <span class="keyword">import</span> <span class="identifier">partial</span><span class="punctuation">,</span> <span class="identifier">reduce</span>
<span class="keyword">from</span> <span class="identifier">itertools</span> <span class="keyword">import</span> <span class="identifier">product</span>
<span class="keyword">import</span> <span class="identifier">numbers</span>
<span class="keyword">import</span> <span class="identifier">operator</span>
<span class="keyword">import</span> <span class="identifier">time</span>
<span class="keyword">import</span> <span class="identifier">warnings</span>

<span class="keyword">import</span> <span class="identifier">numpy</span> <span class="keyword">as</span> <span class="identifier">np</span>
<span class="keyword">from</span> <span class="identifier">numpy</span><span class="punctuation">.</span><span class="identifier">ma</span> <span class="keyword">import</span> <span class="identifier">MaskedArray</span>
<span class="keyword">from</span> <span class="identifier">scipy</span><span class="punctuation">.</span><span class="identifier">stats</span> <span class="keyword">import</span> <span class="identifier">rankdata</span>

<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">BaseEstimator</span><span class="punctuation">,</span> <span class="identifier">is_classifier</span><span class="punctuation">,</span> <span class="identifier">clone</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">base</span> <span class="keyword">import</span> <span class="identifier">MetaEstimatorMixin</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_split</span> <span class="keyword">import</span> <span class="identifier">check_cv</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_validation</span> <span class="keyword">import</span> <span class="identifier">_fit_and_score</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_validation</span> <span class="keyword">import</span> <span class="identifier">_aggregate_score_dicts</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_validation</span> <span class="keyword">import</span> <span class="identifier">_insert_error_scores</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="identifier">_validation</span> <span class="keyword">import</span> <span class="identifier">_normalize_score_results</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="invalid">e</span><span class="invalid">x</span><span class="invalid">c</span><span class="invalid">e</span><span class="invalid">p</span><span class="invalid">t</span><span class="invalid">i</span><span class="invalid">o</span><span class="invalid">n</span><span class="invalid">s</span> <span class="keyword">import</span> <span class="identifier">NotFittedError</span>
<span class="keyword">from</span> <span class="identifier">joblib</span> <span class="keyword">import</span> <span class="identifier">Parallel</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">check_random_state</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">random</span> <span class="keyword">import</span> <span class="identifier">sample_without_replacement</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">_tags</span> <span class="keyword">import</span> <span class="identifier">_safe_tags</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">validation</span> <span class="keyword">import</span> <span class="identifier">indexable</span><span class="punctuation">,</span> <span class="identifier">check_is_fitted</span><span class="punctuation">,</span> <span class="identifier">_check_fit_params</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">metaestimators</span> <span class="keyword">import</span> <span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span><span class="punctuation">.</span><span class="identifier">fixes</span> <span class="keyword">import</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">metrics</span><span class="punctuation">.</span><span class="identifier">_scorer</span> <span class="keyword">import</span> <span class="identifier">_check_multimetric_scoring</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">metrics</span> <span class="keyword">import</span> <span class="identifier">check_scoring</span>
<span class="keyword">from</span> <span class="punctuation">.</span><span class="punctuation">.</span><span class="identifier">utils</span> <span class="keyword">import</span> <span class="identifier">deprecated</span>

<span class="identifier">__all__</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="string-literal">'GridSearchCV', 'ParameterGrid'</span><span class="punctuation">,</span>
           <span class="string-literal">'ParameterSampler', 'RandomizedSearchCV'</span><span class="grouping">]</span>


<span class="keyword">class</span> <span class="identifier">ParameterGrid</span><span class="punctuation">:</span>
    <span class="comment">"""Grid of parameters with a discrete number of values for each.

    Can be used to iterate over parameter value combinations with the
    Python built-in function iter.
    The order of the generated parameter combinations is deterministic.

    Read more in the :ref:`User Guide &lt;grid_search&gt;`.

    Parameters
    ----------
    param_grid : dict of str to sequence, or sequence of such
        The parameter grid to explore, as a dictionary mapping estimator
        parameters to sequences of allowed values.

        An empty dict signifies default parameters.

        A sequence of dicts signifies a sequence of grids to search, and is
        useful to avoid exploring parameter combinations that make no sense
        or have no effect. See the examples below.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.model_selection import ParameterGrid
    &gt;&gt;&gt; param_grid = {'a': [1, 2], 'b': [True, False]}
    &gt;&gt;&gt; list(ParameterGrid(param_grid)) == (
    ...    [{'a': 1, 'b': True}, {'a': 1, 'b': False},
    ...     {'a': 2, 'b': True}, {'a': 2, 'b': False}])
    True

    &gt;&gt;&gt; grid = [{'kernel': ['linear']}, {'kernel': ['rbf'], 'gamma': [1, 10]}]
    &gt;&gt;&gt; list(ParameterGrid(grid)) == [{'kernel': 'linear'},
    ...                               {'kernel': 'rbf', 'gamma': 1},
    ...                               {'kernel': 'rbf', 'gamma': 10}]
    True
    &gt;&gt;&gt; ParameterGrid(grid)[1] == {'kernel': 'rbf', 'gamma': 1}
    True

    See Also
    --------
    GridSearchCV : Uses :class:`ParameterGrid` to perform a full parallelized
        parameter search.
    """</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">param_grid</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">param_grid</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">Mapping</span><span class="punctuation">,</span> <span class="identifier">Iterable</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">'Parameter grid is not a dict or '</span>
                            <span class="string-literal">'a list ({!r})'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">param_grid</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">param_grid</span><span class="punctuation">,</span> <span class="identifier">Mapping</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># wrap dictionary in a singleton list to support either dict</span>
            <span class="comment"># or list of dicts</span>
            <span class="identifier">param_grid</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">param_grid</span><span class="grouping">]</span>

        <span class="comment"># check if all entries are dictionaries of lists</span>
        <span class="keyword">for</span> <span class="identifier">grid</span> <span class="relational-operator">in</span> <span class="identifier">param_grid</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">grid</span><span class="punctuation">,</span> <span class="identifier">dict</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">'Parameter grid is not a '</span>
                                <span class="string-literal">'dict ({!r})'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">grid</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="keyword">for</span> <span class="identifier">key</span> <span class="relational-operator">in</span> <span class="identifier">grid</span><span class="punctuation">:</span>
                <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">grid</span><span class="grouping">[</span><span class="identifier">key</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Iterable</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">'Parameter grid value is not iterable '</span>
                                    <span class="string-literal">'(key={!r}, value={!r})'</span>
                                    <span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">key</span><span class="punctuation">,</span> <span class="identifier">grid</span><span class="grouping">[</span><span class="identifier">key</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">param_grid</span> <span class="arithmetic-assignment">=</span> <span class="identifier">param_grid</span>

    <span class="keyword">def</span> <span class="identifier">__iter__</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Iterate over the points in the grid.

        Returns
        -------
        params : iterator over dict of str to any
            Yields dictionaries mapping each estimator parameter to one of its
            allowed values.
        """</span>
        <span class="keyword">for</span> <span class="identifier">p</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">param_grid</span><span class="punctuation">:</span>
            <span class="comment"># Always sort the keys of a dictionary, for reproducibility</span>
            <span class="identifier">items</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sorted</span><span class="grouping">(</span><span class="identifier">p</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">items</span><span class="punctuation">:</span>
                <span class="keyword">yield</span> <span class="grouping">{</span><span class="grouping">}</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">keys</span><span class="punctuation">,</span> <span class="identifier">values</span> <span class="arithmetic-assignment">=</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">items</span><span class="grouping">)</span>
                <span class="keyword">for</span> <span class="identifier">v</span> <span class="relational-operator">in</span> <span class="identifier">product</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">values</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">params</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dict</span><span class="grouping">(</span><span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">keys</span><span class="punctuation">,</span> <span class="identifier">v</span><span class="grouping">)</span><span class="grouping">)</span>
                    <span class="keyword">yield</span> <span class="identifier">params</span>

    <span class="keyword">def</span> <span class="identifier">__len__</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Number of points on the grid."""</span>
        <span class="comment"># Product function that can handle iterables (np.product can't).</span>
        <span class="identifier">product</span> <span class="arithmetic-assignment">=</span> <span class="identifier">partial</span><span class="grouping">(</span><span class="identifier">reduce</span><span class="punctuation">,</span> <span class="identifier">operator</span><span class="punctuation">.</span><span class="identifier">mul</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">sum</span><span class="grouping">(</span><span class="identifier">product</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">v</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">v</span> <span class="relational-operator">in</span> <span class="identifier">p</span><span class="punctuation">.</span><span class="identifier">values</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span> <span class="keyword">if</span> <span class="identifier">p</span> <span class="keyword">else</span> <span class="int-literal">1</span>
                   <span class="keyword">for</span> <span class="identifier">p</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">param_grid</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">__getitem__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">ind</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Get the parameters that would be ``ind``th in iteration

        Parameters
        ----------
        ind : int
            The iteration index

        Returns
        -------
        params : dict of str to any
            Equal to list(self)[ind]
        """</span>
        <span class="comment"># This is used to make discrete sampling without replacement memory</span>
        <span class="comment"># efficient.</span>
        <span class="keyword">for</span> <span class="identifier">sub_grid</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">param_grid</span><span class="punctuation">:</span>
            <span class="comment"># XXX: could memoize information used here</span>
            <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">sub_grid</span><span class="punctuation">:</span>
                <span class="keyword">if</span> <span class="identifier">ind</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
                    <span class="keyword">return</span> <span class="grouping">{</span><span class="grouping">}</span>
                <span class="keyword">else</span><span class="punctuation">:</span>
                    <span class="identifier">ind</span> <span class="arithmetic-assignment">-=</span> <span class="int-literal">1</span>
                    <span class="keyword">continue</span>

            <span class="comment"># Reverse so most frequent cycling parameter comes first</span>
            <span class="identifier">keys</span><span class="punctuation">,</span> <span class="identifier">values_lists</span> <span class="arithmetic-assignment">=</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="arithmetic-operator">*</span><span class="identifier">sorted</span><span class="grouping">(</span><span class="identifier">sub_grid</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="arithmetic-operator">-</span><span class="int-literal">1</span><span class="grouping">]</span><span class="grouping">)</span>
            <span class="identifier">sizes</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">v_list</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">v_list</span> <span class="relational-operator">in</span> <span class="identifier">values_lists</span><span class="grouping">]</span>
            <span class="identifier">total</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">product</span><span class="grouping">(</span><span class="identifier">sizes</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="identifier">ind</span> <span class="relational-operator">&gt;=</span> <span class="identifier">total</span><span class="punctuation">:</span>
                <span class="comment"># Try the next grid</span>
                <span class="identifier">ind</span> <span class="arithmetic-assignment">-=</span> <span class="identifier">total</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">out</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="grouping">}</span>
                <span class="keyword">for</span> <span class="identifier">key</span><span class="punctuation">,</span> <span class="identifier">v_list</span><span class="punctuation">,</span> <span class="identifier">n</span> <span class="relational-operator">in</span> <span class="identifier">zip</span><span class="grouping">(</span><span class="identifier">keys</span><span class="punctuation">,</span> <span class="identifier">values_lists</span><span class="punctuation">,</span> <span class="identifier">sizes</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">ind</span><span class="punctuation">,</span> <span class="identifier">offset</span> <span class="arithmetic-assignment">=</span> <span class="identifier">divmod</span><span class="grouping">(</span><span class="identifier">ind</span><span class="punctuation">,</span> <span class="identifier">n</span><span class="grouping">)</span>
                    <span class="identifier">out</span><span class="grouping">[</span><span class="identifier">key</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">v_list</span><span class="grouping">[</span><span class="identifier">offset</span><span class="grouping">]</span>
                <span class="keyword">return</span> <span class="identifier">out</span>

        <span class="keyword">raise</span> <span class="identifier">IndexError</span><span class="grouping">(</span><span class="string-literal">'ParameterGrid index out of range'</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">ParameterSampler</span><span class="punctuation">:</span>
    <span class="comment">"""Generator on parameters sampled from given distributions.

    Non-deterministic iterable over random candidate combinations for hyper-
    parameter search. If all parameters are presented as a list,
    sampling without replacement is performed. If at least one parameter
    is given as a distribution, sampling with replacement is used.
    It is highly recommended to use continuous distributions for continuous
    parameters.

    Read more in the :ref:`User Guide &lt;grid_search&gt;`.

    Parameters
    ----------
    param_distributions : dict
        Dictionary with parameters names (`str`) as keys and distributions
        or lists of parameters to try. Distributions must provide a ``rvs``
        method for sampling (such as those from scipy.stats.distributions).
        If a list is given, it is sampled uniformly.
        If a list of dicts is given, first a dict is sampled uniformly, and
        then a parameter is sampled using that dict as above.

    n_iter : int
        Number of parameter settings that are produced.

    random_state : int, RandomState instance or None, default=None
        Pseudo random number generator state used for random uniform sampling
        from lists of possible values instead of scipy.stats distributions.
        Pass an int for reproducible output across multiple
        function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    Returns
    -------
    params : dict of str to any
        **Yields** dictionaries mapping each estimator parameter to
        as sampled value.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.model_selection import ParameterSampler
    &gt;&gt;&gt; from scipy.stats.distributions import expon
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; rng = np.random.RandomState(0)
    &gt;&gt;&gt; param_grid = {'a':[1, 2], 'b': expon()}
    &gt;&gt;&gt; param_list = list(ParameterSampler(param_grid, n_iter=4,
    ...                                    random_state=rng))
    &gt;&gt;&gt; rounded_list = [dict((k, round(v, 6)) for (k, v) in d.items())
    ...                 for d in param_list]
    &gt;&gt;&gt; rounded_list == [{'b': 0.89856, 'a': 1},
    ...                  {'b': 0.923223, 'a': 1},
    ...                  {'b': 1.878964, 'a': 2},
    ...                  {'b': 1.038159, 'a': 2}]
    True
    """</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">param_distributions</span><span class="punctuation">,</span> <span class="identifier">n_iter</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">param_distributions</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">Mapping</span><span class="punctuation">,</span> <span class="identifier">Iterable</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">'Parameter distribution is not a dict or '</span>
                            <span class="string-literal">'a list ({!r})'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">param_distributions</span><span class="grouping">)</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">param_distributions</span><span class="punctuation">,</span> <span class="identifier">Mapping</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># wrap dictionary in a singleton list to support either dict</span>
            <span class="comment"># or list of dicts</span>
            <span class="identifier">param_distributions</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">param_distributions</span><span class="grouping">]</span>

        <span class="keyword">for</span> <span class="identifier">dist</span> <span class="relational-operator">in</span> <span class="identifier">param_distributions</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">dist</span><span class="punctuation">,</span> <span class="identifier">dict</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">'Parameter distribution is not a '</span>
                                <span class="string-literal">'dict ({!r})'</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">dist</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="keyword">for</span> <span class="identifier">key</span> <span class="relational-operator">in</span> <span class="identifier">dist</span><span class="punctuation">:</span>
                <span class="keyword">if</span> <span class="grouping">(</span><span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">dist</span><span class="grouping">[</span><span class="identifier">key</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="identifier">Iterable</span><span class="grouping">)</span>
                        <span class="logical-operator">and</span> <span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">dist</span><span class="grouping">[</span><span class="identifier">key</span><span class="grouping">]</span><span class="punctuation">,</span> <span class="string-literal">'rvs'</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">'Parameter value is not iterable '</span>
                                    <span class="string-literal">'or distribution (key={!r}, value={!r})'</span>
                                    <span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">key</span><span class="punctuation">,</span> <span class="identifier">dist</span><span class="grouping">[</span><span class="identifier">key</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">param_distributions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">param_distributions</span>

    <span class="keyword">def</span> <span class="identifier">_is_all_lists</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">all</span><span class="grouping">(</span>
            <span class="identifier">all</span><span class="grouping">(</span><span class="logical-operator">not</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">v</span><span class="punctuation">,</span> <span class="string-literal">"rvs"</span><span class="grouping">)</span> <span class="keyword">for</span> <span class="identifier">v</span> <span class="relational-operator">in</span> <span class="identifier">dist</span><span class="punctuation">.</span><span class="identifier">values</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="keyword">for</span> <span class="identifier">dist</span> <span class="relational-operator">in</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">param_distributions</span>
        <span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">__iter__</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">rng</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_random_state</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span>

        <span class="comment"># if all distributions are given as lists, we want to sample without</span>
        <span class="comment"># replacement</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_is_all_lists</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># look up sampled parameter settings in parameter grid</span>
            <span class="identifier">param_grid</span> <span class="arithmetic-assignment">=</span> <span class="identifier">ParameterGrid</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">param_distributions</span><span class="grouping">)</span>
            <span class="identifier">grid_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">param_grid</span><span class="grouping">)</span>
            <span class="identifier">n_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter</span>

            <span class="keyword">if</span> <span class="identifier">grid_size</span> <span class="relational-operator">&lt;</span> <span class="identifier">n_iter</span><span class="punctuation">:</span>
                <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span>
                    <span class="string-literal">'The total space of parameters %d is smaller '</span>
                    <span class="string-literal">'than n_iter=%d. Running %d iterations. For exhaustive '</span>
                    <span class="string-literal">'searches, use GridSearchCV.'</span>
                    <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">grid_size</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter</span><span class="punctuation">,</span> <span class="identifier">grid_size</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">UserWarning</span><span class="grouping">)</span>
                <span class="identifier">n_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">grid_size</span>
            <span class="keyword">for</span> <span class="identifier">i</span> <span class="relational-operator">in</span> <span class="identifier">sample_without_replacement</span><span class="grouping">(</span><span class="identifier">grid_size</span><span class="punctuation">,</span> <span class="identifier">n_iter</span><span class="punctuation">,</span>
                                                <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">rng</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">yield</span> <span class="identifier">param_grid</span><span class="grouping">[</span><span class="identifier">i</span><span class="grouping">]</span>

        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">for</span> <span class="identifier">_</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">dist</span> <span class="arithmetic-assignment">=</span> <span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">choice</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">param_distributions</span><span class="grouping">)</span>
                <span class="comment"># Always sort the keys of a dictionary, for reproducibility</span>
                <span class="identifier">items</span> <span class="arithmetic-assignment">=</span> <span class="identifier">sorted</span><span class="grouping">(</span><span class="identifier">dist</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="grouping">)</span>
                <span class="identifier">params</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dict</span><span class="grouping">(</span><span class="grouping">)</span>
                <span class="keyword">for</span> <span class="identifier">k</span><span class="punctuation">,</span> <span class="identifier">v</span> <span class="relational-operator">in</span> <span class="identifier">items</span><span class="punctuation">:</span>
                    <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">v</span><span class="punctuation">,</span> <span class="string-literal">"rvs"</span><span class="grouping">)</span><span class="punctuation">:</span>
                        <span class="identifier">params</span><span class="grouping">[</span><span class="identifier">k</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">v</span><span class="punctuation">.</span><span class="identifier">rvs</span><span class="grouping">(</span><span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">rng</span><span class="grouping">)</span>
                    <span class="keyword">else</span><span class="punctuation">:</span>
                        <span class="identifier">params</span><span class="grouping">[</span><span class="identifier">k</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">v</span><span class="grouping">[</span><span class="identifier">rng</span><span class="punctuation">.</span><span class="identifier">randint</span><span class="grouping">(</span><span class="identifier">len</span><span class="grouping">(</span><span class="identifier">v</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">]</span>
                <span class="keyword">yield</span> <span class="identifier">params</span>

    <span class="keyword">def</span> <span class="identifier">__len__</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Number of points that will be sampled."""</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_is_all_lists</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">grid_size</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">ParameterGrid</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">param_distributions</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="keyword">return</span> <span class="identifier">min</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter</span><span class="punctuation">,</span> <span class="identifier">grid_size</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter</span>


<span class="keyword">def</span> <span class="identifier">_check_param_grid</span><span class="grouping">(</span><span class="identifier">param_grid</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="keyword">if</span> <span class="identifier">hasattr</span><span class="grouping">(</span><span class="identifier">param_grid</span><span class="punctuation">,</span> <span class="string-literal">'items'</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">param_grid</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="identifier">param_grid</span><span class="grouping">]</span>

    <span class="keyword">for</span> <span class="identifier">p</span> <span class="relational-operator">in</span> <span class="identifier">param_grid</span><span class="punctuation">:</span>
        <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">v</span> <span class="relational-operator">in</span> <span class="identifier">p</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ndarray</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">v</span><span class="punctuation">.</span><span class="identifier">ndim</span> <span class="relational-operator">&gt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Parameter array should be one-dimensional."</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">v</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span> <span class="logical-operator">or</span>
                    <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">v</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">ndarray</span><span class="punctuation">,</span> <span class="identifier">Sequence</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Parameter grid for parameter ({0}) needs to"</span>
                                 <span class="string-literal">" be a list or numpy array, but got ({1})."</span>
                                 <span class="string-literal">" Single values need to be wrapped in a list"</span>
                                 <span class="string-literal">" with one element."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">type</span><span class="grouping">(</span><span class="identifier">v</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

            <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">v</span><span class="grouping">)</span> <span class="relational-operator">==</span> <span class="int-literal">0</span><span class="punctuation">:</span>
                <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"Parameter values for parameter ({0}) need "</span>
                                 <span class="string-literal">"to be a non-empty sequence."</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">name</span><span class="grouping">)</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">BaseSearchCV</span><span class="grouping">(</span><span class="identifier">MetaEstimatorMixin</span><span class="punctuation">,</span> <span class="identifier">BaseEstimator</span><span class="punctuation">,</span> <span class="identifier">metaclass</span><span class="arithmetic-assignment">=</span><span class="identifier">ABCMeta</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Abstract base class for hyper parameter search with cross-validation.
    """</span>

    <span class="punctuation">@</span><span class="identifier">abstractmethod</span>
    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">estimator</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">scoring</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">refit</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span>
                 <span class="identifier">pre_dispatch</span><span class="arithmetic-assignment">=</span><span class="string-literal">'2*n_jobs'</span><span class="punctuation">,</span> <span class="identifier">error_score</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">nan</span><span class="punctuation">,</span>
                 <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span><span class="punctuation">:</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span> <span class="arithmetic-assignment">=</span> <span class="identifier">scoring</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">estimator</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_jobs</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">refit</span> <span class="arithmetic-assignment">=</span> <span class="identifier">refit</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cv</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="arithmetic-assignment">=</span> <span class="identifier">verbose</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">pre_dispatch</span> <span class="arithmetic-assignment">=</span> <span class="identifier">pre_dispatch</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">error_score</span> <span class="arithmetic-assignment">=</span> <span class="identifier">error_score</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">e</span> <span class="arithmetic-assignment">=</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">e</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">_estimator_type</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="punctuation">.</span><span class="identifier">_estimator_type</span>

    <span class="keyword">def</span> <span class="identifier">_more_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># allows cross-validation to see 'precomputed' metrics</span>
        <span class="keyword">return</span> <span class="grouping">{</span>
            <span class="string-literal">'pairwise'</span><span class="punctuation">:</span> <span class="identifier">_safe_tags</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="string-literal">"pairwise"</span><span class="grouping">)</span><span class="punctuation">,</span>
            <span class="string-literal">"_xfail_checks": {"check_supervised_y_2d"</span><span class="punctuation">:</span>
                              <span class="string-literal">"DataConversionWarning not caught"</span><span class="grouping">}</span><span class="punctuation">,</span>
        <span class="grouping">}</span>

    <span class="comment"># TODO: Remove in 1.1</span>
    <span class="comment"># mypy error: Decorated property not supported</span>
    <span class="punctuation">@</span><span class="identifier">deprecated</span><span class="grouping">(</span><span class="string-literal">"Attribute _pairwise was deprecated in "</span>  <span class="comment"># type: ignore</span>
                <span class="string-literal">"version 0.24 and will be removed in 1.1 (renaming of 0.26)."</span><span class="grouping">)</span>
    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">_pairwise</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># allows cross-validation to see 'precomputed' metrics</span>
        <span class="keyword">return</span> <span class="identifier">getattr</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="string-literal">'_pairwise'</span><span class="punctuation">,</span> <span class="bool-literal">False</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">score</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Returns the score on the given data, if the estimator has been refit.

        This uses the score defined by ``scoring`` where provided, and the
        ``best_estimator_.score`` method otherwise.

        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Input data, where n_samples is the number of samples and
            n_features is the number of features.

        y : array-like of shape (n_samples, n_output) \
            or (n_samples,), default=None
            Target relative to X for classification or regression;
            None for unsupervised learning.

        Returns
        -------
        score : float
        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_is_fitted</span><span class="grouping">(</span><span class="string-literal">'score'</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scorer_</span> <span class="relational-operator">is</span> <span class="none-literal">None</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">"No score function explicitly defined, "</span>
                             <span class="string-literal">"and the estimator doesn't provide one %s"</span>
                             <span class="arithmetic-operator">%</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scorer_</span><span class="punctuation">,</span> <span class="identifier">dict</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">multimetric_</span><span class="punctuation">:</span>
                <span class="identifier">scorer</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scorer_</span><span class="grouping">[</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">refit</span><span class="grouping">]</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">scorer</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scorer_</span>
            <span class="keyword">return</span> <span class="identifier">scorer</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>

        <span class="comment"># callable</span>
        <span class="identifier">score</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scorer_</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">multimetric_</span><span class="punctuation">:</span>
            <span class="identifier">score</span> <span class="arithmetic-assignment">=</span> <span class="identifier">score</span><span class="grouping">[</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">refit</span><span class="grouping">]</span>
        <span class="keyword">return</span> <span class="identifier">score</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="string-literal">'best_estimator_', 'estimator'</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">score_samples</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Call score_samples on the estimator with the best found parameters.

        Only available if ``refit=True`` and the underlying estimator supports
        ``score_samples``.

        .. versionadded:: 0.24

        Parameters
        ----------
        X : iterable
            Data to predict on. Must fulfill input requirements
            of the underlying estimator.

        Returns
        -------
        y_score : ndarray of shape (n_samples,)
        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_is_fitted</span><span class="grouping">(</span><span class="string-literal">'score_samples'</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span><span class="punctuation">.</span><span class="identifier">score_samples</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">method_name</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">refit</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">NotFittedError</span><span class="grouping">(</span><span class="string-literal">'This %s instance was initialized '</span>
                                 <span class="string-literal">'with refit=False. %s is '</span>
                                 <span class="string-literal">'available only after refitting on the best '</span>
                                 <span class="string-literal">'parameters. You can refit an estimator '</span>
                                 <span class="string-literal">'manually using the ``best_params_`` '</span>
                                 <span class="string-literal">'attribute'</span>
                                 <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">type</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__name__</span><span class="punctuation">,</span> <span class="identifier">method_name</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="string-literal">'best_estimator_', 'estimator'</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Call predict on the estimator with the best found parameters.

        Only available if ``refit=True`` and the underlying estimator supports
        ``predict``.

        Parameters
        ----------
        X : indexable, length n_samples
            Must fulfill the input assumptions of the
            underlying estimator.

        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_is_fitted</span><span class="grouping">(</span><span class="string-literal">'predict'</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span><span class="punctuation">.</span><span class="identifier">predict</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="string-literal">'best_estimator_', 'estimator'</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Call predict_proba on the estimator with the best found parameters.

        Only available if ``refit=True`` and the underlying estimator supports
        ``predict_proba``.

        Parameters
        ----------
        X : indexable, length n_samples
            Must fulfill the input assumptions of the
            underlying estimator.

        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_is_fitted</span><span class="grouping">(</span><span class="string-literal">'predict_proba'</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span><span class="punctuation">.</span><span class="identifier">predict_proba</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="string-literal">'best_estimator_', 'estimator'</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">predict_log_proba</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Call predict_log_proba on the estimator with the best found parameters.

        Only available if ``refit=True`` and the underlying estimator supports
        ``predict_log_proba``.

        Parameters
        ----------
        X : indexable, length n_samples
            Must fulfill the input assumptions of the
            underlying estimator.

        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_is_fitted</span><span class="grouping">(</span><span class="string-literal">'predict_log_proba'</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span><span class="punctuation">.</span><span class="identifier">predict_log_proba</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="string-literal">'best_estimator_', 'estimator'</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">decision_function</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Call decision_function on the estimator with the best found parameters.

        Only available if ``refit=True`` and the underlying estimator supports
        ``decision_function``.

        Parameters
        ----------
        X : indexable, length n_samples
            Must fulfill the input assumptions of the
            underlying estimator.

        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_is_fitted</span><span class="grouping">(</span><span class="string-literal">'decision_function'</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span><span class="punctuation">.</span><span class="identifier">decision_function</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="string-literal">'best_estimator_', 'estimator'</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Call transform on the estimator with the best found parameters.

        Only available if the underlying estimator supports ``transform`` and
        ``refit=True``.

        Parameters
        ----------
        X : indexable, length n_samples
            Must fulfill the input assumptions of the
            underlying estimator.

        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_is_fitted</span><span class="grouping">(</span><span class="string-literal">'transform'</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span><span class="punctuation">.</span><span class="identifier">transform</span><span class="grouping">(</span><span class="identifier">X</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">_</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">_</span><span class="invalid">h</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">_</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">h</span><span class="invalid">o</span><span class="invalid">d</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">g</span><span class="invalid">a</span><span class="invalid">t</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span><span class="string-literal">'best_estimator_', 'estimator'</span><span class="grouping">)</span><span class="grouping">)</span>
    <span class="keyword">def</span> <span class="identifier">inverse_transform</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">Xt</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Call inverse_transform on the estimator with the best found params.

        Only available if the underlying estimator implements
        ``inverse_transform`` and ``refit=True``.

        Parameters
        ----------
        Xt : indexable, length n_samples
            Must fulfill the input assumptions of the
            underlying estimator.

        """</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_is_fitted</span><span class="grouping">(</span><span class="string-literal">'inverse_transform'</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span><span class="punctuation">.</span><span class="identifier">inverse_transform</span><span class="grouping">(</span><span class="identifier">Xt</span><span class="grouping">)</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="identifier">n_features_in_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment"># For consistency with other estimators we raise a AttributeError so</span>
        <span class="comment"># that hasattr() fails if the search estimator isn't fitted.</span>
        <span class="keyword">try</span><span class="punctuation">:</span>
            <span class="identifier">check_is_fitted</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span>
        <span class="keyword">except</span> <span class="identifier">NotFittedError</span> <span class="keyword">as</span> <span class="identifier">nfe</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">AttributeError</span><span class="grouping">(</span>
                <span class="string-literal">"{} object has no n_features_in_ attribute."</span>
                <span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">__class__</span><span class="punctuation">.</span><span class="identifier">__name__</span><span class="grouping">)</span>
            <span class="grouping">)</span> <span class="keyword">from</span> <span class="identifier">nfe</span>

        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span><span class="punctuation">.</span><span class="identifier">n_features_in_</span>

    <span class="punctuation">@</span><span class="identifier">property</span>
    <span class="keyword">def</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span><span class="grouping">(</span><span class="identifier">self</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_is_fitted</span><span class="grouping">(</span><span class="string-literal">"classes_"</span><span class="grouping">)</span>
        <span class="keyword">return</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span><span class="punctuation">.</span><span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">_</span>

    <span class="keyword">def</span> <span class="identifier">_run_search</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">evaluate_candidates</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Repeatedly calls `evaluate_candidates` to conduct a search.

        This method, implemented in sub-classes, makes it possible to
        customize the the scheduling of evaluations: GridSearchCV and
        RandomizedSearchCV schedule evaluations for their whole parameter
        search space at once but other more sequential approaches are also
        possible: for instance is possible to iteratively schedule evaluations
        for new regions of the parameter search space based on previously
        collected evaluation results. This makes it possible to implement
        Bayesian optimization or more generally sequential model-based
        optimization by deriving from the BaseSearchCV abstract base class.
        For example, Successive Halving is implemented by calling
        `evaluate_candidates` multiples times (once per iteration of the SH
        process), each time passing a different set of candidates with `X`
        and `y` of increasing sizes.

        Parameters
        ----------
        evaluate_candidates : callable
            This callback accepts:
                - a list of candidates, where each candidate is a dict of
                  parameter settings.
                - an optional `cv` parameter which can be used to e.g.
                  evaluate candidates on different dataset splits, or
                  evaluate candidates on subsampled data (as done in the
                  SucessiveHaling estimators). By default, the original `cv`
                  parameter is used, and it is available as a private
                  `_checked_cv_orig` attribute.
                - an optional `more_results` dict. Each key will be added to
                  the `cv_results_` attribute. Values should be lists of
                  length `n_candidates`

            It returns a dict of all results so far, formatted like
            ``cv_results_``.

            Important note (relevant whether the default cv is used or not):
            in randomized splitters, and unless the random_state parameter of
            cv was set to an int, calling cv.split() multiple times will
            yield different splits. Since cv.split() is called in
            evaluate_candidates, this means that candidates will be evaluated
            on different splits each time evaluate_candidates is called. This
            might be a methodological issue depending on the search strategy
            that you're implementing. To prevent randomized splitters from
            being used, you may use _split._yields_constant_splits()

        Examples
        --------

        ::

            def _run_search(self, evaluate_candidates):
                'Try C=0.1 only if C=1 is better than C=10'
                all_results = evaluate_candidates([{'C': 1}, {'C': 10}])
                score = all_results['mean_test_score']
                if score[0] &lt; score[1]:
                    evaluate_candidates([{'C': 0.1}])
        """</span>
        <span class="keyword">raise</span> <span class="identifier">NotImplementedError</span><span class="grouping">(</span><span class="string-literal">"_run_search not implemented."</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_check_refit_for_multimetric</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">scores</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Check `refit` is compatible with `scores` is valid"""</span>
        <span class="identifier">multimetric_refit_msg</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span>
            <span class="string-literal">"For multi-metric scoring, the parameter refit must be set to a "</span>
            <span class="string-literal">"scorer key or a callable to refit an estimator with the best "</span>
            <span class="string-literal">"parameter setting on the whole data and make the best_* "</span>
            <span class="string-literal">"attributes available for that metric. If this is not needed, "</span>
            <span class="identifier">f</span><span class="string-literal">"refit should be set to False explicitly. {self.refit!r} was "</span>
            <span class="string-literal">"passed."</span><span class="grouping">)</span>

        <span class="identifier">valid_refit_dict</span> <span class="arithmetic-assignment">=</span> <span class="grouping">(</span><span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">refit</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span> <span class="logical-operator">and</span>
                            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">refit</span> <span class="relational-operator">in</span> <span class="identifier">scores</span><span class="grouping">)</span>

        <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">refit</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="bool-literal">False</span> <span class="logical-operator">and</span> <span class="logical-operator">not</span> <span class="identifier">valid_refit_dict</span>
                <span class="logical-operator">and</span> <span class="logical-operator">not</span> <span class="identifier">callable</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">refit</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="identifier">multimetric_refit_msg</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Run fit with all sets of parameters.

        Parameters
        ----------

        X : array-like of shape (n_samples, n_features)
            Training vector, where n_samples is the number of samples and
            n_features is the number of features.

        y : array-like of shape (n_samples, n_output) \
            or (n_samples,), default=None
            Target relative to X for classification or regression;
            None for unsupervised learning.

        groups : array-like of shape (n_samples,), default=None
            Group labels for the samples used while splitting the dataset into
            train/test set. Only used in conjunction with a "Group" :term:`cv`
            instance (e.g., :class:`~sklearn.model_selection.GroupKFold`).

        **fit_params : dict of str -&gt; object
            Parameters passed to the ``fit`` method of the estimator
        """</span>
        <span class="identifier">estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span>
        <span class="identifier">refit_metric</span> <span class="arithmetic-assignment">=</span> <span class="string-literal">"score"</span>

        <span class="keyword">if</span> <span class="identifier">callable</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">scorers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span>
        <span class="keyword">elif</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span> <span class="relational-operator">is</span> <span class="none-literal">None</span> <span class="logical-operator">or</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span><span class="punctuation">,</span> <span class="identifier">str</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="identifier">scorers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_scoring</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span><span class="grouping">)</span>
        <span class="keyword">else</span><span class="punctuation">:</span>
            <span class="identifier">scorers</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_multimetric_scoring</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_refit_for_multimetric</span><span class="grouping">(</span><span class="identifier">scorers</span><span class="grouping">)</span>
            <span class="identifier">refit_metric</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">refit</span>

        <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span> <span class="arithmetic-assignment">=</span> <span class="identifier">indexable</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span>
        <span class="identifier">fit_params</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_check_fit_params</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">fit_params</span><span class="grouping">)</span>

        <span class="identifier">cv_orig</span> <span class="arithmetic-assignment">=</span> <span class="identifier">check_cv</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="invalid">c</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">s</span><span class="invalid">i</span><span class="invalid">f</span><span class="invalid">i</span><span class="invalid">e</span><span class="invalid">r</span><span class="arithmetic-assignment">=</span><span class="identifier">is_classifier</span><span class="grouping">(</span><span class="identifier">estimator</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="identifier">n_splits</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cv_orig</span><span class="punctuation">.</span><span class="identifier">get_n_splits</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span>

        <span class="identifier">base_estimator</span> <span class="arithmetic-assignment">=</span> <span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">estimator</span><span class="grouping">)</span>

        <span class="identifier">parallel</span> <span class="arithmetic-assignment">=</span> <span class="identifier">Parallel</span><span class="grouping">(</span><span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_jobs</span><span class="punctuation">,</span>
                            <span class="identifier">pre_dispatch</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">pre_dispatch</span><span class="grouping">)</span>

        <span class="identifier">fit_and_score_kwargs</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dict</span><span class="grouping">(</span><span class="identifier">scorer</span><span class="arithmetic-assignment">=</span><span class="identifier">scorers</span><span class="punctuation">,</span>
                                    <span class="identifier">fit_params</span><span class="arithmetic-assignment">=</span><span class="identifier">fit_params</span><span class="punctuation">,</span>
                                    <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">e</span><span class="punctuation">,</span>
                                    <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">s</span><span class="invalid">t</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">m</span><span class="invalid">p</span><span class="invalid">l</span><span class="invalid">e</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                                    <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">i</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                                    <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">p</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">m</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">e</span><span class="invalid">r</span><span class="invalid">s</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span>
                                    <span class="identifier">error_score</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">error_score</span><span class="punctuation">,</span>
                                    <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span><span class="grouping">)</span>
        <span class="identifier">results</span> <span class="arithmetic-assignment">=</span> <span class="grouping">{</span><span class="grouping">}</span>
        <span class="keyword">with</span> <span class="identifier">parallel</span><span class="punctuation">:</span>
            <span class="identifier">all_candidate_params</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
            <span class="identifier">all_out</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="grouping">]</span>
            <span class="identifier">all_more_results</span> <span class="arithmetic-assignment">=</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">d</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">list</span><span class="grouping">)</span>

            <span class="keyword">def</span> <span class="identifier">evaluate_candidates</span><span class="grouping">(</span><span class="identifier">candidate_params</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                                    <span class="identifier">more_results</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">cv</span> <span class="arithmetic-assignment">=</span> <span class="identifier">cv</span> <span class="logical-operator">or</span> <span class="identifier">cv_orig</span>
                <span class="identifier">candidate_params</span> <span class="arithmetic-assignment">=</span> <span class="identifier">list</span><span class="grouping">(</span><span class="identifier">candidate_params</span><span class="grouping">)</span>
                <span class="identifier">n_candidates</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">candidate_params</span><span class="grouping">)</span>

                <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">verbose</span> <span class="relational-operator">&gt;</span> <span class="int-literal">0</span><span class="punctuation">:</span>
                    <span class="identifier">print</span><span class="grouping">(</span><span class="string-literal">"Fitting {0} folds for each of {1} candidates,"</span>
                          <span class="string-literal">" totalling {2} fits"</span><span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span>
                              <span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="identifier">n_candidates</span><span class="punctuation">,</span> <span class="identifier">n_candidates</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_splits</span><span class="grouping">)</span><span class="grouping">)</span>

                <span class="identifier">out</span> <span class="arithmetic-assignment">=</span> <span class="identifier">parallel</span><span class="grouping">(</span><span class="invalid">d</span><span class="invalid">e</span><span class="invalid">l</span><span class="invalid">a</span><span class="invalid">y</span><span class="invalid">e</span><span class="invalid">d</span><span class="grouping">(</span><span class="identifier">_fit_and_score</span><span class="grouping">)</span><span class="grouping">(</span><span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">base_estimator</span><span class="grouping">)</span><span class="punctuation">,</span>
                                                       <span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span>
                                                       <span class="identifier">train</span><span class="arithmetic-assignment">=</span><span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span><span class="arithmetic-assignment">=</span><span class="identifier">test</span><span class="punctuation">,</span>
                                                       <span class="identifier">parameters</span><span class="arithmetic-assignment">=</span><span class="identifier">parameters</span><span class="punctuation">,</span>
                                                       <span class="identifier">split_progress</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span>
                                                           <span class="identifier">split_idx</span><span class="punctuation">,</span>
                                                           <span class="identifier">n_splits</span><span class="grouping">)</span><span class="punctuation">,</span>
                                                       <span class="identifier">candidate_progress</span><span class="arithmetic-assignment">=</span><span class="grouping">(</span>
                                                           <span class="identifier">cand_idx</span><span class="punctuation">,</span>
                                                           <span class="identifier">n_candidates</span><span class="grouping">)</span><span class="punctuation">,</span>
                                                       <span class="arithmetic-operator">**</span><span class="identifier">fit_and_score_kwargs</span><span class="grouping">)</span>
                               <span class="keyword">for</span> <span class="grouping">(</span><span class="identifier">cand_idx</span><span class="punctuation">,</span> <span class="identifier">parameters</span><span class="grouping">)</span><span class="punctuation">,</span>
                                   <span class="grouping">(</span><span class="identifier">split_idx</span><span class="punctuation">,</span> <span class="grouping">(</span><span class="identifier">train</span><span class="punctuation">,</span> <span class="identifier">test</span><span class="grouping">)</span><span class="grouping">)</span> <span class="relational-operator">in</span> <span class="identifier">product</span><span class="grouping">(</span>
                                   <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">candidate_params</span><span class="grouping">)</span><span class="punctuation">,</span>
                                   <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">cv</span><span class="punctuation">.</span><span class="identifier">split</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="identifier">groups</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span>

                <span class="keyword">if</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">out</span><span class="grouping">)</span> <span class="relational-operator">&lt;</span> <span class="int-literal">1</span><span class="punctuation">:</span>
                    <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'No fits were performed. '</span>
                                     <span class="string-literal">'Was the CV iterator empty? '</span>
                                     <span class="string-literal">'Were there no candidates?'</span><span class="grouping">)</span>
                <span class="keyword">elif</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">out</span><span class="grouping">)</span> <span class="relational-operator">!=</span> <span class="identifier">n_candidates</span> <span class="arithmetic-operator">*</span> <span class="identifier">n_splits</span><span class="punctuation">:</span>
                    <span class="keyword">raise</span> <span class="identifier">ValueError</span><span class="grouping">(</span><span class="string-literal">'cv.split and cv.get_n_splits returned '</span>
                                     <span class="string-literal">'inconsistent results. Expected {} '</span>
                                     <span class="string-literal">'splits, got {}'</span>
                                     <span class="punctuation">.</span><span class="invalid">f</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">m</span><span class="invalid">a</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">n_splits</span><span class="punctuation">,</span>
                                             <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">out</span><span class="grouping">)</span> <span class="arithmetic-operator">//</span> <span class="identifier">n_candidates</span><span class="grouping">)</span><span class="grouping">)</span>

                <span class="comment"># For callable self.scoring, the return type is only know after</span>
                <span class="comment"># calling. If the return type is a dictionary, the error scores</span>
                <span class="comment"># can now be inserted with the correct key. The type checking</span>
                <span class="comment"># of out will be done in `_insert_error_scores`.</span>
                <span class="keyword">if</span> <span class="identifier">callable</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="identifier">_insert_error_scores</span><span class="grouping">(</span><span class="identifier">out</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">error_score</span><span class="grouping">)</span>
                <span class="identifier">all_candidate_params</span><span class="punctuation">.</span><span class="identifier">extend</span><span class="grouping">(</span><span class="identifier">candidate_params</span><span class="grouping">)</span>
                <span class="identifier">all_out</span><span class="punctuation">.</span><span class="identifier">extend</span><span class="grouping">(</span><span class="identifier">out</span><span class="grouping">)</span>
                <span class="keyword">if</span> <span class="identifier">more_results</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                    <span class="keyword">for</span> <span class="identifier">key</span><span class="punctuation">,</span> <span class="identifier">value</span> <span class="relational-operator">in</span> <span class="identifier">more_results</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
                        <span class="identifier">all_more_results</span><span class="grouping">[</span><span class="identifier">key</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">extend</span><span class="grouping">(</span><span class="identifier">value</span><span class="grouping">)</span>

                <span class="keyword">nonlocal</span> <span class="identifier">results</span>
                <span class="identifier">results</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_format_results</span><span class="grouping">(</span>
                    <span class="identifier">all_candidate_params</span><span class="punctuation">,</span> <span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="identifier">all_out</span><span class="punctuation">,</span>
                    <span class="identifier">all_more_results</span><span class="grouping">)</span>

                <span class="keyword">return</span> <span class="identifier">results</span>

            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_run_search</span><span class="grouping">(</span><span class="identifier">evaluate_candidates</span><span class="grouping">)</span>

            <span class="comment"># multimetric is determined here because in the case of a callable</span>
            <span class="comment"># self.scoring the return type is only known after calling</span>
            <span class="identifier">first_test_score</span> <span class="arithmetic-assignment">=</span> <span class="identifier">all_out</span><span class="grouping">[</span><span class="int-literal">0</span><span class="grouping">]</span><span class="grouping">[</span><span class="string-literal">'test_scores'</span><span class="grouping">]</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">multimetric_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">first_test_score</span><span class="punctuation">,</span> <span class="identifier">dict</span><span class="grouping">)</span>

            <span class="comment"># check refit_metric now for a callabe scorer that is multimetric</span>
            <span class="keyword">if</span> <span class="identifier">callable</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scoring</span><span class="grouping">)</span> <span class="logical-operator">and</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">multimetric_</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">_check_refit_for_multimetric</span><span class="grouping">(</span><span class="identifier">first_test_score</span><span class="grouping">)</span>
                <span class="identifier">refit_metric</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">refit</span>

        <span class="comment"># For multi-metric evaluation, store the best_index_, best_params_ and</span>
        <span class="comment"># best_score_ iff refit is one of the scorer names</span>
        <span class="comment"># In single metric evaluation, refit_metric is "score"</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">refit</span> <span class="logical-operator">or</span> <span class="logical-operator">not</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">multimetric_</span><span class="punctuation">:</span>
            <span class="comment"># If callable, refit is expected to return the index of the best</span>
            <span class="comment"># parameter set.</span>
            <span class="keyword">if</span> <span class="identifier">callable</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">refit</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_index_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">refit</span><span class="grouping">(</span><span class="identifier">results</span><span class="grouping">)</span>
                <span class="keyword">if</span> <span class="logical-operator">not</span> <span class="identifier">isinstance</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_index_</span><span class="punctuation">,</span> <span class="identifier">numbers</span><span class="punctuation">.</span><span class="identifier">Integral</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="keyword">raise</span> <span class="identifier">TypeError</span><span class="grouping">(</span><span class="string-literal">'best_index_ returned is not an integer'</span><span class="grouping">)</span>
                <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_index_</span> <span class="relational-operator">&lt;</span> <span class="int-literal">0</span> <span class="logical-operator">or</span>
                   <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_index_</span> <span class="relational-operator">&gt;=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">results</span><span class="grouping">[</span><span class="string-literal">"params"</span><span class="grouping">]</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="keyword">raise</span> <span class="identifier">IndexError</span><span class="grouping">(</span><span class="string-literal">'best_index_ index out of range'</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_index_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">results</span><span class="grouping">[</span><span class="string-literal">"rank_test_%s"</span>
                                           <span class="arithmetic-operator">%</span> <span class="identifier">refit_metric</span><span class="grouping">]</span><span class="punctuation">.</span><span class="identifier">argmin</span><span class="grouping">(</span><span class="grouping">)</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_score_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">results</span><span class="grouping">[</span><span class="string-literal">"mean_test_%s"</span> <span class="arithmetic-operator">%</span> <span class="identifier">refit_metric</span><span class="grouping">]</span><span class="grouping">[</span>
                                           <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_index_</span><span class="grouping">]</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_params_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">results</span><span class="grouping">[</span><span class="string-literal">"params"</span><span class="grouping">]</span><span class="grouping">[</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_index_</span><span class="grouping">]</span>

        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">refit</span><span class="punctuation">:</span>
            <span class="comment"># we clone again after setting params in case some</span>
            <span class="comment"># of the params are estimators as well.</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">clone</span><span class="grouping">(</span><span class="identifier">base_estimator</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">set_params</span><span class="grouping">(</span>
                <span class="arithmetic-operator">**</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_params_</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">refit_start_time</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="punctuation">.</span><span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">y</span> <span class="relational-operator">is</span> <span class="logical-operator">not</span> <span class="none-literal">None</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="identifier">y</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span>
            <span class="keyword">else</span><span class="punctuation">:</span>
                <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">best_estimator_</span><span class="punctuation">.</span><span class="identifier">fit</span><span class="grouping">(</span><span class="identifier">X</span><span class="punctuation">,</span> <span class="arithmetic-operator">**</span><span class="identifier">fit_params</span><span class="grouping">)</span>
            <span class="identifier">refit_end_time</span> <span class="arithmetic-assignment">=</span> <span class="identifier">time</span><span class="punctuation">.</span><span class="identifier">time</span><span class="grouping">(</span><span class="grouping">)</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">refit_time_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">refit_end_time</span> <span class="arithmetic-operator">-</span> <span class="identifier">refit_start_time</span>

        <span class="comment"># Store the only scorer not as a dict for single metric evaluation</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">scorer_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">scorers</span>

        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">cv_results_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">results</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_splits_</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_splits</span>

        <span class="keyword">return</span> <span class="identifier">self</span>

    <span class="keyword">def</span> <span class="identifier">_format_results</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">candidate_params</span><span class="punctuation">,</span> <span class="identifier">n_splits</span><span class="punctuation">,</span> <span class="identifier">out</span><span class="punctuation">,</span>
                        <span class="identifier">more_results</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">n_candidates</span> <span class="arithmetic-assignment">=</span> <span class="identifier">len</span><span class="grouping">(</span><span class="identifier">candidate_params</span><span class="grouping">)</span>
        <span class="identifier">out</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_aggregate_score_dicts</span><span class="grouping">(</span><span class="identifier">out</span><span class="grouping">)</span>

        <span class="identifier">results</span> <span class="arithmetic-assignment">=</span> <span class="identifier">dict</span><span class="grouping">(</span><span class="identifier">more_results</span> <span class="logical-operator">or</span> <span class="grouping">{</span><span class="grouping">}</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">key</span><span class="punctuation">,</span> <span class="identifier">val</span> <span class="relational-operator">in</span> <span class="identifier">results</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment"># each value is a list (as per evaluate_candidate's convention)</span>
            <span class="comment"># we convert it to an array for consistency with the other keys</span>
            <span class="identifier">results</span><span class="grouping">[</span><span class="identifier">key</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span><span class="identifier">val</span><span class="grouping">)</span>

        <span class="keyword">def</span> <span class="identifier">_store</span><span class="grouping">(</span><span class="identifier">key_name</span><span class="punctuation">,</span> <span class="identifier">array</span><span class="punctuation">,</span> <span class="identifier">weights</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">splits</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="punctuation">,</span> <span class="identifier">rank</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="comment">"""A small helper to store the scores/times to the cv_results_"""</span>
            <span class="comment"># When iterated first by splits, then by parameters</span>
            <span class="comment"># We want `array` to have `n_candidates` rows and `n_splits` cols.</span>
            <span class="identifier">array</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">array</span><span class="grouping">(</span><span class="identifier">array</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">float64</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">reshape</span><span class="grouping">(</span><span class="identifier">n_candidates</span><span class="punctuation">,</span>
                                                              <span class="identifier">n_splits</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">splits</span><span class="punctuation">:</span>
                <span class="keyword">for</span> <span class="identifier">split_idx</span> <span class="relational-operator">in</span> <span class="identifier">range</span><span class="grouping">(</span><span class="identifier">n_splits</span><span class="grouping">)</span><span class="punctuation">:</span>
                    <span class="comment"># Uses closure to alter the results</span>
                    <span class="identifier">results</span><span class="grouping">[</span><span class="string-literal">"split%d_%s"</span>
                            <span class="arithmetic-operator">%</span> <span class="grouping">(</span><span class="identifier">split_idx</span><span class="punctuation">,</span> <span class="identifier">key_name</span><span class="grouping">)</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">array</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">split_idx</span><span class="grouping">]</span>

            <span class="identifier">array_means</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">average</span><span class="grouping">(</span><span class="identifier">array</span><span class="punctuation">,</span> <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">weights</span><span class="arithmetic-assignment">=</span><span class="identifier">weights</span><span class="grouping">)</span>
            <span class="identifier">results</span><span class="grouping">[</span><span class="string-literal">'mean_%s'</span> <span class="arithmetic-operator">%</span> <span class="identifier">key_name</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">array_means</span>

            <span class="keyword">if</span> <span class="grouping">(</span><span class="identifier">key_name</span><span class="punctuation">.</span><span class="identifier">startswith</span><span class="grouping">(</span><span class="grouping">(</span><span class="string-literal">"train_", "test_"</span><span class="grouping">)</span><span class="grouping">)</span> <span class="logical-operator">and</span>
                    <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">any</span><span class="grouping">(</span><span class="bitwise-operator">~</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">isfinite</span><span class="grouping">(</span><span class="identifier">array_means</span><span class="grouping">)</span><span class="grouping">)</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="identifier">warnings</span><span class="punctuation">.</span><span class="identifier">warn</span><span class="grouping">(</span>
                    <span class="identifier">f</span><span class="string-literal">"One or more of the {key_name.split('_')[0]} scores "</span>
                    <span class="identifier">f</span><span class="string-literal">"are non-finite: {array_means}"</span><span class="punctuation">,</span>
                    <span class="identifier">category</span><span class="arithmetic-assignment">=</span><span class="identifier">UserWarning</span>
                <span class="grouping">)</span>

            <span class="comment"># Weighted std is not directly available in numpy</span>
            <span class="identifier">array_stds</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">sqrt</span><span class="grouping">(</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">average</span><span class="grouping">(</span><span class="grouping">(</span><span class="identifier">array</span> <span class="arithmetic-operator">-</span>
                                             <span class="identifier">array_means</span><span class="grouping">[</span><span class="punctuation">:</span><span class="punctuation">,</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">newaxis</span><span class="grouping">]</span><span class="grouping">)</span> <span class="arithmetic-operator">**</span> <span class="int-literal">2</span><span class="punctuation">,</span>
                                            <span class="identifier">axis</span><span class="arithmetic-assignment">=</span><span class="int-literal">1</span><span class="punctuation">,</span> <span class="identifier">weights</span><span class="arithmetic-assignment">=</span><span class="identifier">weights</span><span class="grouping">)</span><span class="grouping">)</span>
            <span class="identifier">results</span><span class="grouping">[</span><span class="string-literal">'std_%s'</span> <span class="arithmetic-operator">%</span> <span class="identifier">key_name</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">array_stds</span>

            <span class="keyword">if</span> <span class="identifier">rank</span><span class="punctuation">:</span>
                <span class="identifier">results</span><span class="grouping">[</span><span class="string-literal">"rank_%s"</span> <span class="arithmetic-operator">%</span> <span class="identifier">key_name</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">np</span><span class="punctuation">.</span><span class="invalid">a</span><span class="invalid">s</span><span class="invalid">a</span><span class="invalid">r</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">y</span><span class="grouping">(</span>
                    <span class="identifier">rankdata</span><span class="grouping">(</span><span class="arithmetic-operator">-</span><span class="identifier">array_means</span><span class="punctuation">,</span> <span class="identifier">method</span><span class="arithmetic-assignment">=</span><span class="string-literal">'min'</span><span class="grouping">)</span><span class="punctuation">,</span> <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">int32</span><span class="grouping">)</span>

        <span class="identifier">_store</span><span class="grouping">(</span><span class="string-literal">'fit_time'</span><span class="punctuation">,</span> <span class="identifier">out</span><span class="grouping">[</span><span class="string-literal">"fit_time"</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="identifier">_store</span><span class="grouping">(</span><span class="string-literal">'score_time'</span><span class="punctuation">,</span> <span class="identifier">out</span><span class="grouping">[</span><span class="string-literal">"score_time"</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="comment"># Use one MaskedArray and mask all the places where the param is not</span>
        <span class="comment"># applicable for that candidate. Use defaultdict as each candidate may</span>
        <span class="comment"># not contain all the params</span>
        <span class="identifier">param_results</span> <span class="arithmetic-assignment">=</span> <span class="invalid">d</span><span class="invalid">e</span><span class="invalid">f</span><span class="invalid">a</span><span class="invalid">u</span><span class="invalid">l</span><span class="invalid">t</span><span class="invalid">d</span><span class="invalid">i</span><span class="invalid">c</span><span class="invalid">t</span><span class="grouping">(</span><span class="identifier">partial</span><span class="grouping">(</span><span class="identifier">MaskedArray</span><span class="punctuation">,</span>
                                            <span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">empty</span><span class="grouping">(</span><span class="identifier">n_candidates</span><span class="punctuation">,</span><span class="grouping">)</span><span class="punctuation">,</span>
                                            <span class="identifier">mask</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                                            <span class="identifier">dtype</span><span class="arithmetic-assignment">=</span><span class="identifier">object</span><span class="grouping">)</span><span class="grouping">)</span>
        <span class="keyword">for</span> <span class="identifier">cand_idx</span><span class="punctuation">,</span> <span class="identifier">params</span> <span class="relational-operator">in</span> <span class="identifier">enumerate</span><span class="grouping">(</span><span class="identifier">candidate_params</span><span class="grouping">)</span><span class="punctuation">:</span>
            <span class="keyword">for</span> <span class="identifier">name</span><span class="punctuation">,</span> <span class="identifier">value</span> <span class="relational-operator">in</span> <span class="identifier">params</span><span class="punctuation">.</span><span class="identifier">items</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">:</span>
                <span class="comment"># An all masked empty array gets created for the key</span>
                <span class="comment"># `"param_%s" % name` at the first occurrence of `name`.</span>
                <span class="comment"># Setting the value at an index also unmasks that index</span>
                <span class="identifier">param_results</span><span class="grouping">[</span><span class="string-literal">"param_%s"</span> <span class="arithmetic-operator">%</span> <span class="identifier">name</span><span class="grouping">]</span><span class="grouping">[</span><span class="identifier">cand_idx</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">value</span>

        <span class="identifier">results</span><span class="punctuation">.</span><span class="identifier">update</span><span class="grouping">(</span><span class="identifier">param_results</span><span class="grouping">)</span>
        <span class="comment"># Store a list of param dicts at the key 'params'</span>
        <span class="identifier">results</span><span class="grouping">[</span><span class="string-literal">'params'</span><span class="grouping">]</span> <span class="arithmetic-assignment">=</span> <span class="identifier">candidate_params</span>

        <span class="identifier">test_scores_dict</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_normalize_score_results</span><span class="grouping">(</span><span class="identifier">out</span><span class="grouping">[</span><span class="string-literal">"test_scores"</span><span class="grouping">]</span><span class="grouping">)</span>
        <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">e</span><span class="punctuation">:</span>
            <span class="identifier">train_scores_dict</span> <span class="arithmetic-assignment">=</span> <span class="identifier">_normalize_score_results</span><span class="grouping">(</span><span class="identifier">out</span><span class="grouping">[</span><span class="string-literal">"train_scores"</span><span class="grouping">]</span><span class="grouping">)</span>

        <span class="keyword">for</span> <span class="identifier">scorer_name</span> <span class="relational-operator">in</span> <span class="identifier">test_scores_dict</span><span class="punctuation">:</span>
            <span class="comment"># Computed the (weighted) mean and std for test scores alone</span>
            <span class="identifier">_store</span><span class="grouping">(</span><span class="string-literal">'test_%s'</span> <span class="arithmetic-operator">%</span> <span class="identifier">scorer_name</span><span class="punctuation">,</span> <span class="identifier">test_scores_dict</span><span class="grouping">[</span><span class="identifier">scorer_name</span><span class="grouping">]</span><span class="punctuation">,</span>
                   <span class="identifier">splits</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">rank</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                   <span class="identifier">weights</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="grouping">)</span>
            <span class="keyword">if</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">e</span><span class="punctuation">:</span>
                <span class="identifier">_store</span><span class="grouping">(</span><span class="string-literal">'train_%s'</span> <span class="arithmetic-operator">%</span> <span class="identifier">scorer_name</span><span class="punctuation">,</span>
                       <span class="identifier">train_scores_dict</span><span class="grouping">[</span><span class="identifier">scorer_name</span><span class="grouping">]</span><span class="punctuation">,</span>
                       <span class="identifier">splits</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="grouping">)</span>

        <span class="keyword">return</span> <span class="identifier">results</span>


<span class="keyword">class</span> <span class="identifier">GridSearchCV</span><span class="grouping">(</span><span class="identifier">BaseSearchCV</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Exhaustive search over specified parameter values for an estimator.

    Important members are fit, predict.

    GridSearchCV implements a "fit" and a "score" method.
    It also implements "score_samples", "predict", "predict_proba",
    "decision_function", "transform" and "inverse_transform" if they are
    implemented in the estimator used.

    The parameters of the estimator used to apply these methods are optimized
    by cross-validated grid-search over a parameter grid.

    Read more in the :ref:`User Guide &lt;grid_search&gt;`.

    Parameters
    ----------
    estimator : estimator object.
        This is assumed to implement the scikit-learn estimator interface.
        Either estimator needs to provide a ``score`` function,
        or ``scoring`` must be passed.

    param_grid : dict or list of dictionaries
        Dictionary with parameters names (`str`) as keys and lists of
        parameter settings to try as values, or a list of such
        dictionaries, in which case the grids spanned by each dictionary
        in the list are explored. This enables searching over any sequence
        of parameter settings.

    scoring : str, callable, list, tuple or dict, default=None
        Strategy to evaluate the performance of the cross-validated model on
        the test set.

        If `scoring` represents a single score, one can use:

        - a single string (see :ref:`scoring_parameter`);
        - a callable (see :ref:`scoring`) that returns a single value.

        If `scoring` represents multiple scores, one can use:

        - a list or tuple of unique strings;
        - a callable returning a dictionary where the keys are the metric
          names and the values are the metric scores;
        - a dictionary with metric names as keys and callables a values.

        See :ref:`multimetric_grid_search` for an example.

    n_jobs : int, default=None
        Number of jobs to run in parallel.
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

        .. versionchanged:: v0.20
           `n_jobs` default changed from 1 to None

    refit : bool, str, or callable, default=True
        Refit an estimator using the best found parameters on the whole
        dataset.

        For multiple metric evaluation, this needs to be a `str` denoting the
        scorer that would be used to find the best parameters for refitting
        the estimator at the end.

        Where there are considerations other than maximum score in
        choosing a best estimator, ``refit`` can be set to a function which
        returns the selected ``best_index_`` given ``cv_results_``. In that
        case, the ``best_estimator_`` and ``best_params_`` will be set
        according to the returned ``best_index_`` while the ``best_score_``
        attribute will not be available.

        The refitted estimator is made available at the ``best_estimator_``
        attribute and permits using ``predict`` directly on this
        ``GridSearchCV`` instance.

        Also for multiple metric evaluation, the attributes ``best_index_``,
        ``best_score_`` and ``best_params_`` will only be available if
        ``refit`` is set and all of them will be determined w.r.t this specific
        scorer.

        See ``scoring`` parameter to know more about multiple metric
        evaluation.

        .. versionchanged:: 0.20
            Support for callable added.

    cv : int, cross-validation generator or an iterable, default=None
        Determines the cross-validation splitting strategy.
        Possible inputs for cv are:

        - None, to use the default 5-fold cross validation,
        - integer, to specify the number of folds in a `(Stratified)KFold`,
        - :term:`CV splitter`,
        - An iterable yielding (train, test) splits as arrays of indices.

        For integer/None inputs, if the estimator is a classifier and ``y`` is
        either binary or multiclass, :class:`StratifiedKFold` is used. In all
        other cases, :class:`KFold` is used. These splitters are instantiated
        with `shuffle=False` so the splits will be the same across calls.

        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
        cross-validation strategies that can be used here.

        .. versionchanged:: 0.22
            ``cv`` default value if None changed from 3-fold to 5-fold.

    verbose : int
        Controls the verbosity: the higher, the more messages.

        - &gt;1 : the computation time for each fold and parameter candidate is
          displayed;
        - &gt;2 : the score is also displayed;
        - &gt;3 : the fold and candidate parameter indexes are also displayed
          together with the starting time of the computation.

    pre_dispatch : int, or str, default=n_jobs
        Controls the number of jobs that get dispatched during parallel
        execution. Reducing this number can be useful to avoid an
        explosion of memory consumption when more jobs get dispatched
        than CPUs can process. This parameter can be:

            - None, in which case all the jobs are immediately
              created and spawned. Use this for lightweight and
              fast-running jobs, to avoid delays due to on-demand
              spawning of the jobs

            - An int, giving the exact number of total jobs that are
              spawned

            - A str, giving an expression as a function of n_jobs,
              as in '2*n_jobs'

    error_score : 'raise' or numeric, default=np.nan
        Value to assign to the score if an error occurs in estimator fitting.
        If set to 'raise', the error is raised. If a numeric value is given,
        FitFailedWarning is raised. This parameter does not affect the refit
        step, which will always raise the error.

    return_train_score : bool, default=False
        If ``False``, the ``cv_results_`` attribute will not include training
        scores.
        Computing training scores is used to get insights on how different
        parameter settings impact the overfitting/underfitting trade-off.
        However computing the scores on the training set can be computationally
        expensive and is not strictly required to select the parameters that
        yield the best generalization performance.

        .. versionadded:: 0.19

        .. versionchanged:: 0.21
            Default value was changed from ``True`` to ``False``


    Examples
    --------
    &gt;&gt;&gt; from sklearn import svm, datasets
    &gt;&gt;&gt; from sklearn.model_selection import GridSearchCV
    &gt;&gt;&gt; iris = datasets.load_iris()
    &gt;&gt;&gt; parameters = {'kernel':('linear', 'rbf'), 'C':[1, 10]}
    &gt;&gt;&gt; svc = svm.SVC()
    &gt;&gt;&gt; clf = GridSearchCV(svc, parameters)
    &gt;&gt;&gt; clf.fit(iris.data, iris.target)
    GridSearchCV(estimator=SVC(),
                 param_grid={'C': [1, 10], 'kernel': ('linear', 'rbf')})
    &gt;&gt;&gt; sorted(clf.cv_results_.keys())
    ['mean_fit_time', 'mean_score_time', 'mean_test_score',...
     'param_C', 'param_kernel', 'params',...
     'rank_test_score', 'split0_test_score',...
     'split2_test_score', ...
     'std_fit_time', 'std_score_time', 'std_test_score']

    Attributes
    ----------
    cv_results_ : dict of numpy (masked) ndarrays
        A dict with keys as column headers and values as columns, that can be
        imported into a pandas ``DataFrame``.

        For instance the below given table

        +------------+-----------+------------+-----------------+---+---------+
        |param_kernel|param_gamma|param_degree|split0_test_score|...|rank_t...|
        +============+===========+============+=================+===+=========+
        |  'poly'    |     --    |      2     |       0.80      |...|    2    |
        +------------+-----------+------------+-----------------+---+---------+
        |  'poly'    |     --    |      3     |       0.70      |...|    4    |
        +------------+-----------+------------+-----------------+---+---------+
        |  'rbf'     |     0.1   |     --     |       0.80      |...|    3    |
        +------------+-----------+------------+-----------------+---+---------+
        |  'rbf'     |     0.2   |     --     |       0.93      |...|    1    |
        +------------+-----------+------------+-----------------+---+---------+

        will be represented by a ``cv_results_`` dict of::

            {
            'param_kernel': masked_array(data = ['poly', 'poly', 'rbf', 'rbf'],
                                         mask = [False False False False]...)
            'param_gamma': masked_array(data = [-- -- 0.1 0.2],
                                        mask = [ True  True False False]...),
            'param_degree': masked_array(data = [2.0 3.0 -- --],
                                         mask = [False False  True  True]...),
            'split0_test_score'  : [0.80, 0.70, 0.80, 0.93],
            'split1_test_score'  : [0.82, 0.50, 0.70, 0.78],
            'mean_test_score'    : [0.81, 0.60, 0.75, 0.85],
            'std_test_score'     : [0.01, 0.10, 0.05, 0.08],
            'rank_test_score'    : [2, 4, 3, 1],
            'split0_train_score' : [0.80, 0.92, 0.70, 0.93],
            'split1_train_score' : [0.82, 0.55, 0.70, 0.87],
            'mean_train_score'   : [0.81, 0.74, 0.70, 0.90],
            'std_train_score'    : [0.01, 0.19, 0.00, 0.03],
            'mean_fit_time'      : [0.73, 0.63, 0.43, 0.49],
            'std_fit_time'       : [0.01, 0.02, 0.01, 0.01],
            'mean_score_time'    : [0.01, 0.06, 0.04, 0.04],
            'std_score_time'     : [0.00, 0.00, 0.00, 0.01],
            'params'             : [{'kernel': 'poly', 'degree': 2}, ...],
            }

        NOTE

        The key ``'params'`` is used to store a list of parameter
        settings dicts for all the parameter candidates.

        The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and
        ``std_score_time`` are all in seconds.

        For multi-metric evaluation, the scores for all the scorers are
        available in the ``cv_results_`` dict at the keys ending with that
        scorer's name (``'_&lt;scorer_name&gt;'``) instead of ``'_score'`` shown
        above. ('split0_test_precision', 'mean_train_precision' etc.)

    best_estimator_ : estimator
        Estimator that was chosen by the search, i.e. estimator
        which gave highest score (or smallest loss if specified)
        on the left out data. Not available if ``refit=False``.

        See ``refit`` parameter for more information on allowed values.

    best_score_ : float
        Mean cross-validated score of the best_estimator

        For multi-metric evaluation, this is present only if ``refit`` is
        specified.

        This attribute is not available if ``refit`` is a function.

    best_params_ : dict
        Parameter setting that gave the best results on the hold out data.

        For multi-metric evaluation, this is present only if ``refit`` is
        specified.

    best_index_ : int
        The index (of the ``cv_results_`` arrays) which corresponds to the best
        candidate parameter setting.

        The dict at ``search.cv_results_['params'][search.best_index_]`` gives
        the parameter setting for the best model, that gives the highest
        mean score (``search.best_score_``).

        For multi-metric evaluation, this is present only if ``refit`` is
        specified.

    scorer_ : function or a dict
        Scorer function used on the held out data to choose the best
        parameters for the model.

        For multi-metric evaluation, this attribute holds the validated
        ``scoring`` dict which maps the scorer key to the scorer callable.

    n_splits_ : int
        The number of cross-validation splits (folds/iterations).

    refit_time_ : float
        Seconds used for refitting the best model on the whole dataset.

        This is present only if ``refit`` is not False.

        .. versionadded:: 0.20

    multimetric_ : bool
        Whether or not the scorers compute several metrics.

    Notes
    -----
    The parameters selected are those that maximize the score of the left out
    data, unless an explicit score is passed in which case it is used instead.

    If `n_jobs` was set to a value higher than one, the data is copied for each
    point in the grid (and not `n_jobs` times). This is done for efficiency
    reasons if individual jobs take very little time, but may raise errors if
    the dataset is large and not enough memory is available.  A workaround in
    this case is to set `pre_dispatch`. Then, the memory is copied only
    `pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *
    n_jobs`.

    See Also
    ---------
    ParameterGrid : Generates all the combinations of a hyperparameter grid.
    train_test_split : Utility function to split the data into a development
        set usable for fitting a GridSearchCV instance and an evaluation set
        for its final evaluation.
    sklearn.metrics.make_scorer : Make a scorer from a performance metric or
        loss function.

    """</span>
    <span class="identifier">_required_parameters</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="string-literal">"estimator", "param_grid"</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">param_grid</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">scoring</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">refit</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span>
                 <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">pre_dispatch</span><span class="arithmetic-assignment">=</span><span class="string-literal">'2*n_jobs'</span><span class="punctuation">,</span>
                 <span class="identifier">error_score</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">nan</span><span class="punctuation">,</span> <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">estimator</span><span class="arithmetic-assignment">=</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">scoring</span><span class="arithmetic-assignment">=</span><span class="identifier">scoring</span><span class="punctuation">,</span>
            <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">n_jobs</span><span class="punctuation">,</span> <span class="identifier">refit</span><span class="arithmetic-assignment">=</span><span class="identifier">refit</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="punctuation">,</span>
            <span class="identifier">pre_dispatch</span><span class="arithmetic-assignment">=</span><span class="identifier">pre_dispatch</span><span class="punctuation">,</span> <span class="identifier">error_score</span><span class="arithmetic-assignment">=</span><span class="identifier">error_score</span><span class="punctuation">,</span>
            <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">e</span><span class="grouping">)</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">param_grid</span> <span class="arithmetic-assignment">=</span> <span class="identifier">param_grid</span>
        <span class="identifier">_check_param_grid</span><span class="grouping">(</span><span class="identifier">param_grid</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_run_search</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">evaluate_candidates</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Search all candidates in param_grid"""</span>
        <span class="identifier">evaluate_candidates</span><span class="grouping">(</span><span class="identifier">ParameterGrid</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">param_grid</span><span class="grouping">)</span><span class="grouping">)</span>


<span class="keyword">class</span> <span class="identifier">RandomizedSearchCV</span><span class="grouping">(</span><span class="identifier">BaseSearchCV</span><span class="grouping">)</span><span class="punctuation">:</span>
    <span class="comment">"""Randomized search on hyper parameters.

    RandomizedSearchCV implements a "fit" and a "score" method.
    It also implements "score_samples", "predict", "predict_proba",
    "decision_function", "transform" and "inverse_transform" if they are
    implemented in the estimator used.

    The parameters of the estimator used to apply these methods are optimized
    by cross-validated search over parameter settings.

    In contrast to GridSearchCV, not all parameter values are tried out, but
    rather a fixed number of parameter settings is sampled from the specified
    distributions. The number of parameter settings that are tried is
    given by n_iter.

    If all parameters are presented as a list,
    sampling without replacement is performed. If at least one parameter
    is given as a distribution, sampling with replacement is used.
    It is highly recommended to use continuous distributions for continuous
    parameters.

    Read more in the :ref:`User Guide &lt;randomized_parameter_search&gt;`.

    .. versionadded:: 0.14

    Parameters
    ----------
    estimator : estimator object.
        A object of that type is instantiated for each grid point.
        This is assumed to implement the scikit-learn estimator interface.
        Either estimator needs to provide a ``score`` function,
        or ``scoring`` must be passed.

    param_distributions : dict or list of dicts
        Dictionary with parameters names (`str`) as keys and distributions
        or lists of parameters to try. Distributions must provide a ``rvs``
        method for sampling (such as those from scipy.stats.distributions).
        If a list is given, it is sampled uniformly.
        If a list of dicts is given, first a dict is sampled uniformly, and
        then a parameter is sampled using that dict as above.

    n_iter : int, default=10
        Number of parameter settings that are sampled. n_iter trades
        off runtime vs quality of the solution.

    scoring : str, callable, list, tuple or dict, default=None
        Strategy to evaluate the performance of the cross-validated model on
        the test set.

        If `scoring` represents a single score, one can use:

        - a single string (see :ref:`scoring_parameter`);
        - a callable (see :ref:`scoring`) that returns a single value.

        If `scoring` represents multiple scores, one can use:

        - a list or tuple of unique strings;
        - a callable returning a dictionary where the keys are the metric
          names and the values are the metric scores;
        - a dictionary with metric names as keys and callables a values.

        See :ref:`multimetric_grid_search` for an example.

        If None, the estimator's score method is used.

    n_jobs : int, default=None
        Number of jobs to run in parallel.
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;`
        for more details.

        .. versionchanged:: v0.20
           `n_jobs` default changed from 1 to None

    refit : bool, str, or callable, default=True
        Refit an estimator using the best found parameters on the whole
        dataset.

        For multiple metric evaluation, this needs to be a `str` denoting the
        scorer that would be used to find the best parameters for refitting
        the estimator at the end.

        Where there are considerations other than maximum score in
        choosing a best estimator, ``refit`` can be set to a function which
        returns the selected ``best_index_`` given the ``cv_results``. In that
        case, the ``best_estimator_`` and ``best_params_`` will be set
        according to the returned ``best_index_`` while the ``best_score_``
        attribute will not be available.

        The refitted estimator is made available at the ``best_estimator_``
        attribute and permits using ``predict`` directly on this
        ``RandomizedSearchCV`` instance.

        Also for multiple metric evaluation, the attributes ``best_index_``,
        ``best_score_`` and ``best_params_`` will only be available if
        ``refit`` is set and all of them will be determined w.r.t this specific
        scorer.

        See ``scoring`` parameter to know more about multiple metric
        evaluation.

        .. versionchanged:: 0.20
            Support for callable added.

    cv : int, cross-validation generator or an iterable, default=None
        Determines the cross-validation splitting strategy.
        Possible inputs for cv are:

        - None, to use the default 5-fold cross validation,
        - integer, to specify the number of folds in a `(Stratified)KFold`,
        - :term:`CV splitter`,
        - An iterable yielding (train, test) splits as arrays of indices.

        For integer/None inputs, if the estimator is a classifier and ``y`` is
        either binary or multiclass, :class:`StratifiedKFold` is used. In all
        other cases, :class:`KFold` is used. These splitters are instantiated
        with `shuffle=False` so the splits will be the same across calls.

        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various
        cross-validation strategies that can be used here.

        .. versionchanged:: 0.22
            ``cv`` default value if None changed from 3-fold to 5-fold.

    verbose : int
        Controls the verbosity: the higher, the more messages.

    pre_dispatch : int, or str, default=None
        Controls the number of jobs that get dispatched during parallel
        execution. Reducing this number can be useful to avoid an
        explosion of memory consumption when more jobs get dispatched
        than CPUs can process. This parameter can be:

            - None, in which case all the jobs are immediately
              created and spawned. Use this for lightweight and
              fast-running jobs, to avoid delays due to on-demand
              spawning of the jobs

            - An int, giving the exact number of total jobs that are
              spawned

            - A str, giving an expression as a function of n_jobs,
              as in '2*n_jobs'

    random_state : int, RandomState instance or None, default=None
        Pseudo random number generator state used for random uniform sampling
        from lists of possible values instead of scipy.stats distributions.
        Pass an int for reproducible output across multiple
        function calls.
        See :term:`Glossary &lt;random_state&gt;`.

    error_score : 'raise' or numeric, default=np.nan
        Value to assign to the score if an error occurs in estimator fitting.
        If set to 'raise', the error is raised. If a numeric value is given,
        FitFailedWarning is raised. This parameter does not affect the refit
        step, which will always raise the error.

    return_train_score : bool, default=False
        If ``False``, the ``cv_results_`` attribute will not include training
        scores.
        Computing training scores is used to get insights on how different
        parameter settings impact the overfitting/underfitting trade-off.
        However computing the scores on the training set can be computationally
        expensive and is not strictly required to select the parameters that
        yield the best generalization performance.

        .. versionadded:: 0.19

        .. versionchanged:: 0.21
            Default value was changed from ``True`` to ``False``

    Attributes
    ----------
    cv_results_ : dict of numpy (masked) ndarrays
        A dict with keys as column headers and values as columns, that can be
        imported into a pandas ``DataFrame``.

        For instance the below given table

        +--------------+-------------+-------------------+---+---------------+
        | param_kernel | param_gamma | split0_test_score |...|rank_test_score|
        +==============+=============+===================+===+===============+
        |    'rbf'     |     0.1     |       0.80        |...|       1       |
        +--------------+-------------+-------------------+---+---------------+
        |    'rbf'     |     0.2     |       0.84        |...|       3       |
        +--------------+-------------+-------------------+---+---------------+
        |    'rbf'     |     0.3     |       0.70        |...|       2       |
        +--------------+-------------+-------------------+---+---------------+

        will be represented by a ``cv_results_`` dict of::

            {
            'param_kernel' : masked_array(data = ['rbf', 'rbf', 'rbf'],
                                          mask = False),
            'param_gamma'  : masked_array(data = [0.1 0.2 0.3], mask = False),
            'split0_test_score'  : [0.80, 0.84, 0.70],
            'split1_test_score'  : [0.82, 0.50, 0.70],
            'mean_test_score'    : [0.81, 0.67, 0.70],
            'std_test_score'     : [0.01, 0.24, 0.00],
            'rank_test_score'    : [1, 3, 2],
            'split0_train_score' : [0.80, 0.92, 0.70],
            'split1_train_score' : [0.82, 0.55, 0.70],
            'mean_train_score'   : [0.81, 0.74, 0.70],
            'std_train_score'    : [0.01, 0.19, 0.00],
            'mean_fit_time'      : [0.73, 0.63, 0.43],
            'std_fit_time'       : [0.01, 0.02, 0.01],
            'mean_score_time'    : [0.01, 0.06, 0.04],
            'std_score_time'     : [0.00, 0.00, 0.00],
            'params'             : [{'kernel' : 'rbf', 'gamma' : 0.1}, ...],
            }

        NOTE

        The key ``'params'`` is used to store a list of parameter
        settings dicts for all the parameter candidates.

        The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and
        ``std_score_time`` are all in seconds.

        For multi-metric evaluation, the scores for all the scorers are
        available in the ``cv_results_`` dict at the keys ending with that
        scorer's name (``'_&lt;scorer_name&gt;'``) instead of ``'_score'`` shown
        above. ('split0_test_precision', 'mean_train_precision' etc.)

    best_estimator_ : estimator
        Estimator that was chosen by the search, i.e. estimator
        which gave highest score (or smallest loss if specified)
        on the left out data. Not available if ``refit=False``.

        For multi-metric evaluation, this attribute is present only if
        ``refit`` is specified.

        See ``refit`` parameter for more information on allowed values.

    best_score_ : float
        Mean cross-validated score of the best_estimator.

        For multi-metric evaluation, this is not available if ``refit`` is
        ``False``. See ``refit`` parameter for more information.

        This attribute is not available if ``refit`` is a function.

    best_params_ : dict
        Parameter setting that gave the best results on the hold out data.

        For multi-metric evaluation, this is not available if ``refit`` is
        ``False``. See ``refit`` parameter for more information.

    best_index_ : int
        The index (of the ``cv_results_`` arrays) which corresponds to the best
        candidate parameter setting.

        The dict at ``search.cv_results_['params'][search.best_index_]`` gives
        the parameter setting for the best model, that gives the highest
        mean score (``search.best_score_``).

        For multi-metric evaluation, this is not available if ``refit`` is
        ``False``. See ``refit`` parameter for more information.

    scorer_ : function or a dict
        Scorer function used on the held out data to choose the best
        parameters for the model.

        For multi-metric evaluation, this attribute holds the validated
        ``scoring`` dict which maps the scorer key to the scorer callable.

    n_splits_ : int
        The number of cross-validation splits (folds/iterations).

    refit_time_ : float
        Seconds used for refitting the best model on the whole dataset.

        This is present only if ``refit`` is not False.

        .. versionadded:: 0.20

    multimetric_ : bool
        Whether or not the scorers compute several metrics.

    Notes
    -----
    The parameters selected are those that maximize the score of the held-out
    data, according to the scoring parameter.

    If `n_jobs` was set to a value higher than one, the data is copied for each
    parameter setting(and not `n_jobs` times). This is done for efficiency
    reasons if individual jobs take very little time, but may raise errors if
    the dataset is large and not enough memory is available.  A workaround in
    this case is to set `pre_dispatch`. Then, the memory is copied only
    `pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *
    n_jobs`.

    See Also
    --------
    GridSearchCV : Does exhaustive search over a grid of parameters.
    ParameterSampler : A generator over parameter settings, constructed from
        param_distributions.

    Examples
    --------
    &gt;&gt;&gt; from sklearn.datasets import load_iris
    &gt;&gt;&gt; from sklearn.linear_model import LogisticRegression
    &gt;&gt;&gt; from sklearn.model_selection import RandomizedSearchCV
    &gt;&gt;&gt; from scipy.stats import uniform
    &gt;&gt;&gt; iris = load_iris()
    &gt;&gt;&gt; logistic = LogisticRegression(solver='saga', tol=1e-2, max_iter=200,
    ...                               random_state=0)
    &gt;&gt;&gt; distributions = dict(C=uniform(loc=0, scale=4),
    ...                      penalty=['l2', 'l1'])
    &gt;&gt;&gt; clf = RandomizedSearchCV(logistic, distributions, random_state=0)
    &gt;&gt;&gt; search = clf.fit(iris.data, iris.target)
    &gt;&gt;&gt; search.best_params_
    {'C': 2..., 'penalty': 'l1'}
    """</span>
    <span class="identifier">_required_parameters</span> <span class="arithmetic-assignment">=</span> <span class="grouping">[</span><span class="string-literal">"estimator", "param_distributions"</span><span class="grouping">]</span>

    <span class="keyword">def</span> <span class="identifier">__init__</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">param_distributions</span><span class="punctuation">,</span> <span class="arithmetic-operator">*</span><span class="punctuation">,</span> <span class="identifier">n_iter</span><span class="arithmetic-assignment">=</span><span class="int-literal">10</span><span class="punctuation">,</span>
                 <span class="identifier">scoring</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">refit</span><span class="arithmetic-assignment">=</span><span class="bool-literal">True</span><span class="punctuation">,</span>
                 <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="int-literal">0</span><span class="punctuation">,</span> <span class="identifier">pre_dispatch</span><span class="arithmetic-assignment">=</span><span class="string-literal">'2*n_jobs'</span><span class="punctuation">,</span>
                 <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="none-literal">None</span><span class="punctuation">,</span> <span class="identifier">error_score</span><span class="arithmetic-assignment">=</span><span class="identifier">np</span><span class="punctuation">.</span><span class="identifier">nan</span><span class="punctuation">,</span>
                 <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="bool-literal">False</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">param_distributions</span> <span class="arithmetic-assignment">=</span> <span class="identifier">param_distributions</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter</span> <span class="arithmetic-assignment">=</span> <span class="identifier">n_iter</span>
        <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span> <span class="arithmetic-assignment">=</span> <span class="identifier">random_state</span>
        <span class="identifier">super</span><span class="grouping">(</span><span class="grouping">)</span><span class="punctuation">.</span><span class="identifier">__init__</span><span class="grouping">(</span>
            <span class="identifier">estimator</span><span class="arithmetic-assignment">=</span><span class="identifier">estimator</span><span class="punctuation">,</span> <span class="identifier">scoring</span><span class="arithmetic-assignment">=</span><span class="identifier">scoring</span><span class="punctuation">,</span>
            <span class="identifier">n_jobs</span><span class="arithmetic-assignment">=</span><span class="identifier">n_jobs</span><span class="punctuation">,</span> <span class="identifier">refit</span><span class="arithmetic-assignment">=</span><span class="identifier">refit</span><span class="punctuation">,</span> <span class="identifier">cv</span><span class="arithmetic-assignment">=</span><span class="identifier">cv</span><span class="punctuation">,</span> <span class="identifier">verbose</span><span class="arithmetic-assignment">=</span><span class="identifier">verbose</span><span class="punctuation">,</span>
            <span class="identifier">pre_dispatch</span><span class="arithmetic-assignment">=</span><span class="identifier">pre_dispatch</span><span class="punctuation">,</span> <span class="identifier">error_score</span><span class="arithmetic-assignment">=</span><span class="identifier">error_score</span><span class="punctuation">,</span>
            <span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">e</span><span class="arithmetic-assignment">=</span><span class="invalid">r</span><span class="invalid">e</span><span class="invalid">t</span><span class="invalid">u</span><span class="invalid">r</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">t</span><span class="invalid">r</span><span class="invalid">a</span><span class="invalid">i</span><span class="invalid">n</span><span class="invalid">_</span><span class="invalid">s</span><span class="invalid">c</span><span class="invalid">o</span><span class="invalid">r</span><span class="invalid">e</span><span class="grouping">)</span>

    <span class="keyword">def</span> <span class="identifier">_run_search</span><span class="grouping">(</span><span class="identifier">self</span><span class="punctuation">,</span> <span class="identifier">evaluate_candidates</span><span class="grouping">)</span><span class="punctuation">:</span>
        <span class="comment">"""Search n_iter candidates from param_distributions"""</span>
        <span class="identifier">evaluate_candidates</span><span class="grouping">(</span><span class="identifier">ParameterSampler</span><span class="grouping">(</span>
            <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">param_distributions</span><span class="punctuation">,</span> <span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">n_iter</span><span class="punctuation">,</span>
            <span class="identifier">random_state</span><span class="arithmetic-assignment">=</span><span class="identifier">self</span><span class="punctuation">.</span><span class="identifier">random_state</span><span class="grouping">)</span><span class="grouping">)</span>

    </pre>
  </body>
</html>